# å¾®ä¿¡è‡ªåŠ¨å‘å¸ƒå·¥å…· - äº§å“éœ€æ±‚æ–‡æ¡£ (PRD)

> ç‰ˆæœ¬: v1.9
> æ—¥æœŸ: 2025-11-26
> çŠ¶æ€: **éœ€æ±‚å®šç¨¿** (æœ¬æ–‡æ¡£ä¸ºéœ€æ±‚è§„èŒƒï¼Œéå®ç°çŠ¶æ€)
> ç¼–ç : UTF-8
>
> **é‡è¦è¯´æ˜**: æœ¬æ–‡æ¡£å®šä¹‰äº§å“éœ€æ±‚è§„èŒƒã€‚æ–‡ä¸­"å·²äº¤ä»˜"æŒ‡**éœ€æ±‚å·²ç¡®å®šå¯äº¤ä»˜**ï¼Œ
> å®é™…ä»£ç å®ç°çŠ¶æ€è¯·å‚é˜…é¡¹ç›® README æˆ–ä»£ç ä»“åº“ã€‚

---

## ä¸€ã€é¡¹ç›®èƒŒæ™¯

### 1.1 ä¸šåŠ¡åœºæ™¯

ç”¨æˆ·æœ‰ä¸¤å°ç”µè„‘ååŒå·¥ä½œ:
- **ç”µè„‘ A (é€‰å“ç”µè„‘)**: è¿è¡Œé€‰å“å·¥å…·, ç®¡ç†å†œç‰¹äº§å“ã€æ–‡æ¡ˆã€å›¾ç‰‡, å¯¼å‡ºå‘å¸ƒç´ æ
- **ç”µè„‘ B (å‘å¸ƒç”µè„‘)**: è¿è¡Œæœ¬å·¥å…·, è¯»å–ç´ æå¹¶è‡ªåŠ¨å‘å¸ƒåˆ°å¾®ä¿¡

### 1.2 æ ¸å¿ƒç›®æ ‡

å¼€å‘ä¸€æ¬¾ **PC ç«¯å¾®ä¿¡è‡ªåŠ¨å‘å¸ƒå·¥å…·**, å®ç°:
- è‡ªåŠ¨å‘å¸ƒæœ‹å‹åœˆ (å›¾æ–‡/çº¯æ–‡å­—)
- è‡ªåŠ¨ç¾¤å‘æ¶ˆæ¯åˆ°å¤šä¸ªå¾®ä¿¡ç¾¤
- æ”¯æŒå®šæ—¶å‘å¸ƒã€è‡ªå®šä¹‰é¡ºåº
- æä¾›çŠ¶æ€è¿½è¸ªã€é‚®ä»¶é€šçŸ¥ã€æ•°æ®ç»Ÿè®¡

### 1.3 æŠ€æœ¯è·¯çº¿

| é¡¹ç›® | é€‰æ‹© | ç†ç”± |
|------|------|------|
| è‡ªåŠ¨åŒ–æ–¹å¼ | æ¨¡æ‹Ÿç‚¹å‡» (é Hook) | å°å·é£é™©ä½, æ— ç‰ˆæœ¬å¼ºä¾èµ– |
| æ ¸å¿ƒé©±åŠ¨ | uiautomation + pywinauto + PyAutoGUI | uiautomation å¯¹éæ ‡å‡†æ§ä»¶æ”¯æŒæ›´å¥½ |
| æ“ä½œå¹³å° | PC å¾®ä¿¡ (Windows) | æ”¯æŒæœ‹å‹åœˆå‘å¸ƒ |
| GUI æ¡†æ¶ | PySide6 (Qt) | åŠŸèƒ½å¼ºå¤§, ç•Œé¢ç¾è§‚ |
| æ•°æ®å­˜å‚¨ | SQLite | æœ¬åœ°æŒä¹…åŒ–, æ”¯æŒå¤æ‚æŸ¥è¯¢ |

---

## 1.4 å¿«é€Ÿä¸Šæ‰‹æŒ‡å—

> **ç›®çš„**: å¸®åŠ©æ–°ç”¨æˆ·åœ¨ 10 åˆ†é’Ÿå†…å®Œæˆé¦–æ¬¡å‘å¸ƒã€‚è¯¦ç»†é…ç½®å’Œé«˜çº§åŠŸèƒ½è¯·å‚é˜…åç»­ç« èŠ‚ã€‚

### æœ€å°å¯ç”¨æ­¥éª¤ (5 æ­¥å¿«é€Ÿå¯åŠ¨)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å¿«é€Ÿä¸Šæ‰‹æµç¨‹ (é¢„è®¡ 10 åˆ†é’Ÿ)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  [æ­¥éª¤ 1] ç¯å¢ƒæ£€æŸ¥ (2 åˆ†é’Ÿ)                                          â”‚
â”‚  â”œâ”€â”€ âœ“ PC å¾®ä¿¡å·²ç™»å½•å¹¶ç½®äºå‰å°                                       â”‚
â”‚  â”œâ”€â”€ âœ“ å…±äº«æ–‡ä»¶å¤¹å·²æŒ‚è½½ (é»˜è®¤: Z:\publish)                           â”‚
â”‚  â””â”€â”€ âœ“ å±å¹•åˆ†è¾¨ç‡ â‰¥ 900Ã—700 (æ¨è 1920Ã—1080ï¼ŒDPI 100%)              â”‚
â”‚           â”‚                                                         â”‚
â”‚           â–¼                                                         â”‚
â”‚  [æ­¥éª¤ 2] å¯åŠ¨å·¥å…· (1 åˆ†é’Ÿ)                                          â”‚
â”‚  â”œâ”€â”€ åŒå‡» WeChatAutoSender.exe                                      â”‚
â”‚  â””â”€â”€ ç­‰å¾…ç¯å¢ƒè‡ªæ£€é€šè¿‡ (ç»¿è‰²æç¤º)                                      â”‚
â”‚           â”‚                                                         â”‚
â”‚           â–¼                                                         â”‚
â”‚  [æ­¥éª¤ 3] å¯¼å…¥ç´ æ (3 åˆ†é’Ÿ)                                          â”‚
â”‚  â”œâ”€â”€ ç‚¹å‡»ã€Œå¯¼å…¥ Excelã€æŒ‰é’®                                          â”‚
â”‚  â”œâ”€â”€ é€‰æ‹©å‘å¸ƒæ¸…å•æ–‡ä»¶ (*.xlsx)                                       â”‚
â”‚  â””â”€â”€ ç¡®è®¤ä»»åŠ¡åˆ—è¡¨æ˜¾ç¤ºå¯¼å…¥çš„æ¡ç›®                                       â”‚
â”‚           â”‚                                                         â”‚
â”‚           â–¼                                                         â”‚
â”‚  [æ­¥éª¤ 4] è®¾ç½®å‘å¸ƒ (2 åˆ†é’Ÿ)                                          â”‚
â”‚  â”œâ”€â”€ [å¯é€‰] æ‹–æ‹½è°ƒæ•´å‘å¸ƒé¡ºåº                                         â”‚
â”‚  â”œâ”€â”€ [å¯é€‰] å³é”®è®¾ç½®å®šæ—¶å‘å¸ƒæ—¶é—´                                      â”‚
â”‚  â””â”€â”€ é€‰æ‹©ç«‹å³å‘å¸ƒæˆ–å®šæ—¶å‘å¸ƒ                                          â”‚
â”‚           â”‚                                                         â”‚
â”‚           â–¼                                                         â”‚
â”‚  [æ­¥éª¤ 5] æ‰§è¡Œå‘å¸ƒ (è‡ªåŠ¨)                                            â”‚
â”‚  â”œâ”€â”€ ç‚¹å‡»ã€Œå¼€å§‹å‘å¸ƒã€                                                â”‚
â”‚  â”œâ”€â”€ å·¥å…·è‡ªåŠ¨æ‰§è¡Œï¼Œè¯·å‹¿è§¦ç¢°é¼ æ ‡é”®ç›˜                                   â”‚
â”‚  â””â”€â”€ å®ŒæˆåæŸ¥çœ‹å›æ‰§æŠ¥å‘Š                                              â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### é¦–æ¬¡è¿è¡Œæ£€æŸ¥æ¸…å•

| æ£€æŸ¥é¡¹ | çŠ¶æ€ | è¯´æ˜ |
|--------|------|------|
| PC å¾®ä¿¡å·²ç™»å½• | [ ] | å¿…é¡»ä½¿ç”¨ PC ç‰ˆå¾®ä¿¡ï¼Œéç½‘é¡µç‰ˆ |
| å¾®ä¿¡çª—å£ç½®äºå‰å° | [ ] | ä¸è¦æœ€å°åŒ– |
| å…±äº«æ–‡ä»¶å¤¹å¯è®¿é—® | [ ] | æµ‹è¯•: èµ„æºç®¡ç†å™¨æ‰“å¼€ `Z:\publish` |
| æ˜¾ç¤ºå™¨è®¾ç½®æ­£ç¡® | [ ] | æœ€ä½ 900Ã—700ï¼›æ¨è 1920Ã—1080 + 100% DPI |
| å…³é—­å±ä¿å’Œé”å± | [ ] | é¿å…å‘å¸ƒä¸­æ–­ |

### å¸¸è§é—®é¢˜é€ŸæŸ¥

| é—®é¢˜ | åŸå›  | è§£å†³æ–¹æ¡ˆ |
|------|------|----------|
| å¯åŠ¨æ—¶æŠ¥é”™"å¾®ä¿¡æœªç™»å½•" | å¾®ä¿¡æœªè¿è¡Œæˆ–æœªç™»å½• | å…ˆç™»å½• PC å¾®ä¿¡ |
| å¯¼å…¥å¤±è´¥ | Excel æ ¼å¼ä¸æ­£ç¡® | ä½¿ç”¨æ¨¡æ¿æ–‡ä»¶å¯¼å‡ºç´ æ |
| å‘å¸ƒä¸­é€”åœæ­¢ | è§¦ç¢°äº†é¼ æ ‡é”®ç›˜ | å‘å¸ƒæœŸé—´è¯·å‹¿æ“ä½œç”µè„‘ |
| éƒ¨åˆ†ä»»åŠ¡å¤±è´¥ | ç½‘ç»œæ³¢åŠ¨æˆ–å¾®ä¿¡å¼¹çª— | æŸ¥çœ‹æ—¥å¿—ï¼Œé‡æ–°å‘å¸ƒå¤±è´¥é¡¹ |

### ä¸‹ä¸€æ­¥

- **è¯¦ç»†åŠŸèƒ½**: å‚è§ã€Œå››ã€ç³»ç»Ÿæ¶æ„ã€äº†è§£æ•´ä½“è®¾è®¡
- **é«˜çº§é…ç½®**: å‚è§ã€Œåå…«ã€éƒ¨ç½²ä¸è¿è¡Œã€è¿›è¡Œç”Ÿäº§é…ç½®
- **æ•…éšœæ’é™¤**: å‚è§ã€Œä¸‰ã€æ ¸å¿ƒå‘å¸ƒæµç¨‹ä¸å¼‚å¸¸å¤„ç†ã€äº†è§£å¼‚å¸¸å¤„ç†

---

## äºŒã€æ ¸å¿ƒæšä¸¾ä¸å¸¸é‡å®šä¹‰

> **é‡è¦**: æ‰€æœ‰ä»£ç ã€é…ç½®ã€Excel å¿…é¡»ç»Ÿä¸€ä½¿ç”¨ä»¥ä¸‹æšä¸¾å€¼

### 2.1 å‘å¸ƒæ¸ é“ (Channel)

| æšä¸¾å€¼ | Excelæ˜¾ç¤ºå€¼ | è¯´æ˜ |
|--------|-------------|------|
| `moment` | æœ‹å‹åœˆç‰ˆ | å‘å¸ƒåˆ°æœ‹å‹åœˆ |
| `group` | ç¤¾ç¾¤ç‰ˆ | å‘é€åˆ°å¾®ä¿¡ç¾¤ |

### 2.2 ä»»åŠ¡çŠ¶æ€ (TaskStatus)

| æšä¸¾å€¼ | å›¾æ ‡ | è¯´æ˜ |
|--------|------|------|
| `pending` | ç™½åœˆ | æœªæ’æœŸ |
| `scheduled` | é»„åœˆ | å·²æ’æœŸå¾…å‘å¸ƒ |
| `running` | è“åœˆ | æ­£åœ¨å‘é€ |
| `success` | ç»¿åœˆ | å‘é€æˆåŠŸ |
| `failed` | çº¢åœˆ | å‘é€å¤±è´¥ |
| `skipped` | è·³è¿‡ | å·²è·³è¿‡ |
| `cancelled` | ç¦æ­¢ | å·²å–æ¶ˆ |
| `paused` | æš‚åœ | ç†”æ–­æš‚åœä¸­ |

### 2.2.1 ä»»åŠ¡çŠ¶æ€è½¬æ¢è¡¨

```
                                    +------------------+
                                    |                  |
                     +--------------+    pending       |
                     |              |                  |
                     |              +--------+---------+
                     |                       |
                     |                       | æ’æœŸ
                     |                       v
                     |              +--------+---------+
                     |              |                  |
              å–æ¶ˆ   |   +----------+   scheduled      +----------+
                     |   |          |                  |          |
                     |   |          +--------+---------+          |
                     |   |                   |                    |
                     |   | ç†”æ–­è§¦å‘          | å¼€å§‹æ‰§è¡Œ           | è·³è¿‡
                     |   |                   v                    |
                     |   |          +--------+---------+          |
                     |   +--------->|                  |          |
                     |              |    running       |          |
                     |              |                  |          |
                     |              +----+--------+----+          |
                     |                   |        |               |
                     |           æˆåŠŸ    |        | å¤±è´¥          |
                     |                   v        v               |
                     |   +---------------+        +------------+  |
                     |   |               |        |            |  |
                     |   |   success     |        |   failed   |  |
                     |   |               |        |            |  |
                     |   +---------------+        +------+-----+  |
                     |                                   |        |
                     |                           é‡è¯•    |        |
                     |                                   v        |
                     |                           +------+-----+   |
                     |                           |            |   |
                     +-------------------------->|  cancelled |<--+
                     |                           |            |
                     |                           +------------+
                     |
                     |                           +------------+
                     +-------------------------->|            |
                                                 |   skipped  |
                                                 |            |
                                                 +------------+
```

**çŠ¶æ€è½¬æ¢è§„åˆ™:**

| å½“å‰çŠ¶æ€ | å¯è½¬æ¢è‡³ | è§¦å‘æ¡ä»¶ |
|----------|----------|----------|
| `pending` | `scheduled` | ç”¨æˆ·è®¾ç½®æ’æœŸæ—¶é—´ |
| `pending` | `cancelled` | ç”¨æˆ·å–æ¶ˆä»»åŠ¡ |
| `pending` | `skipped` | ç”¨æˆ·è·³è¿‡ä»»åŠ¡ |
| `scheduled` | `running` | åˆ°è¾¾æ’æœŸæ—¶é—´, å¼€å§‹æ‰§è¡Œ |
| `scheduled` | `paused` | ç†”æ–­å™¨è§¦å‘ |
| `scheduled` | `cancelled` | ç”¨æˆ·å–æ¶ˆä»»åŠ¡ |
| `scheduled` | `skipped` | ç”¨æˆ·è·³è¿‡ä»»åŠ¡ |
| `running` | `success` | æ‰§è¡ŒæˆåŠŸ |
| `running` | `failed` | æ‰§è¡Œå¤±è´¥ |
| `failed` | `scheduled` | é‡è¯• (retry_count < max_retry) |
| `failed` | `cancelled` | è¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°æˆ–ç”¨æˆ·å–æ¶ˆ |
| `paused` | `scheduled` | ç†”æ–­æ¢å¤ |
| `paused` | `cancelled` | ç”¨æˆ·å–æ¶ˆ |

**é‡è¦çº¦æŸ:**
- `success`ã€`cancelled`ã€`skipped` ä¸ºç»ˆæ€, ä¸å¯å†è½¬æ¢
- `running` çŠ¶æ€åŒä¸€æ—¶åˆ»æœ€å¤šåªèƒ½æœ‰ä¸€ä¸ªä»»åŠ¡ (å•çº¿ç¨‹æ‰§è¡Œ)
- ç¨‹åºå¼‚å¸¸é€€å‡ºæ—¶, `running` çŠ¶æ€ä»»åŠ¡éœ€æ ‡è®°ä¸º `failed`

### 2.2.2 çŠ¶æ€æœ¯è¯­ç»Ÿä¸€è§„èŒƒ

> **å¼ºåˆ¶è¦æ±‚**: ä»£ç ã€UIã€æ•°æ®åº“ã€æ—¥å¿—ä¸­å¿…é¡»ä½¿ç”¨ç»Ÿä¸€çš„çŠ¶æ€æœ¯è¯­ï¼Œç¦æ­¢ä½¿ç”¨åˆ«åã€‚

#### æœ¯è¯­å¯¹ç…§è¡¨

| æ ‡å‡†æœ¯è¯­ | ç¦ç”¨åˆ«å | UI æ˜¾ç¤º | æ•°æ®åº“å­—æ®µå€¼ | æ—¥å¿—å…³é”®è¯ |
|----------|----------|---------|--------------|------------|
| `pending` | waiting, queued, new | å¾…æ’æœŸ | `pending` | [PENDING] |
| `scheduled` | planned, queued | å·²æ’æœŸ | `scheduled` | [SCHEDULED] |
| `running` | ~~executing~~, active, processing | æ‰§è¡Œä¸­ | `running` | [RUNNING] |
| `success` | completed, done, finished | æˆåŠŸ | `success` | [SUCCESS] |
| `failed` | error, fail | å¤±è´¥ | `failed` | [FAILED] |
| `skipped` | ignored, bypassed | å·²è·³è¿‡ | `skipped` | [SKIPPED] |
| `cancelled` | canceled, aborted | å·²å–æ¶ˆ | `cancelled` | [CANCELLED] |
| `paused` | suspended, halted | å·²æš‚åœ | `paused` | [PAUSED] |

> **æ³¨æ„**: `executing` æ›¾åœ¨æ—©æœŸä»£ç ä¸­ä½¿ç”¨ï¼Œå·²åºŸå¼ƒï¼Œå¿…é¡»ç»Ÿä¸€ä¸º `running`ã€‚

#### çŠ¶æ€åŸå› æ ‡å‡†å€¼

ä¸ºé¿å…æ–°å¢éæ ‡å‡†çŠ¶æ€ (å¦‚ `missed`ã€`pending_manual_review`)ï¼Œä½¿ç”¨åŸå› å­—æ®µä¿ç•™è¯­ä¹‰ï¼š

| çŠ¶æ€ | åŸå› å­—æ®µ | æ ‡å‡†å€¼ | è¯´æ˜ |
|------|----------|--------|------|
| `failed` | `failure_reason` | `execution_error` | æ‰§è¡Œè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ |
| `failed` | `failure_reason` | `missed_schedule` | æ¼å‘ (é”™è¿‡è®¡åˆ’æ—¶é—´) |
| `failed` | `failure_reason` | `risk_shutdown` | é£æ§åœæœºå¯¼è‡´å¤±è´¥ |
| `failed` | `failure_reason` | `max_retry_exceeded` | è¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•° |
| `paused` | `pause_reason` | `circuit_breaker` | ç†”æ–­å™¨è§¦å‘æš‚åœ |
| `paused` | `pause_reason` | `manual_review` | éœ€äººå·¥å®¡æ ¸ (GIF/æ˜¾ç¤ºå™¨é—®é¢˜ç­‰) |
| `paused` | `pause_reason` | `user_pause` | ç”¨æˆ·æ‰‹åŠ¨æš‚åœ |
| `paused` | `pause_reason` | `queue_pause` | é˜Ÿåˆ—æ•´ä½“æš‚åœ |

> **é‡è¦**: ç¦æ­¢ç›´æ¥ä½¿ç”¨ `missed`ã€`pending_manual_review` ç­‰éæ ‡å‡†çŠ¶æ€å€¼å†™å…¥æ•°æ®åº“ï¼Œä¼šè§¦å‘ CHECK çº¦æŸå¤±è´¥ã€‚

#### æ•°æ®åº“ Schema (ä»»åŠ¡è¡¨)

```sql
-- tasks è¡¨å®šä¹‰
CREATE TABLE tasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    content_code TEXT NOT NULL,              -- äº§å“ç¼–ç 
    product_name TEXT,                        -- äº§å“åç§°
    channel TEXT NOT NULL CHECK(channel IN ('moment', 'group')),
    group_name TEXT,                          -- ç¾¤å (ä»… group æ¸ é“)

    -- çŠ¶æ€å­—æ®µ (ä½¿ç”¨æ ‡å‡†æœ¯è¯­)
    status TEXT NOT NULL DEFAULT 'pending'
        CHECK(status IN ('pending', 'scheduled', 'running', 'success', 'failed', 'skipped', 'cancelled', 'paused')),

    -- è°ƒåº¦ç›¸å…³
    scheduled_time DATETIME,                  -- æ’æœŸæ—¶é—´
    scheduled_date TEXT GENERATED ALWAYS AS (DATE(scheduled_time)) STORED,  -- æ’æœŸæ—¥æœŸ (è‡ªåŠ¨è®¡ç®—)
    priority INTEGER DEFAULT 5,               -- ä¼˜å…ˆçº§ 1-10
    retry_count INTEGER DEFAULT 0,            -- é‡è¯•æ¬¡æ•°
    max_retry INTEGER DEFAULT 3,              -- æœ€å¤§é‡è¯•æ¬¡æ•°
    reschedule_count INTEGER DEFAULT 0,       -- é‡è°ƒåº¦æ¬¡æ•° (å› ç¯å¢ƒé—®é¢˜)

    -- æ‰§è¡Œç»“æœ
    executed_time DATETIME,                   -- å®é™…æ‰§è¡Œæ—¶é—´
    error_message TEXT,                       -- é”™è¯¯ä¿¡æ¯
    screenshot_path TEXT,                     -- æˆªå›¾è·¯å¾„

    -- çŠ¶æ€åŸå› å­—æ®µ (ç”¨äºä¿ç•™è¯­ä¹‰ï¼Œé¿å…æ–°å¢éæ ‡å‡†çŠ¶æ€)
    failure_reason TEXT,                      -- å¤±è´¥åŸå› : execution_error/missed_schedule/...
    pause_reason TEXT,                        -- æš‚åœåŸå› : circuit_breaker/manual_review/...
    pause_detail TEXT,                        -- æš‚åœè¯¦æƒ…æè¿°
    skip_reason TEXT,                         -- è·³è¿‡åŸå› : idempotent_check/manual_skip/...
    note TEXT,                                -- å¤‡æ³¨ä¿¡æ¯ (è¡¥å‘è¯´æ˜ç­‰)

    -- æš‚åœç›¸å…³
    paused_at DATETIME,                       -- è¿›å…¥ paused çŠ¶æ€çš„æ—¶é—´

    -- å…ƒæ•°æ®
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,

    -- å¹‚ç­‰é”® (å”¯ä¸€çº¦æŸ)
    -- æ³¨: åŒ…å« group_name ä»¥æ”¯æŒ"åŒä¸€å†…å®¹å‘é€åˆ°å¤šä¸ªç¾¤"çš„åœºæ™¯
    -- å¯¹äºæœ‹å‹åœˆ (moment)ï¼Œgroup_name ä¸º NULLï¼ŒUNIQUE çº¦æŸä»ç„¶ç”Ÿæ•ˆ
    -- ä½¿ç”¨ GENERATED åˆ—è€Œéè¡¨è¾¾å¼ï¼Œå› ä¸º SQLite ä¸å…è®¸åœ¨ UNIQUE çº¦æŸä¸­ä½¿ç”¨å‡½æ•°
    UNIQUE(content_code, channel, group_name, scheduled_date)
);

-- æ³¨æ„: è¦æ±‚ SQLite >= 3.31.0 (2020-01-22) ä»¥æ”¯æŒ GENERATED ALWAYS AS

-- çŠ¶æ€ç´¢å¼•
CREATE INDEX idx_tasks_status ON tasks(status);
CREATE INDEX idx_tasks_scheduled_time ON tasks(scheduled_time);
CREATE INDEX idx_tasks_channel_status ON tasks(channel, status);
```

#### çŠ¶æ€æšä¸¾å®šä¹‰ (Python)

```python
# models/enums.py

from enum import Enum

class TaskStatus(str, Enum):
    """
    ä»»åŠ¡çŠ¶æ€æšä¸¾

    é‡è¦: ç¦æ­¢æ·»åŠ åˆ«åæˆ–æ–°çŠ¶æ€ï¼Œæ‰€æœ‰çŠ¶æ€å˜æ›´å¿…é¡»ç»è¿‡æ¶æ„è¯„å®¡
    """
    PENDING = "pending"       # æœªæ’æœŸ
    SCHEDULED = "scheduled"   # å·²æ’æœŸå¾…å‘å¸ƒ
    RUNNING = "running"       # æ­£åœ¨æ‰§è¡Œ (ç¦ç”¨ executing)
    SUCCESS = "success"       # æ‰§è¡ŒæˆåŠŸ
    FAILED = "failed"         # æ‰§è¡Œå¤±è´¥
    SKIPPED = "skipped"       # å·²è·³è¿‡
    CANCELLED = "cancelled"   # å·²å–æ¶ˆ
    PAUSED = "paused"         # ç†”æ–­æš‚åœ

    @classmethod
    def terminal_states(cls) -> set:
        """ç»ˆæ€é›†åˆ (ä¸å¯å†è½¬æ¢)"""
        return {cls.SUCCESS, cls.CANCELLED, cls.SKIPPED}

    @classmethod
    def active_states(cls) -> set:
        """æ´»è·ƒçŠ¶æ€ (å¯ç»§ç»­å¤„ç†)"""
        return {cls.PENDING, cls.SCHEDULED, cls.RUNNING, cls.PAUSED, cls.FAILED}

    def is_terminal(self) -> bool:
        """æ˜¯å¦ä¸ºç»ˆæ€"""
        return self in self.terminal_states()
```

#### UI çŠ¶æ€å›¾æ ‡æ˜ å°„

```python
# ui/status_icons.py

STATUS_DISPLAY = {
    'pending':   {'icon': 'â—‹', 'color': '#CCCCCC', 'text': 'å¾…æ’æœŸ'},
    'scheduled': {'icon': 'â—', 'color': '#FFA500', 'text': 'å·²æ’æœŸ'},
    'running':   {'icon': 'â—', 'color': '#2196F3', 'text': 'æ‰§è¡Œä¸­'},
    'success':   {'icon': 'âœ“', 'color': '#4CAF50', 'text': 'æˆåŠŸ'},
    'failed':    {'icon': 'âœ—', 'color': '#F44336', 'text': 'å¤±è´¥'},
    'skipped':   {'icon': 'âŠ˜', 'color': '#9E9E9E', 'text': 'å·²è·³è¿‡'},
    'cancelled': {'icon': 'âŠ', 'color': '#9E9E9E', 'text': 'å·²å–æ¶ˆ'},
    'paused':    {'icon': 'â¸', 'color': '#FF9800', 'text': 'å·²æš‚åœ'},
}
```

### 2.3 ä¼˜å…ˆçº§ (Priority)

| å€¼ | è¯´æ˜ |
|----|------|
| 1-3 | ä½ä¼˜å…ˆçº§ |
| 4-6 | æ™®é€šä¼˜å…ˆçº§ (é»˜è®¤5) |
| 7-9 | é«˜ä¼˜å…ˆçº§ |
| 10 | ç´§æ€¥ (ç«‹å³æ’é˜Ÿ) |

### 2.4 æ—¶é—´æ ¼å¼è§„èŒƒ

| åœºæ™¯ | æ ¼å¼ | ç¤ºä¾‹ |
|------|------|------|
| æ—¥æœŸ | `YYYY-MM-DD` | 2024-11-25 |
| æ—¶é—´ | `HH:mm:ss` | 09:00:00 |
| æ—¥æœŸæ—¶é—´ | `YYYY-MM-DD HH:mm:ss` | 2024-11-25 09:00:00 |
| æ—¶åŒº | ç»Ÿä¸€ä½¿ç”¨ **Asia/Shanghai (UTC+8)** | - |

---

## ä¸‰ã€æ ¸å¿ƒå‘å¸ƒæµç¨‹ä¸å¼‚å¸¸å¤„ç†

> **æœ¬ç« ç›®æ ‡**: å®šä¹‰è‡ªåŠ¨å‘å¸ƒçš„ä¸»æµç¨‹æ—¶åºã€å¼‚å¸¸åˆ†æ”¯å¤„ç†ç­–ç•¥ã€ç”¨æˆ·åé¦ˆç»Ÿä¸€è§„èŒƒã€‚

### 3.1 æ ¸å¿ƒå‘å¸ƒæµç¨‹æ—¶åºå›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç”¨æˆ·   â”‚  â”‚  å¯¼å…¥å™¨  â”‚  â”‚  è°ƒåº¦å™¨  â”‚  â”‚  æ‰§è¡Œå™¨  â”‚  â”‚  é£æ§å™¨  â”‚  â”‚  é€šçŸ¥å™¨  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚             â”‚             â”‚             â”‚             â”‚             â”‚
     â”‚ 1.å¯¼å…¥Excel â”‚             â”‚             â”‚             â”‚             â”‚
     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚             â”‚             â”‚             â”‚             â”‚
     â”‚             â”‚             â”‚             â”‚             â”‚             â”‚
     â”‚             â”‚ 2.æ ¡éªŒæ•°æ®  â”‚             â”‚             â”‚             â”‚
     â”‚             â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚             â”‚             â”‚             â”‚
     â”‚             â”‚             â”‚             â”‚             â”‚             â”‚
     â”‚             â”‚ 3.è¿”å›æ ¡éªŒç»“æœ              â”‚             â”‚             â”‚
     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚             â”‚             â”‚             â”‚             â”‚
     â”‚             â”‚             â”‚             â”‚             â”‚             â”‚
     â”‚ 4.ç¡®è®¤æ’æœŸ  â”‚             â”‚             â”‚             â”‚             â”‚
     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-->â”‚             â”‚             â”‚             â”‚
     â”‚             â”‚             â”‚             â”‚             â”‚             â”‚
     â”‚             â”‚             â”‚ 5.åˆ°è¾¾æ‰§è¡Œæ—¶é—´            â”‚             â”‚
     â”‚             â”‚             â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚             â”‚             â”‚
     â”‚             â”‚             â”‚             â”‚             â”‚             â”‚
     â”‚             â”‚             â”‚             â”‚ 6.æ‰§è¡Œå‰é£æ§æ£€æŸ¥           â”‚
     â”‚             â”‚             â”‚             â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚             â”‚
     â”‚             â”‚             â”‚             â”‚             â”‚             â”‚
     â”‚             â”‚             â”‚             â”‚ 7.é£æ§é€šè¿‡  â”‚             â”‚
     â”‚             â”‚             â”‚             â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚             â”‚
     â”‚             â”‚             â”‚             â”‚             â”‚             â”‚
     â”‚             â”‚             â”‚             â”‚ 8.æ‰§è¡Œå‘å¸ƒ (æœ‹å‹åœˆ/ç¾¤æ¶ˆæ¯)  â”‚
     â”‚             â”‚             â”‚             â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚
     â”‚             â”‚             â”‚             â”‚                           â”‚
     â”‚             â”‚             â”‚             â”‚ 9.è®°å½•ç»“æœ & æ›´æ–°çŠ¶æ€      â”‚
     â”‚             â”‚             â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚             â”‚             â”‚
     â”‚             â”‚             â”‚             â”‚             â”‚             â”‚
     â”‚             â”‚             â”‚ 10.è§¦å‘é€šçŸ¥ â”‚             â”‚             â”‚
     â”‚             â”‚             â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚             â”‚             â”‚             â”‚             â”‚             â”‚
     â”‚ 11.é‚®ä»¶/å›æ‰§/çŠ¶æ€æ æ›´æ–°   â”‚             â”‚             â”‚             â”‚
     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
     â”‚             â”‚             â”‚             â”‚             â”‚             â”‚
```

### 3.2 å¼‚å¸¸åˆ†æ”¯å¤„ç†ç­–ç•¥

| å¼‚å¸¸åœºæ™¯ | è§¦å‘æ¡ä»¶ | ç³»ç»Ÿè¡Œä¸º | ä»»åŠ¡çŠ¶æ€ | ç”¨æˆ·åé¦ˆ |
|----------|----------|----------|----------|----------|
| **é£æ§åœæœº** | æ£€æµ‹åˆ°å°å·é£é™©çª—å£/OCRå…³é”®è¯ | ç«‹å³åœæ­¢æ‰€æœ‰æ“ä½œï¼Œåˆ›å»ºåœæœºæ ‡è®° | å½“å‰ä»»åŠ¡â†’`failed`ï¼Œé˜Ÿåˆ—â†’`paused` | çŠ¶æ€æ çº¢è‰² + å¼¹çª— + é‚®ä»¶ |
| **æ˜¾ç¤ºå™¨å¤±è´¥** | çª—å£ç§»åŠ¨/å‰å°å¤±è´¥è¶…è¿‡é‡è¯•æ¬¡æ•° | æŒ‰ç­–ç•¥å¤„ç† (failed/manual/reschedule/pause_all) | è§†ç­–ç•¥è€Œå®š | çŠ¶æ€æ é»„è‰² + æ—¥å¿— |
| **å¹‚ç­‰å†²çª** | é‡å¤ä»»åŠ¡é”®æ£€æµ‹ | è·³è¿‡æ‰§è¡Œï¼Œè®°å½•æ—¥å¿— | ä¿æŒåŸçŠ¶æ€/æ ‡è®°`skipped` | æ—¥å¿—è®°å½• |
| **è¡¥å‘å†²çª** | å¤šä¸ªè¡¥å‘è¯·æ±‚ç«äº‰ | ä¼˜å…ˆçº§ä»²è£ (manual>auto>cross_day) | ä½ä¼˜å…ˆçº§è¯·æ±‚å–æ¶ˆ | æ—¥å¿— + å¯é€‰é‚®ä»¶ |
| **æ¨¡æ¿æ›´æ–°å¤±è´¥** | ç­¾åéªŒè¯å¤±è´¥/ä¸‹è½½ä¸­æ–­ | å›æ»šåˆ°ä¸Šä¸€ç‰ˆæœ¬ï¼Œåˆ›å»ºå¤±è´¥æ ‡è®° | ä¸å½±å“å·²æ’æœŸä»»åŠ¡ | å¯åŠ¨æ—¶å¼¹çª—é˜»æ–­ |
| **GIF æ— äººå€¼å®ˆ** | æ— äººå€¼å®ˆæ¨¡å¼ä¸‹æ£€æµ‹åˆ° GIF | è‡ªåŠ¨å–æ¶ˆä»»åŠ¡ | `cancelled` | é‚®ä»¶å‘Šè­¦ |
| **å¾®ä¿¡æœªç™»å½•** | å¯åŠ¨æ£€æŸ¥/æ‰§è¡Œå‰æ£€æµ‹ | é˜»æ­¢å¯åŠ¨æˆ–æš‚åœæ‰§è¡Œ | é˜Ÿåˆ—â†’`paused` | å¼¹çª— + çŠ¶æ€æ  |
| **å…±äº«æ–‡ä»¶å¤¹ä¸å¯ç”¨** | ç½‘ç»œæ–­å¼€/æƒé™é—®é¢˜ | é˜»æ­¢å¯åŠ¨ | æ—  | å¯åŠ¨å¼¹çª— |
| **å‰ªè´´æ¿è¢«å ç”¨** | å…¶ä»–ç¨‹åºé”å®šå‰ªè´´æ¿ | é‡è¯•3æ¬¡åå¤±è´¥ | å½“å‰ä»»åŠ¡â†’`failed` | çŠ¶æ€æ  + æ—¥å¿— |
| **ä»»åŠ¡æ‰§è¡Œè¶…æ—¶** | å•ä»»åŠ¡è¶…è¿‡5åˆ†é’Ÿ | å¼ºåˆ¶ç»ˆæ­¢ï¼Œæ ‡è®°å¤±è´¥ | `failed` | æ—¥å¿— + é‚®ä»¶ |

### 3.3 ç”¨æˆ·åé¦ˆç»Ÿä¸€ç­–ç•¥çŸ©é˜µ

> **åŸåˆ™**: åŒä¸€ç±»äº‹ä»¶ï¼Œç”¨æˆ·æ„ŸçŸ¥æ–¹å¼å¿…é¡»ä¸€è‡´ã€‚

| äº‹ä»¶ç±»å‹ | çŠ¶æ€æ  | å¼¹çª— | é‚®ä»¶ | æ—¥å¿— | å›æ‰§ | Webhook |
|----------|--------|------|------|------|------|---------|
| **æ­£å¸¸å®Œæˆ** | âœ… ç»¿è‰²å›¾æ ‡ | - | æ¯æ—¥æ±‡æ€» | INFO | è®°å½• | å¯é€‰ |
| **éƒ¨åˆ†å¤±è´¥** | âš ï¸ é»„è‰²å›¾æ ‡ | - | å³æ—¶ | WARN | è®°å½• | å¯é€‰ |
| **é£æ§åœæœº** | ğŸ”´ çº¢è‰²é—ªçƒ | å¼ºåˆ¶å¼¹çª— | å³æ—¶+çŸ­ä¿¡ | ERROR | è®°å½• | å¼ºåˆ¶ |
| **ç†”æ–­è§¦å‘** | ğŸ”´ çº¢è‰²å›¾æ ‡ | å¼¹çª— | å³æ—¶ | WARN | è®°å½• | å¯é€‰ |
| **é…ç½®é”™è¯¯** | ğŸ”´ çº¢è‰²å›¾æ ‡ | å¯åŠ¨å¼¹çª— | - | ERROR | - | - |
| **ç½‘ç»œé—®é¢˜** | âš ï¸ é»„è‰²å›¾æ ‡ | å¯é€‰å¼¹çª— | é‡è¯•ç”¨å°½å | WARN | - | - |
| **æƒé™ä¸è¶³** | - | å¼¹çª— | - | WARN | - | - |
| **GIF å–æ¶ˆ** | âš ï¸ é»„è‰²å›¾æ ‡ | - | å³æ—¶ | WARN | è®°å½• | å¯é€‰ |

### 3.4 çŠ¶æ€æ å›¾æ ‡è§„èŒƒ

| å›¾æ ‡ | é¢œè‰² | å«ä¹‰ | æŒç»­æ—¶é—´ |
|------|------|------|----------|
| â— | ç°è‰² | ç©ºé—²/æ— ä»»åŠ¡ | æŒç»­ |
| â— | ç»¿è‰² | æ­£å¸¸è¿è¡Œä¸­ | æ‰§è¡ŒæœŸé—´ |
| â— | è“è‰² | æœ‰ä»»åŠ¡æ’é˜Ÿ | æŒç»­ |
| â— | é»„è‰² | è­¦å‘Š/éƒ¨åˆ†å¤±è´¥ | ç›´åˆ°ç¡®è®¤ |
| â— | çº¢è‰² | é”™è¯¯/åœæœº | ç›´åˆ°å¤„ç† |
| â—‹ | çº¢è‰²é—ªçƒ | ç´§æ€¥/é£æ§è§¦å‘ | ç›´åˆ°å¤„ç† |

### 3.5 å¼‚å¸¸æ¢å¤æ“ä½œæŒ‡å¼•

| å¼‚å¸¸ | æ¢å¤æ“ä½œ | è‡ªåŠ¨/æ‰‹åŠ¨ | æ“ä½œå…¥å£ |
|------|----------|-----------|----------|
| é£æ§åœæœº | 1. æ£€æŸ¥å¾®ä¿¡çŠ¶æ€ 2. åˆ é™¤åœæœºæ ‡è®° 3. é‡å¯ç¨‹åº | æ‰‹åŠ¨ | æ–‡ä»¶ç³»ç»Ÿ + ç¨‹åºé‡å¯ |
| ç†”æ–­è§¦å‘ | ç­‰å¾…å†·å´æ—¶é—´æˆ–æ‰‹åŠ¨é‡ç½® | è‡ªåŠ¨/æ‰‹åŠ¨ | çŠ¶æ€æ å³é”®èœå• |
| æ˜¾ç¤ºå™¨å¤±è´¥ | è°ƒæ•´çª—å£ä½ç½®ï¼Œé‡è¯•ä»»åŠ¡ | æ‰‹åŠ¨ | ä»»åŠ¡åˆ—è¡¨å³é”® |
| æ¨¡æ¿æ›´æ–°å¤±è´¥ | 1. æ£€æŸ¥ç½‘ç»œ 2. éªŒè¯ç­¾å 3. åˆ é™¤å¤±è´¥æ ‡è®° | æ‰‹åŠ¨ | é…ç½®ç•Œé¢ |
| å¾®ä¿¡æœªç™»å½• | ç™»å½•å¾®ä¿¡åé‡å¯ç¨‹åº | æ‰‹åŠ¨ | - |
| è¡¥å‘å†²çª | å–æ¶ˆä½ä¼˜å…ˆçº§è¯·æ±‚æˆ–å¼ºåˆ¶æ‰§è¡Œ | è‡ªåŠ¨/æ‰‹åŠ¨ | è¡¥å‘é˜Ÿåˆ—ç•Œé¢ |

### 3.6 å¼‚å¸¸å¤„ç†æµç¨‹å›¾

```
                          ä»»åŠ¡æ‰§è¡Œå¼€å§‹
                               â”‚
                               â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚    æ‰§è¡Œå‰æ£€æŸ¥       â”‚
                    â”‚  (é£æ§/ç™»å½•/æ˜¾ç¤ºå™¨) â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚                â”‚                â”‚
              â–¼                â–¼                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ é£æ§å¼‚å¸¸ â”‚    â”‚ æ£€æŸ¥é€šè¿‡ â”‚    â”‚ æ˜¾ç¤ºå™¨å¼‚å¸¸â”‚
        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
             â”‚               â”‚               â”‚
             â–¼               â–¼               â–¼
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ ç«‹å³åœæœº     â”‚  â”‚ æ‰§è¡Œå‘å¸ƒ â”‚   â”‚ é‡è¯•ç­–ç•¥    â”‚
     â”‚ é€šçŸ¥+æ ‡è®°    â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚                â”‚
                            â”‚          â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚           â”‚
                   â”‚        â”‚        â”‚ â–¼           â–¼
                   â–¼        â–¼        â–¼ é‡è¯•æˆåŠŸ   é‡è¯•ç”¨å°½
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”  â”‚      â”‚
             â”‚ æ‰§è¡ŒæˆåŠŸâ”‚ â”‚è¶…æ—¶ â”‚ â”‚å¤±è´¥ â”‚  â”‚      â–¼
             â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚         â”‚       â”‚     â”‚  â”‚æŒ‰ç­–ç•¥  â”‚
                  â–¼         â–¼       â–¼     â”‚  â”‚å¤„ç†    â”‚
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚    æ›´æ–°çŠ¶æ€ + é€šçŸ¥     â”‚<â”€â”€â”˜
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## å››ã€ç³»ç»Ÿæ¶æ„

### 4.1 æ•´ä½“æ¶æ„å›¾

```
+---------------------------------------------------------------------+
|                         ç”µè„‘ A (é€‰å“ç”µè„‘)                            |
|  +---------------------------------------------------------------+  |
|  |  é€‰å“å·¥å…· (Next.js + Prisma + SQLite)                          |  |
|  |  - ç®¡ç†äº§å“/æ–‡æ¡ˆ/å›¾ç‰‡                                           |  |
|  |  - å¯¼å‡º Excel + å›¾ç‰‡ (ç›¸å¯¹è·¯å¾„)                                 |  |
|  |  - [åç»­] æä¾› REST API                                         |  |
|  +---------------------------------------------------------------+  |
|                              |                                       |
|                     å…±äº«æ–‡ä»¶å¤¹ / API                                  |
+------------------------------+---------------------------------------+
                               |
                          å±€åŸŸç½‘ä¼ è¾“
                               |
+------------------------------+---------------------------------------+
|                         ç”µè„‘ B (å‘å¸ƒç”µè„‘)                            |
|  +---------------------------------------------------------------+  |
|  |  å¾®ä¿¡è‡ªåŠ¨å‘å¸ƒå·¥å…· (Python + PySide6)                           |  |
|  |  +-----------------------------------------------------------+  |  |
|  |  | UI å±‚: ä»»åŠ¡åˆ—è¡¨ã€é¢„è§ˆã€å®šæ—¶è®¾ç½®ã€æ—¥å¿—ã€é…ç½®                 |  |  |
|  |  +-----------------------------------------------------------+  |  |
|  |  | è°ƒåº¦å±‚: å®šæ—¶å™¨ + ä»»åŠ¡é˜Ÿåˆ— (ä¼˜å…ˆçº§ã€æš‚åœã€é‡è¯•)              |  |  |
|  |  +-----------------------------------------------------------+  |  |
|  |  | æ‰§è¡Œå™¨: æœ‹å‹åœˆå‘å¸ƒå™¨ã€ç¾¤å‘å™¨ã€æˆªå›¾/å¼¹çª—æ£€æµ‹                 |  |  |
|  |  +-----------------------------------------------------------+  |  |
|  |  | æ•°æ®å±‚: Excel è§£æã€SQLite å­˜å‚¨ã€æ–‡ä»¶ç¼“å­˜                   |  |  |
|  |  +-----------------------------------------------------------+  |  |
|  |  | é€šçŸ¥å±‚: é‚®ä»¶å‘é€ã€ç»Ÿè®¡èšåˆã€å›æ‰§ç”Ÿæˆ                        |  |  |
|  |  +-----------------------------------------------------------+  |  |
|  +---------------------------------------------------------------+  |
+---------------------------------------------------------------------+
```

### 4.2 æ¨¡å—åˆ’åˆ†

```
wechat-auto-sender/
|-- main.py                    # ä¸»ç¨‹åºå…¥å£
|-- config.yaml                # é…ç½®æ–‡ä»¶ (æ”¯æŒå¤šç¯å¢ƒ)
|-- selectors.yaml             # UI é€‰æ‹©å™¨é…ç½® (å¤–éƒ¨åŒ–, çƒ­æ›´æ–°)
|-- requirements.txt           # ä¾èµ–æ¸…å•
|
|-- gui/                       # UI å±‚
|   |-- __init__.py
|   |-- main_window.py         # ä¸»çª—å£ (æ ‡ç­¾é¡µå®¹å™¨)
|   |-- queue_tab.py           # å‘å¸ƒé˜Ÿåˆ—æ ‡ç­¾é¡µ
|   |-- schedule_tab.py        # å®šæ—¶è®¾ç½®æ ‡ç­¾é¡µ
|   |-- stats_tab.py           # æ•°æ®ç»Ÿè®¡æ ‡ç­¾é¡µ
|   |-- settings_tab.py        # ç³»ç»Ÿè®¾ç½®æ ‡ç­¾é¡µ
|   |-- preview_dialog.py      # å‘å¸ƒé¢„è§ˆå¼¹çª—
|   |-- log_panel.py           # å®æ—¶æ—¥å¿—é¢æ¿
|   +-- styles.py              # æ ·å¼å®šä¹‰
|
|-- core/                      # æ‰§è¡Œå™¨å±‚
|   |-- __init__.py
|   |-- wechat_controller.py   # å¾®ä¿¡çª—å£æ§åˆ¶ (uiautomation)
|   |-- moment_sender.py       # æœ‹å‹åœˆå‘å¸ƒå™¨
|   |-- group_sender.py        # ç¾¤å‘æ¶ˆæ¯å™¨
|   |-- element_locator.py     # å…ƒç´ å®šä½ (è¯»å– selectors.yaml)
|   |-- popup_detector.py      # å¼¹çª—/é£æ§æ£€æµ‹
|   |-- clipboard_manager.py   # å‰ªè´´æ¿ç®¡ç† (å¤‡ä»½/æ¢å¤/é”å®š)
|   |-- process_guardian.py    # è¿›ç¨‹å®ˆæŠ¤ (å¾®ä¿¡å´©æºƒè‡ªåŠ¨é‡å¯)
|   +-- env_checker.py         # ç¯å¢ƒè‡ªæ£€æ¨¡å—
|
|-- data/                      # æ•°æ®å±‚
|   |-- __init__.py
|   |-- data_source.py         # ç»Ÿä¸€æ•°æ®æºæ¥å£
|   |-- excel_parser.py        # Excel è§£æ + æ ¡éªŒ
|   |-- path_mapper.py         # è·¯å¾„æ˜ å°„ (æœ¬åœ°<->å…±äº«)
|   |-- image_loader.py        # å›¾ç‰‡åŠ è½½ + ç¼“å­˜
|   |-- database.py            # SQLite æ•°æ®åº“æ“ä½œ
|   +-- receipt_generator.py   # å›æ‰§æ–‡ä»¶ç”Ÿæˆ
|
|-- scheduler/                 # è°ƒåº¦å±‚
|   |-- __init__.py
|   |-- task_scheduler.py      # å®šæ—¶ä»»åŠ¡è°ƒåº¦ (APScheduler)
|   |-- queue_manager.py       # ä»»åŠ¡é˜Ÿåˆ—ç®¡ç†
|   |-- retry_handler.py       # é‡è¯•é€»è¾‘ (æŒ‡æ•°å›é€€)
|   +-- circuit_breaker.py     # ç†”æ–­å™¨ (è¿ç»­å¤±è´¥æš‚åœ)
|
|-- models/                    # æ•°æ®æ¨¡å‹
|   |-- __init__.py
|   |-- task.py                # ä»»åŠ¡æ¨¡å‹
|   |-- content.py             # å†…å®¹æ¨¡å‹
|   |-- enums.py               # æšä¸¾å®šä¹‰
|   +-- stats.py               # ç»Ÿè®¡æ¨¡å‹
|
|-- services/                  # æœåŠ¡å±‚
|   |-- __init__.py
|   |-- email_notifier.py      # é‚®ä»¶é€šçŸ¥
|   |-- voice_notifier.py      # è¯­éŸ³é€šçŸ¥ (TTS)
|   |-- notification_manager.py # é€šçŸ¥ç®¡ç†å™¨ (ç»Ÿä¸€è°ƒåº¦)
|   |-- stats_service.py       # ç»Ÿè®¡æœåŠ¡
|   |-- time_service.py        # æ—¶é—´æœåŠ¡ (æ—¶åŒºå¤„ç†)
|   +-- config_manager.py      # é…ç½®ç®¡ç† (åŠ å¯†å­˜å‚¨)
|
|-- templates/                 # UI æˆªå›¾æ¨¡æ¿
|   |-- v3.9.10/               # æŒ‰å¾®ä¿¡ç‰ˆæœ¬åˆ†ç›®å½•
|   |   |-- discover_tab.png
|   |   +-- ...
|   +-- v3.9.11/
|       +-- ...
|
|-- logs/                      # æ—¥å¿— (æŒ‰å¤©è½®è½¬)
|   +-- 2024-11-25.log
|
|-- cache/                     # æœ¬åœ°ç¼“å­˜ (ä»å…±äº«å¤åˆ¶)
|   +-- ...
|
|-- receipts/                  # å›æ‰§æ–‡ä»¶ (åŒæ­¥å›å…±äº«æ–‡ä»¶å¤¹)
|   +-- receipt_2024-11-25_220015.xlsx  # æ ¼å¼: receipt_{æ—¥æœŸ}_{æ—¶åˆ†ç§’}.xlsx
|
+-- db/
    +-- tasks.db               # SQLite æ•°æ®åº“
```

---

## äº”ã€è¿è¡Œæ¨¡å¼ä¸å¹¶å‘äº’æ–¥

### 5.1 æ‰§è¡Œæ¨¡å‹

**æ ¸å¿ƒåŸåˆ™: ä¸¥æ ¼ä¸²è¡Œæ‰§è¡Œ**

```
+-------------------------------------------------+
|              ä»»åŠ¡é˜Ÿåˆ— (ä¼˜å…ˆçº§æ’åº)                |
+-------------------------------------------------+
        |
        v
+-------------------+
| å…¨å±€æ‰§è¡Œé” (Mutex) |  <-- åŒä¸€æ—¶åˆ»ä»…ä¸€ä¸ªä»»åŠ¡æ‰§è¡Œ
+-------------------+
        |
        +--------+--------+--------+
        |        |        |        |
        v        v        v        v
     å‰ªè´´æ¿    å‰å°çª—å£   é¼ æ ‡é”®ç›˜   æˆªå›¾æ£€æµ‹
     (ç‹¬å )    (ç‹¬å )     (ç‹¬å )    (å…±äº«)
```

### 5.2 èµ„æºäº’æ–¥è§„åˆ™

| èµ„æº | äº’æ–¥çº§åˆ« | è¯´æ˜ |
|------|----------|------|
| **å‰ªè´´æ¿** | å…¨å±€ç‹¬å  | ä»»åŠ¡æ‰§è¡ŒæœŸé—´ç‹¬å , å¤‡ä»½/æ¢å¤/éªŒè¯ |
| **å¾®ä¿¡å‰å°çª—å£** | å…¨å±€ç‹¬å  | ä»»åŠ¡æ‰§è¡ŒæœŸé—´ç¦æ­¢å…¶ä»–æ“ä½œ |
| **é¼ æ ‡é”®ç›˜** | å…¨å±€ç‹¬å  | å¯é€‰å¯ç”¨ BlockInput |
| **SQLite æ•°æ®åº“** | å†™é” | WAL æ¨¡å¼æ”¯æŒå¹¶å‘è¯» |
| **æ—¥å¿—æ–‡ä»¶** | æ— é” | è¿½åŠ å†™å…¥, çº¿ç¨‹å®‰å…¨ |

### 5.3 å¹¶å‘ç¦æ­¢å£°æ˜

```python
# scheduler/queue_manager.py

import threading

class TaskQueueManager:
    """
    ä»»åŠ¡é˜Ÿåˆ—ç®¡ç†å™¨

    é‡è¦: å½“å‰ç‰ˆæœ¬ **ä¸æ”¯æŒ** å¹¶è¡Œä»»åŠ¡æ‰§è¡Œ
    åŸå› :
    1. å‰ªè´´æ¿æ˜¯å…¨å±€èµ„æº, æ— æ³•éš”ç¦»
    2. å¾®ä¿¡åªæœ‰ä¸€ä¸ªå‰å°çª—å£
    3. æ¨¡æ‹Ÿç‚¹å‡»å¿…é¡»ç‹¬å é¼ æ ‡/é”®ç›˜

    å¦‚éœ€å¹¶å‘, éœ€è¦:
    - å¤šå¼€å¾®ä¿¡ (å¤šè´¦å·)
    - è™šæ‹Ÿæœºéš”ç¦»
    - è¿œç¨‹æ¡Œé¢å¤šä¼šè¯
    """

    _execution_lock = threading.Lock()  # å…¨å±€æ‰§è¡Œé”

    def execute_next(self):
        """æ‰§è¡Œä¸‹ä¸€ä¸ªä»»åŠ¡ (äº’æ–¥)"""
        if not self._execution_lock.acquire(blocking=False):
            logger.warning("å·²æœ‰ä»»åŠ¡æ­£åœ¨æ‰§è¡Œ, è·³è¿‡æœ¬æ¬¡è°ƒåº¦")
            return

        try:
            task = self._get_next_task()
            if task:
                self._execute_task(task)
        finally:
            self._execution_lock.release()

    def is_executing(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦æœ‰ä»»åŠ¡æ­£åœ¨æ‰§è¡Œ"""
        return self._execution_lock.locked()
```

### 5.4 UI å±‚é¢çš„äº’æ–¥ä¿æŠ¤

```python
def before_task_execution(self):
    """ä»»åŠ¡æ‰§è¡Œå‰çš„ UI ä¿æŠ¤"""

    # 1. ç¦ç”¨å¯èƒ½å¹²æ‰°çš„æŒ‰é’®
    self.btn_execute_now.setEnabled(False)
    self.btn_import_excel.setEnabled(False)
    self.task_list.setDragEnabled(False)

    # 2. æ˜¾ç¤ºæ‰§è¡Œä¸­çŠ¶æ€
    self.status_bar.set_state("running")  # å¿…é¡»ä½¿ç”¨è§„èŒƒçŠ¶æ€å€¼
    self.status_bar.set_message("ä»»åŠ¡æ‰§è¡Œä¸­, è¯·å‹¿æ“ä½œ...")

    # 3. å¯é€‰: é”å®šé¼ æ ‡é”®ç›˜ (éœ€ç®¡ç†å‘˜æƒé™)
    if config.get('block_input_during_execution', False):
        block_input(True)

def after_task_execution(self):
    """ä»»åŠ¡æ‰§è¡Œåæ¢å¤ UI"""

    # æ¢å¤æŒ‰é’®
    self.btn_execute_now.setEnabled(True)
    self.btn_import_excel.setEnabled(True)
    self.task_list.setDragEnabled(True)

    # è§£é”è¾“å…¥
    if config.get('block_input_during_execution', False):
        block_input(False)

    # æ¢å¤çŠ¶æ€æ 
    self.status_bar.set_state("normal")
```

### 5.5 æœªæ¥å¹¶å‘æ‰©å±•è¯´æ˜

å¦‚éœ€æ”¯æŒå¤šä»»åŠ¡å¹¶è¡Œ, å¯è€ƒè™‘ä»¥ä¸‹æ–¹æ¡ˆ:

| æ–¹æ¡ˆ | å¤æ‚åº¦ | è¯´æ˜ |
|------|--------|------|
| **å¤šå¾®ä¿¡å®ä¾‹** | ä¸­ | å¤šå¼€ä¸åŒè´¦å·, æ¯ä¸ªè´¦å·ç‹¬ç«‹é˜Ÿåˆ— |
| **è™šæ‹Ÿæœºéš”ç¦»** | é«˜ | æ¯ä¸ª VM è¿è¡Œç‹¬ç«‹å·¥å…·å®ä¾‹ |
| **RDP å¤šä¼šè¯** | é«˜ | Windows Server å¤šç”¨æˆ·ä¼šè¯ |

å½“å‰ç‰ˆæœ¬ **æ˜ç¡®ä¸æ”¯æŒ** å¹¶å‘æ‰§è¡Œ, ç›¸å…³ä»£ç å·²åŠ é”ä¿æŠ¤ã€‚

---

## å…­ã€æ—¶é—´ä¸è°ƒåº¦è§„èŒƒ

### 6.1 æ—¶åŒºçº¦å®š

| é¡¹ç›® | è§„èŒƒ |
|------|------|
| **ç»Ÿä¸€æ—¶åŒº** | Asia/Shanghai (UTC+8) |
| **ç³»ç»Ÿæ—¶é—´è¦æ±‚** | ç”µè„‘ B éœ€å¼€å¯è‡ªåŠ¨åŒæ­¥æ—¶é—´ (NTP) |
| **æ—¶é’Ÿæ¼‚ç§»å®¹å¿** | +-30 ç§’å†…è§†ä¸ºæ­£å¸¸ |
| **æ—¶é—´æº** | ä½¿ç”¨ `datetime.now(timezone)` è€Œé `datetime.now()` |

### 6.2 å®šæ—¶ä»»åŠ¡æŒä¹…åŒ–

```python
# ä»»åŠ¡è°ƒåº¦çŠ¶æ€å­˜å…¥ SQLite, æ”¯æŒé‡å¯æ¢å¤
class ScheduledTask:
    id: str                    # ä»»åŠ¡å”¯ä¸€ID
    task_id: int               # å…³è”çš„ task è¡¨ ID
    scheduled_time: datetime   # è®¡åˆ’æ‰§è¡Œæ—¶é—´ (å¸¦æ—¶åŒº)
    status: str                # pending/scheduled/running/success/failed (éµå¾ªç»Ÿä¸€çŠ¶æ€æšä¸¾)
    created_at: datetime
```

### 6.3 å¹‚ç­‰æ€§è®¾è®¡

| åœºæ™¯ | å¤„ç†æ–¹å¼ |
|------|----------|
| **ä»»åŠ¡å»é‡** | åŒä¸€ content_code + channel + group_name + æ—¥æœŸ åªå‘ä¸€æ¬¡ |
| **é‡å¯æ¢å¤** | æ£€æŸ¥ status=running çš„ä»»åŠ¡, æ ‡è®°ä¸º failed å¹¶é‡è¯• |
| **æ¼å‘æ£€æµ‹** | å¯åŠ¨æ—¶æ£€æŸ¥ scheduled_time < now ä¸” status=scheduled çš„ä»»åŠ¡ |

```python
def get_task_hash(content_code: str, channel: str, group_name: str, date: str) -> str:
    """
    ç”Ÿæˆä»»åŠ¡å”¯ä¸€æ ‡è¯†, é˜²æ­¢é‡å¤å‘é€

    Args:
        content_code: å†…å®¹ç¼–ç 
        channel: å‘å¸ƒæ¸ é“ (moment/group)
        group_name: ç›®æ ‡ç¾¤å (æœ‹å‹åœˆä¸ºç©ºå­—ç¬¦ä¸²)
        date: æ—¥æœŸå­—ç¬¦ä¸² (YYYY-MM-DD)
    """
    return hashlib.md5(f"{content_code}_{channel}_{group_name}_{date}".encode()).hexdigest()
```

### 6.4 å¹‚ç­‰é”®ä½œç”¨èŒƒå›´ä¸è¡¥å‘ç­–ç•¥

#### 6.4.1 å¹‚ç­‰é”®å®šä¹‰

**å­—æ®µè¯´æ˜:**

å¹‚ç­‰é”®ç”±å››éƒ¨åˆ†ç»„æˆï¼š`content_code + channel + group_name + date`

| å­—æ®µ | æ¥æº | è¯´æ˜ |
|------|------|------|
| `content_code` | `task.content_code` | å†…å®¹ç¼–ç  |
| `channel` | `task.channel` | å‘å¸ƒæ¸ é“ (moment/group) |
| `group_name` | `task.group_name` | ç›®æ ‡ç¾¤å (æœ‹å‹åœˆä¸ºç©ºå­—ç¬¦ä¸² `""`) |
| `date` | `task.scheduled_time.strftime('%Y-%m-%d')` | ä» scheduled_time æå–æ—¥æœŸ |

> **æ³¨æ„**:
> - **ä¸æ‰‹åŠ¨ç»´æŠ¤** `scheduled_date` å­—æ®µï¼Œè€Œæ˜¯é€šè¿‡ `GENERATED ALWAYS AS (DATE(scheduled_time)) STORED` è‡ªåŠ¨ç”Ÿæˆï¼ˆè§ tasks è¡¨å®šä¹‰ï¼‰ï¼Œé¿å…å†—ä½™å’Œä¸ä¸€è‡´ã€‚å¹‚ç­‰é”®ä»£ç ä¸­ä» `scheduled_time` åŠ¨æ€æå–æ—¥æœŸï¼Œä¸æ•°æ®åº“ç”Ÿæˆåˆ—é€»è¾‘ä¸€è‡´ã€‚
> - `group_name` çº³å…¥å¹‚ç­‰é”®ç»´åº¦ï¼Œæ”¯æŒ"åŒä¸€å†…å®¹å‘é€åˆ°å¤šä¸ªç¾¤"çš„åœºæ™¯ï¼Œæ¯ä¸ªç¾¤æ¯å¤©åªèƒ½æ”¶åˆ°ä¸€æ¬¡æŸ content_code çš„æ¨é€ã€‚
> - æœ‹å‹åœˆæ¸ é“ `group_name` ç»Ÿä¸€ä½¿ç”¨ç©ºå­—ç¬¦ä¸² `""`ï¼ˆPython ä»£ç å±‚ï¼‰æˆ– `NULL`ï¼ˆæ•°æ®åº“å±‚ï¼‰ï¼Œç¡®ä¿å¹‚ç­‰é”®å’Œ UNIQUE çº¦æŸè¡Œä¸ºä¸€è‡´ã€‚

```python
# å¹‚ç­‰é”® = content_code + channel + group_name + date (ä» scheduled_time æå–)
# ç¤ºä¾‹: "P001_group_äº§å“äº¤æµç¾¤_2024-11-25" -> hash: "a1b2c3d4..."
# ç¤ºä¾‹: "P001_moment__2024-11-25" -> hash: "e5f6g7h8..." (æœ‹å‹åœˆ group_name ä¸ºç©º)

from datetime import datetime
from typing import Optional

class IdempotencyKey:
    """å¹‚ç­‰é”®ç®¡ç†"""

    @staticmethod
    def generate_from_task(task) -> str:
        """
        ä»ä»»åŠ¡å¯¹è±¡ç”Ÿæˆå¹‚ç­‰é”®

        Args:
            task: ä»»åŠ¡å¯¹è±¡, å¿…é¡»åŒ…å« content_code, channel, group_name, scheduled_time å­—æ®µ

        Returns:
            32ä½ MD5 å“ˆå¸Œå€¼
        """
        # ä» scheduled_time æå–æ—¥æœŸå­—ç¬¦ä¸²
        if isinstance(task.scheduled_time, datetime):
            date_str = task.scheduled_time.strftime('%Y-%m-%d')
        elif isinstance(task.scheduled_time, str):
            # å…¼å®¹å­—ç¬¦ä¸²æ ¼å¼
            date_str = task.scheduled_time[:10]
        else:
            raise ValueError(f"æ— æ•ˆçš„ scheduled_time ç±»å‹: {type(task.scheduled_time)}")

        # group_name: ç¾¤å‘ä¸ºç¾¤å, æœ‹å‹åœˆä¸ºç©ºå­—ç¬¦ä¸²
        group_name = task.group_name if task.group_name else ""
        return IdempotencyKey.generate(task.content_code, task.channel, group_name, date_str)

    @staticmethod
    def generate(content_code: str, channel: str, group_name: str, date: str) -> str:
        """
        ç”Ÿæˆå¹‚ç­‰é”® (åº•å±‚æ–¹æ³•)

        Args:
            content_code: å†…å®¹ç¼–ç 
            channel: å‘å¸ƒæ¸ é“
            group_name: ç›®æ ‡ç¾¤å (æœ‹å‹åœˆä¸ºç©ºå­—ç¬¦ä¸²)
            date: æ—¥æœŸå­—ç¬¦ä¸² (YYYY-MM-DD æ ¼å¼)
        """
        raw = f"{content_code}_{channel}_{group_name}_{date}"
        return hashlib.md5(raw.encode()).hexdigest()

    @staticmethod
    def exists(key: str) -> bool:
        """æ£€æŸ¥å¹‚ç­‰é”®æ˜¯å¦å·²å­˜åœ¨ (å·²æˆåŠŸå‘é€)"""
        return db.query_one(
            "SELECT 1 FROM task_idempotency WHERE key = ? AND status = 'success'",
            [key]
        ) is not None

    @staticmethod
    def record(key: str, task_id: int, status: str):
        """è®°å½•å¹‚ç­‰é”®"""
        db.execute(
            """INSERT OR REPLACE INTO task_idempotency
               (key, task_id, status, created_at)
               VALUES (?, ?, ?, ?)""",
            [key, task_id, status, datetime.now()]
        )

    @staticmethod
    def generate_retry_key(task, retry_count: int) -> str:
        """
        ç”Ÿæˆé‡è¯•å¹‚ç­‰é”® (æ‰‹åŠ¨é‡å‘åœºæ™¯)

        æ ¼å¼: content_code_channel_group_name_date_retryN
        """
        if isinstance(task.scheduled_time, datetime):
            date_str = task.scheduled_time.strftime('%Y-%m-%d')
        else:
            date_str = str(task.scheduled_time)[:10]

        group_name = task.group_name if task.group_name else ""
        raw = f"{task.content_code}_{task.channel}_{group_name}_{date_str}_retry{retry_count}"
        return hashlib.md5(raw.encode()).hexdigest()
```

#### 6.4.2 è¡¥å‘åœºæ™¯ä¸ç­–ç•¥

| åœºæ™¯ | å¹‚ç­‰æ£€æŸ¥ | å¤„ç†ç­–ç•¥ |
|------|----------|----------|
| **æ­£å¸¸å‘é€** | æ£€æŸ¥å¹‚ç­‰é”® | ä¸å­˜åœ¨åˆ™å‘é€, å­˜åœ¨åˆ™è·³è¿‡ |
| **å¤±è´¥é‡è¯•** | åŒä¸€å¹‚ç­‰é”® | å…è®¸é‡è¯• (status != success) |
| **æ¼å‘è¡¥å‘** | åŒä¸€å¹‚ç­‰é”® | æ£€æŸ¥æ˜¯å¦å·²æˆåŠŸ, æœªæˆåŠŸåˆ™è¡¥å‘ |
| **æ‰‹åŠ¨é‡å‘** | ç”Ÿæˆæ–°å¹‚ç­‰é”® | è¿½åŠ åç¼€ `_retry1` |
| **è·¨æ—¥è¡¥å‘** | åŸå¹‚ç­‰é”® | ä¿ç•™åŸæ—¥æœŸ, ä»…è¡¥å‘ |

#### 6.4.3 æ¼å‘æ£€æµ‹ä¸è¡¥å‘æµç¨‹

```python
class MissedTaskHandler:
    """
    æ¼å‘ä»»åŠ¡å¤„ç†å™¨

    åˆå§‹åŒ–æ—¶ä¼ å…¥ config['resend'] é…ç½®æ®µ
    """

    def __init__(self, resend_config: dict):
        """
        Args:
            resend_config: config.yaml ä¸­çš„ resend é…ç½®æ®µ
        """
        self.auto_resend = resend_config.get('auto_resend_missed', False)
        self.max_missed_hours = resend_config.get('max_missed_hours', 24)
        self.auto_resend_max_hours = resend_config.get('auto_resend_max_hours', 6)
        self.require_confirm_groups = resend_config.get('require_confirm_groups', [])

    def detect_missed_tasks(self) -> list:
        """æ£€æµ‹æ¼å‘ä»»åŠ¡"""
        cutoff_time = datetime.now() - timedelta(hours=self.max_missed_hours)

        missed = db.query(
            """SELECT * FROM tasks
               WHERE status = 'scheduled'
               AND scheduled_time < ?
               AND scheduled_time > ?""",
            [datetime.now(), cutoff_time]
        )
        return missed

    def handle_missed_tasks(self) -> dict:
        """å¤„ç†æ¼å‘ä»»åŠ¡"""
        missed = self.detect_missed_tasks()
        result = {'auto_sent': 0, 'marked_missed': 0, 'skipped': 0}

        for task in missed:
            # 1. æ£€æŸ¥å¹‚ç­‰é”® (ä½¿ç”¨ generate_from_task ä» scheduled_time æå–æ—¥æœŸ)
            idem_key = IdempotencyKey.generate_from_task(task)

            if IdempotencyKey.exists(idem_key):
                # å·²å‘é€è¿‡, è·³è¿‡
                task.status = 'skipped'
                task.skip_reason = 'å¹‚ç­‰æ£€æŸ¥: å·²å‘é€'
                result['skipped'] += 1
                continue

            # 2. åˆ¤æ–­æ˜¯å¦è‡ªåŠ¨è¡¥å‘
            if self.auto_resend and self._should_auto_resend(task):
                # è‡ªåŠ¨è¡¥å‘: åŠ å…¥é«˜ä¼˜å…ˆçº§é˜Ÿåˆ—
                queue_manager.add_task(task, priority=8)
                task.status = 'scheduled'
                task.note = 'æ¼å‘è‡ªåŠ¨è¡¥å‘'
                result['auto_sent'] += 1
                logger.info(f"æ¼å‘ä»»åŠ¡è‡ªåŠ¨è¡¥å‘: {task.id}")
            else:
                # æ ‡è®°ä¸ºæ¼å‘, ç­‰å¾…äººå·¥å¤„ç† (ä½¿ç”¨ failed + failure_reason ä¿æŒæšä¸¾ä¸€è‡´)
                task.status = 'failed'
                task.failure_reason = 'missed_schedule'  # æ¼å‘æ ‡è®°
                result['marked_missed'] += 1
                logger.warning(f"æ¼å‘ä»»åŠ¡å¾…å¤„ç†: {task.id}")

            db.update(task)

        return result

    def _should_auto_resend(self, task) -> bool:
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥è‡ªåŠ¨è¡¥å‘"""
        # è§„åˆ™:
        # 1. æ¼å‘æ—¶é—´åœ¨ auto_resend_max_hours å†…
        # 2. ä¸æ˜¯æœ‹å‹åœˆä»»åŠ¡ (æœ‹å‹åœˆæœ‰æ—¶æ•ˆæ€§)
        # 3. ä¸æ˜¯éœ€ç¡®è®¤ç¾¤ (é‡è¦ç¾¤éœ€äººå·¥ç¡®è®¤)

        missed_hours = (datetime.now() - task.scheduled_time).total_seconds() / 3600

        if missed_hours > self.auto_resend_max_hours:
            return False
        if task.channel == 'moment':
            return False  # æœ‹å‹åœˆéœ€äººå·¥ç¡®è®¤
        if task.group_name in self.require_confirm_groups:
            return False  # éœ€ç¡®è®¤ç¾¤éœ€äººå·¥ç¡®è®¤

        return True

    def manual_resend(self, task_id: int, force: bool = False) -> bool:
        """
        æ‰‹åŠ¨é‡å‘ä»»åŠ¡

        Args:
            task_id: ä»»åŠ¡ID
            force: æ˜¯å¦å¼ºåˆ¶é‡å‘ (å¿½ç•¥å¹‚ç­‰æ£€æŸ¥)
        """
        task = db.get_task(task_id)

        if not force:
            # ä½¿ç”¨ generate_from_task ä» scheduled_time æå–æ—¥æœŸ
            idem_key = IdempotencyKey.generate_from_task(task)
            if IdempotencyKey.exists(idem_key):
                logger.warning(f"ä»»åŠ¡ {task_id} å·²æˆåŠŸå‘é€, å¦‚éœ€é‡å‘è¯·ä½¿ç”¨ force=True")
                return False

        # å¼ºåˆ¶é‡å‘: ç”Ÿæˆæ–°å¹‚ç­‰é”® (ä½¿ç”¨ generate_retry_key)
        if force:
            retry_count = task.retry_count + 1
            task.idempotency_key = IdempotencyKey.generate_retry_key(task, retry_count)
            task.retry_count = retry_count

        task.status = 'pending'
        db.update(task)
        queue_manager.add_task(task, priority=9)  # é«˜ä¼˜å…ˆçº§

        logger.info(f"æ‰‹åŠ¨é‡å‘ä»»åŠ¡: {task_id}, force={force}")
        return True
```

#### 6.4.4 è¡¥å‘é…ç½®

```yaml
# config.yaml
resend:
  # è‡ªåŠ¨è¡¥å‘
  auto_resend_missed: false     # æ˜¯å¦è‡ªåŠ¨è¡¥å‘æ¼å‘ä»»åŠ¡ (å»ºè®®å…³é—­)
  max_missed_hours: 24          # æœ€å¤§æ¼å‘æ—¶é—´ (è¶…è¿‡åˆ™ä¸å¤„ç†)
  auto_resend_max_hours: 6      # è‡ªåŠ¨è¡¥å‘çš„æ—¶é—´é™åˆ¶

  # è¡¥å‘ç¡®è®¤
  require_confirm_moment: true  # æœ‹å‹åœˆè¡¥å‘éœ€ç¡®è®¤
  require_confirm_groups: []    # éœ€ç¡®è®¤çš„ç¾¤ååˆ—è¡¨

  # é‡å‘é™åˆ¶
  max_retry_count: 3            # å•ä»»åŠ¡æœ€å¤§é‡è¯•æ¬¡æ•°
  retry_interval_minutes: 10    # é‡è¯•é—´éš” (åˆ†é’Ÿ)
```

#### 6.4.5 äº‹åŠ¡ä¸é”ç­–ç•¥

> **æ ¸å¿ƒè¦æ±‚**: å¹‚ç­‰é”®æ£€æŸ¥ä¸å†™å…¥å¿…é¡»åœ¨åŒä¸€äº‹åŠ¡å†…ï¼Œé˜Ÿåˆ—å–ä»»åŠ¡éœ€åŠ é”é˜²æ­¢å¹¶å‘æŠ¢å ã€‚

```python
# scheduler/idempotency_transaction.py

import sqlite3
import threading
from contextlib import contextmanager
from typing import Optional

class IdempotencyTransactionManager:
    """
    å¹‚ç­‰äº‹åŠ¡ç®¡ç†å™¨

    ä¿è¯:
    1. å¹‚ç­‰é”®æ£€æŸ¥ + å†™å…¥ åœ¨åŒä¸€äº‹åŠ¡å†… (åŸå­æ€§)
    2. é˜Ÿåˆ—å–ä»»åŠ¡æ—¶åŠ è¡Œçº§é” (é˜²å¹¶å‘æŠ¢å )
    3. è·¨æ—¥/æ‰‹åŠ¨/è‡ªåŠ¨è¡¥å‘çš„å†²çªæ£€æµ‹
    """

    _lock = threading.Lock()  # å…¨å±€é” (SQLite ä¸æ”¯æŒçœŸæ­£çš„è¡Œçº§é”)

    def __init__(self, db_path: str = "data/tasks.db"):
        self.db_path = db_path
        self._init_db()

    def _init_db(self):
        """åˆå§‹åŒ–æ•°æ®åº“ï¼Œå¯ç”¨ WAL æ¨¡å¼"""
        conn = sqlite3.connect(self.db_path)
        # å¯ç”¨ WAL æ¨¡å¼: æé«˜å¹¶å‘è¯»å†™æ€§èƒ½ï¼Œé¿å… UI è¯»å–æ—¶é˜»å¡åå°å†™å…¥
        conn.execute("PRAGMA journal_mode=WAL")
        conn.execute("PRAGMA synchronous=NORMAL")  # å¹³è¡¡æ€§èƒ½ä¸å®‰å…¨
        conn.close()

    @contextmanager
    def transaction(self):
        """äº‹åŠ¡ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
        conn = sqlite3.connect(self.db_path, timeout=30)
        conn.isolation_level = None  # è‡ªåŠ¨æäº¤å…³é—­
        try:
            conn.execute("BEGIN IMMEDIATE")  # ç«‹å³è·å–å†™é”
            yield conn
            conn.execute("COMMIT")
        except Exception:
            conn.execute("ROLLBACK")
            raise
        finally:
            conn.close()

    def check_and_record_idempotency(
        self,
        key: str,
        task_id: int
    ) -> tuple[bool, str]:
        """
        åŸå­æ£€æŸ¥å¹¶è®°å½•å¹‚ç­‰é”® (åŒä¸€äº‹åŠ¡å†…)

        Returns:
            (can_proceed, reason): æ˜¯å¦å¯ä»¥æ‰§è¡Œï¼ŒåŠåŸå› 
        """
        with self._lock:  # SQLite éœ€è¦å…¨å±€é”ä¿æŠ¤
            with self.transaction() as conn:
                # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨æˆåŠŸè®°å½•
                cursor = conn.execute(
                    """SELECT status, task_id FROM task_idempotency
                       WHERE key = ?""",
                    [key]
                )
                row = cursor.fetchone()

                if row:
                    existing_status, existing_task_id = row
                    if existing_status == 'success':
                        return False, f"å¹‚ç­‰æ£€æŸ¥å¤±è´¥: å·²æˆåŠŸå‘é€ (task_id={existing_task_id})"
                    elif existing_status == 'processing':
                        return False, f"å¹‚ç­‰æ£€æŸ¥å¤±è´¥: æ­£åœ¨å¤„ç†ä¸­ (task_id={existing_task_id})"
                    # status == 'failed' å…è®¸é‡è¯•

                # å†™å…¥/æ›´æ–°å¹‚ç­‰é”® (æ ‡è®°ä¸º processing)
                conn.execute(
                    """INSERT OR REPLACE INTO task_idempotency
                       (key, task_id, status, created_at, updated_at)
                       VALUES (?, ?, 'processing', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)""",
                    [key, task_id]
                )

                return True, ""

    def mark_success(self, key: str, task_id: int):
        """æ ‡è®°å¹‚ç­‰é”®ä¸ºæˆåŠŸ"""
        with self.transaction() as conn:
            conn.execute(
                """UPDATE task_idempotency
                   SET status = 'success', updated_at = CURRENT_TIMESTAMP
                   WHERE key = ? AND task_id = ?""",
                [key, task_id]
            )

    def mark_failed(self, key: str, task_id: int, error: str):
        """æ ‡è®°å¹‚ç­‰é”®ä¸ºå¤±è´¥"""
        with self.transaction() as conn:
            conn.execute(
                """UPDATE task_idempotency
                   SET status = 'failed', error = ?, updated_at = CURRENT_TIMESTAMP
                   WHERE key = ? AND task_id = ?""",
                [error, key, task_id]
            )


class TaskQueueWithLock:
    """
    å¸¦é”çš„ä»»åŠ¡é˜Ÿåˆ—

    ä¿è¯:
    1. å–ä»»åŠ¡æ—¶åŠ é”ï¼Œé˜²æ­¢å¹¶å‘æŠ¢å 
    2. ä¸å¹‚ç­‰æ£€æŸ¥åœ¨åŒä¸€äº‹åŠ¡é“¾ä¸­
    """

    def __init__(self, idem_manager: IdempotencyTransactionManager):
        self.idem_manager = idem_manager
        self._queue_lock = threading.Lock()

    def fetch_and_lock_next_task(self) -> Optional[dict]:
        """
        è·å–å¹¶é”å®šä¸‹ä¸€ä¸ªå¾…æ‰§è¡Œä»»åŠ¡

        æµç¨‹:
        1. åŠ é˜Ÿåˆ—é”
        2. æŸ¥è¯¢ä¸‹ä¸€ä¸ª pending ä»»åŠ¡
        3. åŸå­æ£€æŸ¥å¹‚ç­‰é”®
        4. æ ‡è®°ä»»åŠ¡ä¸º running (æ³¨æ„: ç»Ÿä¸€ä½¿ç”¨ TaskStatus.RUNNINGï¼Œç¦ç”¨ executing)
        5. é‡Šæ”¾é˜Ÿåˆ—é”
        """
        with self._queue_lock:
            with self.idem_manager.transaction() as conn:
                # 1. æŸ¥è¯¢ä¸‹ä¸€ä¸ªä»»åŠ¡ (æŒ‰ä¼˜å…ˆçº§+æ—¶é—´æ’åº)
                cursor = conn.execute(
                    """SELECT * FROM tasks
                       WHERE status = 'pending'
                       AND scheduled_time <= CURRENT_TIMESTAMP
                       ORDER BY priority DESC, scheduled_time ASC
                       LIMIT 1"""
                )
                row = cursor.fetchone()

                if not row:
                    return None

                task = self._row_to_task(row)

                # 2. æ£€æŸ¥å¹‚ç­‰é”® (åŒä¸€äº‹åŠ¡)
                idem_key = IdempotencyKey.generate_from_task(task)
                cursor = conn.execute(
                    "SELECT status FROM task_idempotency WHERE key = ?",
                    [idem_key]
                )
                idem_row = cursor.fetchone()

                if idem_row and idem_row[0] == 'success':
                    # å·²æˆåŠŸï¼Œè·³è¿‡æ­¤ä»»åŠ¡
                    conn.execute(
                        "UPDATE tasks SET status = 'skipped', skip_reason = ? WHERE id = ?",
                        ['å¹‚ç­‰æ£€æŸ¥: å·²å‘é€', task['id']]
                    )
                    return self.fetch_and_lock_next_task()  # é€’å½’å–ä¸‹ä¸€ä¸ª

                if idem_row and idem_row[0] == 'processing':
                    # æ­£åœ¨å¤„ç†ä¸­ï¼Œè·³è¿‡
                    return self.fetch_and_lock_next_task()

                # 3. å†™å…¥å¹‚ç­‰é”® (æ ‡è®° processing)
                conn.execute(
                    """INSERT OR REPLACE INTO task_idempotency
                       (key, task_id, status, created_at, updated_at)
                       VALUES (?, ?, 'processing', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)""",
                    [idem_key, task['id']]
                )

                # 4. æ ‡è®°ä»»åŠ¡ä¸º running (å¿…é¡»ä½¿ç”¨è§„èŒƒçŠ¶æ€å€¼)
                conn.execute(
                    "UPDATE tasks SET status = 'running' WHERE id = ?",
                    [task['id']]
                )

                task['idempotency_key'] = idem_key
                return task

    def _row_to_task(self, row) -> dict:
        """å°†æ•°æ®åº“è¡Œè½¬æ¢ä¸ºä»»åŠ¡å­—å…¸"""
        # æ ¹æ®å®é™…è¡¨ç»“æ„å®ç°
        pass
```

#### 6.4.6 è·¨æ—¥/æ‰‹åŠ¨/è‡ªåŠ¨è¡¥å‘å†²çªå¤„ç†

```python
# scheduler/resend_conflict_resolver.py

from enum import Enum
from datetime import datetime
from typing import Optional

class ResendSource(Enum):
    """è¡¥å‘æ¥æº"""
    AUTO = "auto"          # è‡ªåŠ¨è¡¥å‘ (æ¼å‘æ£€æµ‹)
    MANUAL = "manual"      # æ‰‹åŠ¨è¡¥å‘ (ç”¨æˆ·æ“ä½œ)
    CROSS_DAY = "cross_day"  # è·¨æ—¥è¡¥å‘ (å®šæ—¶ä»»åŠ¡)

class ResendConflictResolver:
    """
    è¡¥å‘å†²çªè§£å†³å™¨

    å¤„ç†åŒä¸€ä»»åŠ¡è¢«å¤šä¸ªè¡¥å‘æºåŒæ—¶è§¦å‘çš„åœºæ™¯
    """

    def __init__(self, idem_manager: IdempotencyTransactionManager):
        self.idem_manager = idem_manager

        # è¡¥å‘ä¼˜å…ˆçº§ (æ•°å­—è¶Šå¤§ä¼˜å…ˆçº§è¶Šé«˜)
        self.priority_map = {
            ResendSource.MANUAL: 10,      # æ‰‹åŠ¨æœ€é«˜
            ResendSource.AUTO: 5,         # è‡ªåŠ¨æ¬¡ä¹‹
            ResendSource.CROSS_DAY: 3,    # è·¨æ—¥æœ€ä½
        }

    def request_resend(
        self,
        task_id: int,
        source: ResendSource,
        force: bool = False
    ) -> tuple[bool, str]:
        """
        è¯·æ±‚è¡¥å‘ä»»åŠ¡

        Returns:
            (allowed, reason): æ˜¯å¦å…è®¸è¡¥å‘ï¼ŒåŠåŸå› 
        """
        with self.idem_manager._lock:
            with self.idem_manager.transaction() as conn:
                # 1. æ£€æŸ¥æ˜¯å¦æœ‰æ­£åœ¨è¿›è¡Œçš„è¡¥å‘è¯·æ±‚
                cursor = conn.execute(
                    """SELECT source, status FROM resend_requests
                       WHERE task_id = ? AND status = 'pending'
                       ORDER BY priority DESC LIMIT 1""",
                    [task_id]
                )
                existing = cursor.fetchone()

                if existing:
                    existing_source, _ = existing
                    existing_priority = self.priority_map.get(
                        ResendSource(existing_source), 0
                    )
                    new_priority = self.priority_map.get(source, 0)

                    if new_priority <= existing_priority and not force:
                        return False, (
                            f"å·²æœ‰æ›´é«˜ä¼˜å…ˆçº§çš„è¡¥å‘è¯·æ±‚: {existing_source} "
                            f"(å½“å‰: {source.value})"
                        )

                    # æ–°è¯·æ±‚ä¼˜å…ˆçº§æ›´é«˜ï¼Œå–æ¶ˆæ—§è¯·æ±‚
                    conn.execute(
                        """UPDATE resend_requests
                           SET status = 'cancelled', cancel_reason = ?
                           WHERE task_id = ? AND status = 'pending'""",
                        [f'è¢« {source.value} å–ä»£', task_id]
                    )

                # 2. æ£€æŸ¥ä»»åŠ¡åŸå§‹å¹‚ç­‰é”®çŠ¶æ€
                task = self._get_task(conn, task_id)
                if not task:
                    return False, "ä»»åŠ¡ä¸å­˜åœ¨"

                idem_key = IdempotencyKey.generate_from_task(task)
                cursor = conn.execute(
                    "SELECT status FROM task_idempotency WHERE key = ?",
                    [idem_key]
                )
                idem_row = cursor.fetchone()

                if idem_row and idem_row[0] == 'success' and not force:
                    return False, "ä»»åŠ¡å·²æˆåŠŸå‘é€ï¼Œå¦‚éœ€é‡å‘è¯·ä½¿ç”¨ force=True"

                if idem_row and idem_row[0] == 'processing':
                    return False, "ä»»åŠ¡æ­£åœ¨æ‰§è¡Œä¸­ï¼Œè¯·ç¨åå†è¯•"

                # 3. åˆ›å»ºè¡¥å‘è¯·æ±‚
                conn.execute(
                    """INSERT INTO resend_requests
                       (task_id, source, priority, status, created_at)
                       VALUES (?, ?, ?, 'pending', CURRENT_TIMESTAMP)""",
                    [task_id, source.value, self.priority_map.get(source, 0)]
                )

                # 4. å¦‚æœæ˜¯æ‰‹åŠ¨å¼ºåˆ¶é‡å‘ï¼Œç”Ÿæˆæ–°å¹‚ç­‰é”®
                if force and source == ResendSource.MANUAL:
                    retry_count = task.get('retry_count', 0) + 1
                    new_idem_key = IdempotencyKey.generate_retry_key(task, retry_count)
                    conn.execute(
                        "UPDATE tasks SET retry_count = ?, idempotency_key = ? WHERE id = ?",
                        [retry_count, new_idem_key, task_id]
                    )

                return True, f"è¡¥å‘è¯·æ±‚å·²åˆ›å»º (æ¥æº: {source.value})"

    def _get_task(self, conn, task_id: int) -> Optional[dict]:
        """è·å–ä»»åŠ¡ä¿¡æ¯"""
        cursor = conn.execute("SELECT * FROM tasks WHERE id = ?", [task_id])
        row = cursor.fetchone()
        return self._row_to_dict(row) if row else None
```

**è¡¥å‘è¯·æ±‚è¡¨ç»“æ„:**

```sql
CREATE TABLE IF NOT EXISTS resend_requests (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id INTEGER NOT NULL,
    source TEXT NOT NULL,           -- auto/manual/cross_day
    priority INTEGER DEFAULT 0,
    status TEXT DEFAULT 'pending',  -- pending/processing/completed/cancelled
    cancel_reason TEXT,
    created_at DATETIME,
    completed_at DATETIME,
    FOREIGN KEY (task_id) REFERENCES tasks(id)
);

CREATE INDEX IF NOT EXISTS idx_resend_task_status ON resend_requests(task_id, status);
```

**å¹‚ç­‰é”®è¡¨ç»“æ„ (æ›´æ–°):**

```sql
CREATE TABLE IF NOT EXISTS task_idempotency (
    key TEXT PRIMARY KEY,
    task_id INTEGER NOT NULL,
    status TEXT NOT NULL,           -- processing/success/failed
    error TEXT,                     -- å¤±è´¥åŸå› 
    created_at DATETIME,
    updated_at DATETIME
);

CREATE INDEX IF NOT EXISTS idx_idem_status ON task_idempotency(status);
```

---

## ä¸ƒã€å‰ªè´´æ¿å®‰å…¨ç®¡ç†

### 7.1 é£é™©è¯´æ˜

æ‰§è¡Œå™¨å¤§é‡ä¾èµ–å‰ªè´´æ¿ä¼ è¾“æ–‡æ¡ˆå’Œå›¾ç‰‡, å­˜åœ¨ä»¥ä¸‹é£é™©:
- ç”¨æˆ·æ‰‹åŠ¨å¤åˆ¶æ“ä½œä¼šè¦†ç›–å‰ªè´´æ¿å†…å®¹
- å…¶ä»–åå°ç¨‹åºå¯èƒ½æŠ¢å å‰ªè´´æ¿
- å‘é€æœŸé—´å‰ªè´´æ¿è¢«ä¿®æ”¹å¯¼è‡´å†…å®¹é”™ä¹±

### 7.2 è§£å†³æ–¹æ¡ˆ

```python
# core/clipboard_manager.py

import win32clipboard
import threading

class ClipboardManager:
    """å‰ªè´´æ¿å®‰å…¨ç®¡ç†å™¨"""

    _lock = threading.Lock()
    _backup = None

    @classmethod
    def backup(cls):
        """å¤‡ä»½å½“å‰å‰ªè´´æ¿å†…å®¹"""
        with cls._lock:
            try:
                win32clipboard.OpenClipboard()
                if win32clipboard.IsClipboardFormatAvailable(win32clipboard.CF_UNICODETEXT):
                    cls._backup = ('text', win32clipboard.GetClipboardData(win32clipboard.CF_UNICODETEXT))
                elif win32clipboard.IsClipboardFormatAvailable(win32clipboard.CF_DIB):
                    cls._backup = ('image', win32clipboard.GetClipboardData(win32clipboard.CF_DIB))
                else:
                    cls._backup = None
            finally:
                win32clipboard.CloseClipboard()

    @classmethod
    def restore(cls):
        """æ¢å¤å‰ªè´´æ¿å†…å®¹"""
        with cls._lock:
            if cls._backup:
                try:
                    win32clipboard.OpenClipboard()
                    win32clipboard.EmptyClipboard()
                    if cls._backup[0] == 'text':
                        win32clipboard.SetClipboardData(win32clipboard.CF_UNICODETEXT, cls._backup[1])
                    elif cls._backup[0] == 'image':
                        win32clipboard.SetClipboardData(win32clipboard.CF_DIB, cls._backup[1])
                finally:
                    win32clipboard.CloseClipboard()

    @classmethod
    def verify_content(cls, expected_text: str) -> bool:
        """éªŒè¯å‰ªè´´æ¿å†…å®¹æ˜¯å¦è¢«ç¯¡æ”¹"""
        try:
            win32clipboard.OpenClipboard()
            if win32clipboard.IsClipboardFormatAvailable(win32clipboard.CF_UNICODETEXT):
                actual = win32clipboard.GetClipboardData(win32clipboard.CF_UNICODETEXT)
                return actual == expected_text
            return False
        finally:
            win32clipboard.CloseClipboard()
```

### 7.3 ä½¿ç”¨æµç¨‹

```python
def safe_paste_text(text: str):
    """å®‰å…¨ç²˜è´´æ–‡æœ¬"""
    # 1. å¤‡ä»½åŸå‰ªè´´æ¿
    ClipboardManager.backup()

    try:
        # 2. å†™å…¥æ–°å†…å®¹
        pyperclip.copy(text)

        # 3. éªŒè¯å†…å®¹
        if not ClipboardManager.verify_content(text):
            raise ClipboardTamperedException("å‰ªè´´æ¿å†…å®¹è¢«å¤–éƒ¨ä¿®æ”¹")

        # 4. æ‰§è¡Œç²˜è´´
        pyautogui.hotkey('ctrl', 'v')
        time.sleep(0.3)

    finally:
        # 5. æ¢å¤åŸå‰ªè´´æ¿
        ClipboardManager.restore()
```

### 7.4 è¿è¡Œç¯å¢ƒè¦æ±‚

> **é‡è¦æç¤º**: ç”µè„‘ B åœ¨è¿è¡Œå‘å¸ƒä»»åŠ¡æœŸé—´åº”å¤„äº **æ— äººå€¼å®ˆ** çŠ¶æ€, é¿å…æ‰‹åŠ¨æ“ä½œå¹²æ‰°

å¯é€‰: åœ¨æ‰§è¡Œå…³é”®ç²˜è´´æ“ä½œæ—¶çŸ­æš‚å±è”½è¾“å…¥ (éœ€ç®¡ç†å‘˜æƒé™):
```python
import ctypes
user32 = ctypes.windll.user32

def block_input(block: bool):
    """å±è”½/æ¢å¤ç‰©ç†é”®é¼ è¾“å…¥ (éœ€ç®¡ç†å‘˜æƒé™)"""
    user32.BlockInput(block)
```

---

## å…«ã€ç†”æ–­ä¸æ¢å¤æœºåˆ¶

### 8.1 ç†”æ–­æ¡ä»¶

| æ¡ä»¶ | è§¦å‘åŠ¨ä½œ |
|------|----------|
| è¿ç»­å¤±è´¥ >= 3 æ¬¡ | æš‚åœé˜Ÿåˆ—, é‚®ä»¶å‘Šè­¦ |
| æ£€æµ‹åˆ°é£æ§å…³é”®è¯ | ç«‹å³æš‚åœ, ç´§æ€¥å‘Šè­¦ |
| å¾®ä¿¡è¿›ç¨‹å´©æºƒ | å°è¯•é‡å¯, å¤±è´¥åˆ™æš‚åœ |
| ç½‘ç»œè¿ç»­è¶…æ—¶ >= 5 æ¬¡ | æš‚åœå¹¶ç­‰å¾…ç½‘ç»œæ¢å¤ |

### 8.2 ç†”æ–­å™¨å®ç°

```python
# scheduler/circuit_breaker.py

from datetime import datetime, timedelta
from enum import Enum

class CircuitState(Enum):
    CLOSED = "closed"       # æ­£å¸¸è¿è¡Œ
    OPEN = "open"           # ç†”æ–­ä¸­
    HALF_OPEN = "half_open" # è¯•æ¢æ¢å¤

class CircuitBreaker:
    """ç†”æ–­å™¨"""

    def __init__(self,
                 failure_threshold: int = 3,
                 recovery_timeout: int = 300,  # 5åˆ†é’Ÿå†·å´
                 half_open_max_calls: int = 1):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.half_open_max_calls = half_open_max_calls

        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.last_failure_time = None
        self.half_open_calls = 0

    def record_success(self):
        """è®°å½•æˆåŠŸ"""
        self.failure_count = 0
        if self.state == CircuitState.HALF_OPEN:
            self.state = CircuitState.CLOSED
            logger.info("ç†”æ–­å™¨æ¢å¤: HALF_OPEN -> CLOSED")

    def record_failure(self, error: str):
        """è®°å½•å¤±è´¥"""
        self.failure_count += 1
        self.last_failure_time = datetime.now()

        if self.failure_count >= self.failure_threshold:
            self.state = CircuitState.OPEN
            logger.warning(f"ç†”æ–­å™¨è§¦å‘: è¿ç»­å¤±è´¥ {self.failure_count} æ¬¡")
            send_circuit_breaker_alert(error)

    def can_execute(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥æ‰§è¡Œ"""
        if self.state == CircuitState.CLOSED:
            return True

        if self.state == CircuitState.OPEN:
            # æ£€æŸ¥å†·å´æ—¶é—´
            if datetime.now() - self.last_failure_time > timedelta(seconds=self.recovery_timeout):
                self.state = CircuitState.HALF_OPEN
                self.half_open_calls = 0
                logger.info("ç†”æ–­å™¨è¿›å…¥è¯•æ¢çŠ¶æ€: OPEN -> HALF_OPEN")
                return True
            return False

        if self.state == CircuitState.HALF_OPEN:
            if self.half_open_calls < self.half_open_max_calls:
                self.half_open_calls += 1
                return True
            return False

        return False

    def force_reset(self):
        """äººå·¥å¼ºåˆ¶æ¢å¤"""
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        logger.info("ç†”æ–­å™¨å·²äººå·¥é‡ç½®")
```

### 8.3 æ¢å¤ç­–ç•¥

| æ¢å¤æ–¹å¼ | è¯´æ˜ |
|----------|------|
| **è‡ªåŠ¨æ¢å¤** | å†·å´ 5 åˆ†é’Ÿåè‡ªåŠ¨è¯•æ¢, æˆåŠŸåˆ™æ¢å¤ |
| **äººå·¥æ¢å¤** | GUI æä¾› "å¼ºåˆ¶æ¢å¤" æŒ‰é’®, éœ€ç¡®è®¤ |
| **æ¡ä»¶æ¢å¤** | æ£€æµ‹åˆ°å¾®ä¿¡æ­£å¸¸ + ç½‘ç»œæ­£å¸¸åè‡ªåŠ¨æ¢å¤ |

### 8.4 ç†”æ–­å™¨ UI è¡Œä¸ºè§„èŒƒ

#### 8.4.1 çŠ¶æ€æ æ˜¾ç¤º

```
+------------------------------------------------------------------+
|  [çŠ¶æ€æŒ‡ç¤º]                                                        |
|                                                                    |
|  æ­£å¸¸è¿è¡Œ:    [ç»¿ç¯] ç³»ç»Ÿæ­£å¸¸è¿è¡Œä¸­ | é˜Ÿåˆ—: 12 | ä»Šæ—¥æˆåŠŸ: 8       |
|  ç†”æ–­é¢„è­¦:    [é»„ç¯] è­¦å‘Š: è¿ç»­å¤±è´¥ 2 æ¬¡ | è·ç¦»ç†”æ–­è¿˜å‰© 1 æ¬¡        |
|  ç†”æ–­ä¸­:      [çº¢ç¯] ç†”æ–­ä¿æŠ¤ä¸­ | å‰©ä½™å†·å´: 4:32 | [å¼ºåˆ¶æ¢å¤]       |
|  åŠå¼€æµ‹è¯•:    [æ©™ç¯] è¯•æ¢æ¢å¤ä¸­... | è¯·å‹¿æ“ä½œ                      |
+------------------------------------------------------------------+
```

#### 8.4.2 ç†”æ–­è§¦å‘æ—¶çš„ UI å“åº”

```python
def on_circuit_breaker_triggered(self, error_msg: str, remaining_cooldown: int):
    """ç†”æ–­è§¦å‘æ—¶çš„ UI å›è°ƒ"""

    # 1. æ›´æ–°çŠ¶æ€æ 
    self.status_bar.set_state("circuit_open")
    self.status_bar.set_message(f"ç†”æ–­ä¿æŠ¤å·²è§¦å‘: {error_msg}")

    # 2. æ˜¾ç¤ºç³»ç»Ÿæ‰˜ç›˜é€šçŸ¥
    self.tray_icon.show_notification(
        title="ç†”æ–­ä¿æŠ¤",
        message=f"è¿ç»­å¤±è´¥, å·²æš‚åœå‘é€ã€‚å†·å´æ—¶é—´: {remaining_cooldown // 60} åˆ†é’Ÿ",
        icon="warning"
    )

    # 3. ç¦ç”¨"ç«‹å³æ‰§è¡Œ"æŒ‰é’®
    self.btn_execute_now.setEnabled(False)

    # 4. æ˜¾ç¤º"å¼ºåˆ¶æ¢å¤"æŒ‰é’®
    self.btn_force_recover.setVisible(True)

    # 5. å°†æ‰€æœ‰ scheduled ä»»åŠ¡æ ‡è®°ä¸º paused
    self.pause_all_scheduled_tasks()

    # 6. å¯åŠ¨å†·å´å€’è®¡æ—¶æ˜¾ç¤º
    self.start_cooldown_timer(remaining_cooldown)

def on_circuit_breaker_recovered(self, auto: bool):
    """ç†”æ–­æ¢å¤æ—¶çš„ UI å›è°ƒ"""

    # 1. æ›´æ–°çŠ¶æ€æ 
    self.status_bar.set_state("normal")
    recovery_type = "è‡ªåŠ¨" if auto else "æ‰‹åŠ¨"
    self.status_bar.set_message(f"ç³»ç»Ÿå·²{recovery_type}æ¢å¤æ­£å¸¸")

    # 2. æ˜¾ç¤ºç³»ç»Ÿæ‰˜ç›˜é€šçŸ¥
    self.tray_icon.show_notification(
        title="æ¢å¤æ­£å¸¸",
        message=f"ç†”æ–­ä¿æŠ¤å·²{recovery_type}è§£é™¤, ä»»åŠ¡é˜Ÿåˆ—æ¢å¤æ‰§è¡Œ",
        icon="info"
    )

    # 3. æ¢å¤æŒ‰é’®çŠ¶æ€
    self.btn_execute_now.setEnabled(True)
    self.btn_force_recover.setVisible(False)

    # 4. å°† paused ä»»åŠ¡æ¢å¤ä¸º scheduled
    self.resume_paused_tasks()
```

#### 8.4.3 å¼ºåˆ¶æ¢å¤ç¡®è®¤å¯¹è¯æ¡†

```python
def show_force_recover_dialog(self):
    """æ˜¾ç¤ºå¼ºåˆ¶æ¢å¤ç¡®è®¤å¯¹è¯æ¡†"""

    dialog = QMessageBox(self)
    dialog.setIcon(QMessageBox.Warning)
    dialog.setWindowTitle("ç¡®è®¤å¼ºåˆ¶æ¢å¤")
    dialog.setText("ç†”æ–­ä¿æŠ¤æ˜¯ä¸ºäº†é˜²æ­¢è´¦å·é£é™©è§¦å‘çš„è‡ªåŠ¨ä¿æŠ¤æœºåˆ¶ã€‚")
    dialog.setInformativeText(
        "å¼ºåˆ¶æ¢å¤å¯èƒ½å¯¼è‡´:\n"
        "- å¦‚æœé—®é¢˜æœªè§£å†³, å°†å†æ¬¡è§¦å‘ç†”æ–­\n"
        "- é¢‘ç¹æ“ä½œå¯èƒ½å¢åŠ è´¦å·é£é™©\n\n"
        "å»ºè®®: å…ˆæ£€æŸ¥å¾®ä¿¡çŠ¶æ€å’Œç½‘ç»œè¿æ¥, ç¡®è®¤æ— é—®é¢˜åå†æ¢å¤ã€‚\n\n"
        "ç¡®å®šè¦å¼ºåˆ¶æ¢å¤å—?"
    )
    dialog.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
    dialog.setDefaultButton(QMessageBox.No)

    if dialog.exec() == QMessageBox.Yes:
        self.circuit_breaker.force_reset()
        self.on_circuit_breaker_recovered(auto=False)
        logger.info("ç”¨æˆ·æ‰‹åŠ¨å¼ºåˆ¶æ¢å¤ç†”æ–­å™¨")
```

### 8.5 åŠ¨æ€é€Ÿç‡è°ƒèŠ‚

```python
class AdaptiveRateLimiter:
    """è‡ªé€‚åº”é€Ÿç‡é™åˆ¶å™¨"""

    def __init__(self, base_interval: int = 180):
        self.base_interval = base_interval  # åŸºç¡€é—´éš” (ç§’)
        self.current_interval = base_interval
        self.recent_failures = 0

    def get_interval(self) -> int:
        """è·å–å½“å‰é—´éš” (æ ¹æ®å¤±è´¥ç‡åŠ¨æ€è°ƒæ•´)"""
        if self.recent_failures == 0:
            self.current_interval = self.base_interval
        elif self.recent_failures <= 2:
            self.current_interval = self.base_interval * 1.5
        elif self.recent_failures <= 4:
            self.current_interval = self.base_interval * 2
        else:
            self.current_interval = self.base_interval * 3

        # åŠ å…¥éšæœºæŠ–åŠ¨
        jitter = random.randint(-30, 60)
        return int(self.current_interval + jitter)

    def record_result(self, success: bool):
        if success:
            self.recent_failures = max(0, self.recent_failures - 1)
        else:
            self.recent_failures += 1
```

---

## ä¹ã€é£æ§ä¸å°å·å¤„ç½®

> **æ ¸å¿ƒåŸåˆ™**: æ“ä½œå¤±è´¥ç«‹å³åœæœºï¼Œç­‰å¾…äººå·¥æ£€æŸ¥åå†æ¢å¤æ“ä½œã€‚å®å¯æ¼å‘ï¼Œä¸å¯å› è‡ªåŠ¨åŒ–å¯¼è‡´è´¦å·é£é™©ã€‚

### 9.1 é£æ§äº‹ä»¶ç±»å‹å®šä¹‰

```python
# core/risk_control.py

from enum import Enum, auto
from dataclasses import dataclass
from datetime import datetime
from typing import Optional
import logging

logger = logging.getLogger(__name__)

class RiskLevel(Enum):
    """é£é™©ç­‰çº§"""
    LOW = "low"           # ä½é£é™©ï¼šå¯è‡ªåŠ¨æ¢å¤
    MEDIUM = "medium"     # ä¸­é£é™©ï¼šéœ€äººå·¥ç¡®è®¤
    HIGH = "high"         # é«˜é£é™©ï¼šç«‹å³åœæœº
    CRITICAL = "critical" # ä¸¥é‡ï¼šç«‹å³åœæœº + ç´§æ€¥å‘Šè­¦

class RiskEventType(Enum):
    """é£æ§äº‹ä»¶ç±»å‹"""
    # é«˜å±äº‹ä»¶ - ç«‹å³åœæœº
    ACCOUNT_BANNED = auto()           # è´¦å·è¢«å°ç¦
    LOGIN_RESTRICTED = auto()         # ç™»å½•å—é™
    FEATURE_DISABLED = auto()         # åŠŸèƒ½è¢«ç¦ç”¨
    SECURITY_VERIFICATION = auto()    # å®‰å…¨éªŒè¯å¼¹çª—

    # ä¸­å±äº‹ä»¶ - åœæœºç­‰å¾…äººå·¥
    SEND_FREQUENCY_LIMITED = auto()   # å‘é€é¢‘ç‡å—é™
    CONTENT_BLOCKED = auto()          # å†…å®¹è¢«æ‹¦æˆª
    UNUSUAL_ACTIVITY_ALERT = auto()   # å¼‚å¸¸æ´»åŠ¨æé†’

    # ä½å±äº‹ä»¶ - è®°å½•å¹¶ç»§ç»­è§‚å¯Ÿ
    OPERATION_TIMEOUT = auto()        # æ“ä½œè¶…æ—¶
    ELEMENT_NOT_FOUND = auto()        # å…ƒç´ æœªæ‰¾åˆ°
    NETWORK_UNSTABLE = auto()         # ç½‘ç»œä¸ç¨³å®š

# äº‹ä»¶ä¸é£é™©ç­‰çº§æ˜ å°„
RISK_EVENT_LEVELS = {
    RiskEventType.ACCOUNT_BANNED: RiskLevel.CRITICAL,
    RiskEventType.LOGIN_RESTRICTED: RiskLevel.CRITICAL,
    RiskEventType.FEATURE_DISABLED: RiskLevel.HIGH,
    RiskEventType.SECURITY_VERIFICATION: RiskLevel.HIGH,
    RiskEventType.SEND_FREQUENCY_LIMITED: RiskLevel.MEDIUM,
    RiskEventType.CONTENT_BLOCKED: RiskLevel.MEDIUM,
    RiskEventType.UNUSUAL_ACTIVITY_ALERT: RiskLevel.MEDIUM,
    RiskEventType.OPERATION_TIMEOUT: RiskLevel.LOW,
    RiskEventType.ELEMENT_NOT_FOUND: RiskLevel.LOW,
    RiskEventType.NETWORK_UNSTABLE: RiskLevel.LOW,
}

@dataclass
class RiskEvent:
    """é£æ§äº‹ä»¶"""
    event_type: RiskEventType
    level: RiskLevel
    timestamp: datetime
    description: str
    screenshot_path: Optional[str] = None
    additional_info: Optional[dict] = None
```

### 9.2 é£æ§æ£€æµ‹å™¨

```python
# core/risk_detector.py

import re
from typing import Optional, List
from PIL import Image
import pytesseract

class RiskDetector:
    """é£æ§æ£€æµ‹å™¨ - è¯†åˆ«å¾®ä¿¡é£æ§ä¿¡å·"""

    # é£æ§å…³é”®è¯ (çª—å£æ ‡é¢˜/å¼¹çª—æ–‡æœ¬)
    RISK_KEYWORDS = {
        RiskLevel.CRITICAL: [
            "è´¦å·å·²è¢«å°ç¦", "è´¦å·å¼‚å¸¸", "æ°¸ä¹…å°ç¦",
            "ç™»å½•å—é™", "æ— æ³•ç™»å½•", "è´¦å·å·²å†»ç»“",
        ],
        RiskLevel.HIGH: [
            "å®‰å…¨éªŒè¯", "èº«ä»½éªŒè¯", "è¯·è¾“å…¥éªŒè¯ç ",
            "åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨", "æ“ä½œé¢‘ç¹", "è¯·ç¨åå†è¯•",
        ],
        RiskLevel.MEDIUM: [
            "å‘é€è¿‡äºé¢‘ç¹", "æ¶ˆæ¯å‘é€å¤±è´¥", "å†…å®¹æ— æ³•å‘é€",
            "æ£€æµ‹åˆ°å¼‚å¸¸", "å®‰å…¨æé†’",
        ],
    }

    def __init__(self):
        self.detected_events: List[RiskEvent] = []

    def check_window_title(self, title: str) -> Optional[RiskEvent]:
        """æ£€æŸ¥çª—å£æ ‡é¢˜æ˜¯å¦åŒ…å«é£æ§å…³é”®è¯"""
        for level, keywords in self.RISK_KEYWORDS.items():
            for keyword in keywords:
                if keyword in title:
                    return self._create_event(
                        self._keyword_to_event_type(keyword, level),
                        level,
                        f"çª—å£æ ‡é¢˜æ£€æµ‹åˆ°é£æ§ä¿¡å·: {title}"
                    )
        return None

    def check_screenshot(self, screenshot_path: str) -> Optional[RiskEvent]:
        """OCRæ£€æŸ¥æˆªå›¾ä¸­çš„é£æ§æ–‡æœ¬"""
        try:
            image = Image.open(screenshot_path)
            text = pytesseract.image_to_string(image, lang='chi_sim')

            for level, keywords in self.RISK_KEYWORDS.items():
                for keyword in keywords:
                    if keyword in text:
                        return self._create_event(
                            self._keyword_to_event_type(keyword, level),
                            level,
                            f"æˆªå›¾OCRæ£€æµ‹åˆ°é£æ§ä¿¡å·: {keyword}",
                            screenshot_path=screenshot_path
                        )
        except Exception as e:
            logger.warning(f"æˆªå›¾é£æ§æ£€æµ‹å¤±è´¥: {e}")
        return None

    def check_operation_result(self, success: bool, error_msg: str = "") -> Optional[RiskEvent]:
        """æ£€æŸ¥æ“ä½œç»“æœåˆ¤æ–­æ˜¯å¦è§¦å‘é£æ§"""
        if success:
            return None

        # æ ¹æ®é”™è¯¯ä¿¡æ¯åˆ¤æ–­é£é™©ç±»å‹
        if any(kw in error_msg for kw in ["è¶…æ—¶", "timeout"]):
            return self._create_event(
                RiskEventType.OPERATION_TIMEOUT,
                RiskLevel.LOW,
                f"æ“ä½œè¶…æ—¶: {error_msg}"
            )

        if any(kw in error_msg for kw in ["æ‰¾ä¸åˆ°", "not found", "å…ƒç´ "]):
            return self._create_event(
                RiskEventType.ELEMENT_NOT_FOUND,
                RiskLevel.LOW,
                f"å…ƒç´ æœªæ‰¾åˆ°: {error_msg}"
            )

        # æœªçŸ¥é”™è¯¯é»˜è®¤ä¸­é£é™©
        return self._create_event(
            RiskEventType.UNUSUAL_ACTIVITY_ALERT,
            RiskLevel.MEDIUM,
            f"æ“ä½œå¤±è´¥: {error_msg}"
        )

    def _keyword_to_event_type(self, keyword: str, level: RiskLevel) -> RiskEventType:
        """æ ¹æ®å…³é”®è¯æ¨æ–­äº‹ä»¶ç±»å‹"""
        keyword_mapping = {
            "å°ç¦": RiskEventType.ACCOUNT_BANNED,
            "å†»ç»“": RiskEventType.ACCOUNT_BANNED,
            "ç™»å½•å—é™": RiskEventType.LOGIN_RESTRICTED,
            "æ— æ³•ç™»å½•": RiskEventType.LOGIN_RESTRICTED,
            "éªŒè¯": RiskEventType.SECURITY_VERIFICATION,
            "éªŒè¯ç ": RiskEventType.SECURITY_VERIFICATION,
            "åŠŸèƒ½": RiskEventType.FEATURE_DISABLED,
            "é¢‘ç¹": RiskEventType.SEND_FREQUENCY_LIMITED,
            "å‘é€å¤±è´¥": RiskEventType.CONTENT_BLOCKED,
        }
        for kw, event_type in keyword_mapping.items():
            if kw in keyword:
                return event_type
        return RiskEventType.UNUSUAL_ACTIVITY_ALERT

    def _create_event(
        self,
        event_type: RiskEventType,
        level: RiskLevel,
        description: str,
        screenshot_path: str = None
    ) -> RiskEvent:
        event = RiskEvent(
            event_type=event_type,
            level=level,
            timestamp=datetime.now(),
            description=description,
            screenshot_path=screenshot_path
        )
        self.detected_events.append(event)
        return event
```

### 9.3 åœæœºæ§åˆ¶å™¨

```python
# core/shutdown_controller.py

import sys
import signal
from pathlib import Path
from datetime import datetime
from typing import Optional
import json

class ShutdownController:
    """
    åœæœºæ§åˆ¶å™¨

    æ ¸å¿ƒç­–ç•¥: ä»»ä½• MEDIUM åŠä»¥ä¸Šé£é™©äº‹ä»¶ï¼Œç«‹å³åœæ­¢è¿›ç¨‹ï¼Œ
    ç­‰å¾…äººå·¥æ£€æŸ¥ç¡®è®¤åæ‰èƒ½æ¢å¤ã€‚
    """

    SHUTDOWN_FLAG_FILE = Path("data/.shutdown_flag")
    SHUTDOWN_LOG_FILE = Path("data/shutdown_log.json")

    def __init__(self, alert_manager: 'AlertManager'):
        self.alert_manager = alert_manager
        self.is_shutting_down = False

    def handle_risk_event(self, event: RiskEvent) -> bool:
        """
        å¤„ç†é£æ§äº‹ä»¶

        Returns:
            bool: True=å·²åœæœº, False=ç»§ç»­è¿è¡Œ
        """
        # è®°å½•æ‰€æœ‰äº‹ä»¶
        self._log_event(event)

        if event.level == RiskLevel.LOW:
            # ä½é£é™©ï¼šä»…è®°å½•ï¼Œç»§ç»­è§‚å¯Ÿ
            logger.warning(f"ä½é£é™©äº‹ä»¶: {event.description}")
            return False

        if event.level == RiskLevel.MEDIUM:
            # ä¸­é£é™©ï¼šåœæœºç­‰å¾…äººå·¥
            logger.error(f"ä¸­é£é™©äº‹ä»¶è§¦å‘åœæœº: {event.description}")
            self._initiate_shutdown(event, urgent=False)
            return True

        if event.level in (RiskLevel.HIGH, RiskLevel.CRITICAL):
            # é«˜/ä¸¥é‡é£é™©ï¼šç´§æ€¥åœæœº + ç«‹å³å‘Šè­¦
            logger.critical(f"é«˜é£é™©äº‹ä»¶è§¦å‘ç´§æ€¥åœæœº: {event.description}")
            self._initiate_shutdown(event, urgent=True)
            return True

        return False

    def _initiate_shutdown(self, event: RiskEvent, urgent: bool):
        """æ‰§è¡Œåœæœºæµç¨‹"""
        if self.is_shutting_down:
            return

        self.is_shutting_down = True

        # 1. å†™å…¥åœæœºæ ‡è®°æ–‡ä»¶ (é˜»æ­¢é‡å¯)
        self._write_shutdown_flag(event)

        # 2. å‘é€å‘Šè­¦
        if urgent:
            self.alert_manager.send_urgent_alert(event)
        else:
            self.alert_manager.send_normal_alert(event)

        # 3. ä¿å­˜å½“å‰çŠ¶æ€ (ç”¨äºæ¢å¤)
        self._save_state_snapshot()

        # 4. ä¼˜é›…é€€å‡º
        logger.info("æ­£åœ¨æ‰§è¡Œä¼˜é›…åœæœº...")
        sys.exit(1)

    def _write_shutdown_flag(self, event: RiskEvent):
        """å†™å…¥åœæœºæ ‡è®°æ–‡ä»¶"""
        flag_data = {
            "shutdown_time": datetime.now().isoformat(),
            "event_type": event.event_type.name,
            "risk_level": event.level.value,
            "description": event.description,
            "screenshot": event.screenshot_path,
            "requires_human_check": True,
            "recovery_instructions": self._get_recovery_instructions(event)
        }

        self.SHUTDOWN_FLAG_FILE.parent.mkdir(parents=True, exist_ok=True)
        self.SHUTDOWN_FLAG_FILE.write_text(
            json.dumps(flag_data, ensure_ascii=False, indent=2),
            encoding='utf-8'
        )

    def _get_recovery_instructions(self, event: RiskEvent) -> str:
        """æ ¹æ®äº‹ä»¶ç±»å‹è¿”å›æ¢å¤æŒ‡å¼•"""
        instructions = {
            RiskEventType.ACCOUNT_BANNED:
                "1. ç™»å½•å¾®ä¿¡æ£€æŸ¥è´¦å·çŠ¶æ€\n"
                "2. å¦‚å·²å°ç¦ï¼Œè”ç³»å¾®ä¿¡å®¢æœç”³è¯‰\n"
                "3. ç¡®è®¤è´¦å·æ¢å¤åï¼Œåˆ é™¤ .shutdown_flag æ–‡ä»¶\n"
                "4. é‡æ–°å¯åŠ¨ç¨‹åº",

            RiskEventType.LOGIN_RESTRICTED:
                "1. æ‰‹åŠ¨ç™»å½•å¾®ä¿¡å®ŒæˆéªŒè¯\n"
                "2. æ£€æŸ¥æ˜¯å¦éœ€è¦ç»‘å®šæ‰‹æœº/æ›´æ¢å¯†ç \n"
                "3. ç¡®è®¤æ­£å¸¸åï¼Œåˆ é™¤ .shutdown_flag æ–‡ä»¶",

            RiskEventType.SECURITY_VERIFICATION:
                "1. æ‰‹åŠ¨å®Œæˆå¾®ä¿¡å®‰å…¨éªŒè¯\n"
                "2. æ£€æŸ¥è´¦å·å®‰å…¨è®¾ç½®\n"
                "3. ç¡®è®¤æ­£å¸¸åï¼Œåˆ é™¤ .shutdown_flag æ–‡ä»¶",

            RiskEventType.SEND_FREQUENCY_LIMITED:
                "1. ç­‰å¾…è‡³å°‘2å°æ—¶åå†å°è¯•\n"
                "2. è€ƒè™‘é™ä½å‘é€é¢‘ç‡é…ç½®\n"
                "3. åˆ é™¤ .shutdown_flag æ–‡ä»¶åé‡å¯",
        }
        return instructions.get(
            event.event_type,
            "1. æ£€æŸ¥å¾®ä¿¡å®¢æˆ·ç«¯çŠ¶æ€\n2. æŸ¥çœ‹æˆªå›¾å’Œæ—¥å¿—\n3. ç¡®è®¤å®‰å…¨ååˆ é™¤ .shutdown_flag æ–‡ä»¶"
        )

    def _save_state_snapshot(self):
        """ä¿å­˜çŠ¶æ€å¿«ç…§ç”¨äºæ¢å¤"""
        # ç”± TaskQueue å®ç°å…·ä½“çš„çŠ¶æ€ä¿å­˜
        pass

    def _log_event(self, event: RiskEvent):
        """è®°å½•äº‹ä»¶åˆ°æ—¥å¿—æ–‡ä»¶"""
        log_entry = {
            "timestamp": event.timestamp.isoformat(),
            "event_type": event.event_type.name,
            "level": event.level.value,
            "description": event.description,
            "screenshot": event.screenshot_path
        }

        # è¿½åŠ åˆ°æ—¥å¿—æ–‡ä»¶
        logs = []
        if self.SHUTDOWN_LOG_FILE.exists():
            try:
                logs = json.loads(self.SHUTDOWN_LOG_FILE.read_text(encoding='utf-8'))
            except (json.JSONDecodeError, IOError):
                pass

        logs.append(log_entry)

        # åªä¿ç•™æœ€è¿‘100æ¡
        logs = logs[-100:]

        self.SHUTDOWN_LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
        self.SHUTDOWN_LOG_FILE.write_text(
            json.dumps(logs, ensure_ascii=False, indent=2),
            encoding='utf-8'
        )

    @classmethod
    def check_can_start(cls) -> tuple[bool, Optional[dict]]:
        """
        å¯åŠ¨å‰æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿è¡Œ

        Returns:
            (can_start, shutdown_info): æ˜¯å¦å¯å¯åŠ¨ï¼Œä»¥åŠåœæœºä¿¡æ¯
        """
        if not cls.SHUTDOWN_FLAG_FILE.exists():
            return True, None

        try:
            flag_data = json.loads(
                cls.SHUTDOWN_FLAG_FILE.read_text(encoding='utf-8')
            )
            return False, flag_data
        except (json.JSONDecodeError, IOError):
            return True, None
```

### 9.4 å‘Šè­¦ç®¡ç†å™¨

```python
# core/alert_manager.py

import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.image import MIMEImage
from pathlib import Path

class AlertManager:
    """å‘Šè­¦ç®¡ç†å™¨ - é£æ§äº‹ä»¶é€šçŸ¥"""

    def __init__(self, config: dict):
        self.config = config
        self.email_config = config.get('email', {})
        self.sms_config = config.get('sms', {})  # é¢„ç•™çŸ­ä¿¡æ¥å£

    def send_urgent_alert(self, event: RiskEvent):
        """å‘é€ç´§æ€¥å‘Šè­¦ (é‚®ä»¶ + çŸ­ä¿¡)"""
        subject = f"[ç´§æ€¥] å¾®ä¿¡è‡ªåŠ¨å‘å¸ƒé£æ§å‘Šè­¦ - {event.event_type.name}"
        self._send_email_alert(event, subject, urgent=True)
        self._send_sms_alert(event)

    def send_normal_alert(self, event: RiskEvent):
        """å‘é€æ™®é€šå‘Šè­¦ (ä»…é‚®ä»¶)"""
        subject = f"[è­¦å‘Š] å¾®ä¿¡è‡ªåŠ¨å‘å¸ƒå·²åœæœº - {event.event_type.name}"
        self._send_email_alert(event, subject, urgent=False)

    def _send_email_alert(self, event: RiskEvent, subject: str, urgent: bool):
        """å‘é€é‚®ä»¶å‘Šè­¦"""
        if not self.email_config.get('enabled'):
            logger.warning("é‚®ä»¶å‘Šè­¦æœªå¯ç”¨")
            return

        try:
            msg = MIMEMultipart()
            msg['Subject'] = subject
            msg['From'] = self.email_config['sender']
            msg['To'] = ', '.join(self.email_config['recipients'])

            # é‚®ä»¶æ­£æ–‡
            body = self._format_alert_body(event, urgent)
            msg.attach(MIMEText(body, 'html', 'utf-8'))

            # é™„åŠ æˆªå›¾ (å¦‚æœ‰)
            if event.screenshot_path and Path(event.screenshot_path).exists():
                with open(event.screenshot_path, 'rb') as f:
                    img = MIMEImage(f.read())
                    img.add_header('Content-Disposition', 'attachment',
                                   filename='screenshot.png')
                    msg.attach(img)

            # å‘é€
            with smtplib.SMTP_SSL(
                self.email_config['smtp_host'],
                self.email_config.get('smtp_port', 465)
            ) as server:
                server.login(
                    self.email_config['smtp_user'],
                    self.email_config['smtp_password']
                )
                server.send_message(msg)

            logger.info(f"å‘Šè­¦é‚®ä»¶å·²å‘é€: {subject}")

        except Exception as e:
            logger.error(f"å‘é€å‘Šè­¦é‚®ä»¶å¤±è´¥: {e}")

    def _format_alert_body(self, event: RiskEvent, urgent: bool) -> str:
        """æ ¼å¼åŒ–å‘Šè­¦é‚®ä»¶æ­£æ–‡"""
        urgency = "ğŸš¨ ç´§æ€¥" if urgent else "âš ï¸ è­¦å‘Š"

        return f"""
        <html>
        <body style="font-family: Arial, sans-serif;">
            <h2 style="color: {'red' if urgent else 'orange'};">{urgency} - å¾®ä¿¡è‡ªåŠ¨å‘å¸ƒç³»ç»Ÿå‘Šè­¦</h2>

            <table style="border-collapse: collapse; width: 100%;">
                <tr>
                    <td style="padding: 8px; border: 1px solid #ddd; font-weight: bold;">äº‹ä»¶ç±»å‹</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">{event.event_type.name}</td>
                </tr>
                <tr>
                    <td style="padding: 8px; border: 1px solid #ddd; font-weight: bold;">é£é™©ç­‰çº§</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">{event.level.value.upper()}</td>
                </tr>
                <tr>
                    <td style="padding: 8px; border: 1px solid #ddd; font-weight: bold;">å‘ç”Ÿæ—¶é—´</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">{event.timestamp.strftime('%Y-%m-%d %H:%M:%S')}</td>
                </tr>
                <tr>
                    <td style="padding: 8px; border: 1px solid #ddd; font-weight: bold;">æè¿°</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">{event.description}</td>
                </tr>
            </table>

            <h3>å¤„ç†è¯´æ˜</h3>
            <p style="background: #f5f5f5; padding: 15px; border-radius: 5px;">
                ç³»ç»Ÿå·²è‡ªåŠ¨åœæœºï¼Œ<strong>éœ€è¦äººå·¥æ£€æŸ¥ç¡®è®¤åæ‰èƒ½æ¢å¤</strong>ã€‚<br><br>
                æ¢å¤æ­¥éª¤ï¼š<br>
                1. æ£€æŸ¥å¾®ä¿¡å®¢æˆ·ç«¯çŠ¶æ€<br>
                2. æŸ¥çœ‹æ—¥å¿—å’Œæˆªå›¾ç¡®è®¤é—®é¢˜<br>
                3. è§£å†³é—®é¢˜åï¼Œåˆ é™¤ <code>data/.shutdown_flag</code> æ–‡ä»¶<br>
                4. é‡æ–°å¯åŠ¨ç¨‹åº
            </p>

            <p style="color: #666; font-size: 12px;">
                æ­¤é‚®ä»¶ç”±å¾®ä¿¡è‡ªåŠ¨å‘å¸ƒç³»ç»Ÿè‡ªåŠ¨å‘é€ï¼Œè¯·å‹¿å›å¤ã€‚
            </p>
        </body>
        </html>
        """

    def _send_sms_alert(self, event: RiskEvent):
        """å‘é€çŸ­ä¿¡å‘Šè­¦ (å¯é€‰)"""
        if not self.sms_config.get('enabled'):
            return

        # çŸ­ä¿¡å†…å®¹ç®€æ´
        content = f"[å¾®ä¿¡å‘å¸ƒå‘Šè­¦] {event.event_type.name}: {event.description[:50]}"

        # è°ƒç”¨çŸ­ä¿¡API (æ ¹æ®å®é™…æœåŠ¡å•†å®ç°)
        # ç¤ºä¾‹: é˜¿é‡Œäº‘çŸ­ä¿¡ã€è…¾è®¯äº‘çŸ­ä¿¡ç­‰
        logger.info(f"çŸ­ä¿¡å‘Šè­¦: {content}")
```

### 9.5 å¯åŠ¨å‰æ£€æŸ¥ä¸æ¢å¤ç¡®è®¤

```python
# core/startup_checker.py

class StartupChecker:
    """å¯åŠ¨å‰æ£€æŸ¥å™¨"""

    def __init__(self):
        self.shutdown_controller = ShutdownController

    def run_checks(self) -> bool:
        """
        æ‰§è¡Œå¯åŠ¨å‰æ£€æŸ¥

        Returns:
            bool: True=å¯ä»¥å¯åŠ¨, False=éœ€è¦äººå·¥å¤„ç†
        """
        # æ£€æŸ¥åœæœºæ ‡è®°
        can_start, shutdown_info = self.shutdown_controller.check_can_start()

        if not can_start:
            self._print_shutdown_notice(shutdown_info)
            return False

        return True

    def _print_shutdown_notice(self, info: dict):
        """æ‰“å°åœæœºæç¤º"""
        print("\n" + "="*60)
        print("âš ï¸  ç³»ç»Ÿå› é£æ§äº‹ä»¶å·²åœæœºï¼Œéœ€è¦äººå·¥ç¡®è®¤åæ‰èƒ½å¯åŠ¨")
        print("="*60)
        print(f"\nåœæœºæ—¶é—´: {info.get('shutdown_time')}")
        print(f"äº‹ä»¶ç±»å‹: {info.get('event_type')}")
        print(f"é£é™©ç­‰çº§: {info.get('risk_level')}")
        print(f"äº‹ä»¶æè¿°: {info.get('description')}")
        print(f"\næ¢å¤æŒ‡å¼•:\n{info.get('recovery_instructions')}")
        print("\n" + "-"*60)
        print("ç¡®è®¤é—®é¢˜å·²è§£å†³åï¼Œè¯·åˆ é™¤æ–‡ä»¶: data/.shutdown_flag")
        print("ç„¶åé‡æ–°å¯åŠ¨ç¨‹åº")
        print("="*60 + "\n")


# ä¸»ç¨‹åºå…¥å£ä½¿ç”¨ç¤ºä¾‹
def main():
    # å¯åŠ¨å‰æ£€æŸ¥
    checker = StartupChecker()
    if not checker.run_checks():
        sys.exit(1)

    # æ­£å¸¸å¯åŠ¨æµç¨‹...
```

### 9.6 é£æ§é…ç½®

```yaml
# config/risk_control.yaml

risk_control:
  enabled: true

  # åœæœºç­–ç•¥
  shutdown_policy:
    # LOW é£é™©: ä»…è®°å½•ï¼Œä¸åœæœº
    # MEDIUM åŠä»¥ä¸Š: ç«‹å³åœæœº
    min_shutdown_level: "MEDIUM"

    # è¿ç»­ä½é£é™©äº‹ä»¶é˜ˆå€¼ (è¶…è¿‡åå‡çº§ä¸ºä¸­é£é™©)
    low_risk_escalation_threshold: 3

  # æ£€æµ‹é…ç½®
  detection:
    # æ¯æ¬¡æ“ä½œåæ£€æŸ¥çª—å£æ ‡é¢˜
    check_window_title: true
    # æ“ä½œå¤±è´¥æ—¶æˆªå›¾å¹¶OCRæ£€æŸ¥
    check_screenshot_on_failure: true
    # OCRè¯­è¨€
    ocr_language: "chi_sim"

  # å‘Šè­¦é…ç½®
  alerts:
    email:
      enabled: true
      sender: "alert@yourcompany.com"
      recipients:
        - "admin@yourcompany.com"
        - "ops@yourcompany.com"
      smtp_host: "smtp.yourcompany.com"
      smtp_port: 465
      smtp_user: "alert@yourcompany.com"
      smtp_password: "${SMTP_PASSWORD}"  # ä»ç¯å¢ƒå˜é‡è¯»å–

    sms:
      enabled: false  # æŒ‰éœ€å¯ç”¨
      # provider: "aliyun"
      # ...

  # æ¢å¤é…ç½®
  recovery:
    # æ¢å¤å‰å¿…é¡»äººå·¥ç¡®è®¤ (åˆ é™¤ .shutdown_flag)
    require_human_confirmation: true
    # æ¢å¤åçš„å†·å´æœŸ (ç§’)
    cooldown_after_recovery: 300
```

### 9.7 ä¸å‘å¸ƒæµç¨‹é›†æˆ

```python
# åœ¨ PublishManager ä¸­é›†æˆé£æ§

class PublishManager:
    def __init__(self, ...):
        # ...
        self.risk_detector = RiskDetector()
        self.shutdown_controller = ShutdownController(AlertManager(config))

    def publish_article(self, task: PublishTask) -> PublishResult:
        """å‘å¸ƒæ–‡ç«  - é›†æˆé£æ§æ£€æµ‹"""
        try:
            # æ‰§è¡Œå‘å¸ƒæ“ä½œ
            result = self._do_publish(task)

            # æ£€æŸ¥æ“ä½œç»“æœ
            if not result.success:
                risk_event = self.risk_detector.check_operation_result(
                    success=False,
                    error_msg=result.error_message
                )
                if risk_event:
                    # äº¤ç»™åœæœºæ§åˆ¶å™¨å¤„ç†
                    self.shutdown_controller.handle_risk_event(risk_event)

            return result

        except Exception as e:
            # å¼‚å¸¸ä¹Ÿè§†ä¸ºæ½œåœ¨é£æ§äº‹ä»¶
            screenshot = self._take_screenshot()
            risk_event = self.risk_detector.check_screenshot(screenshot)

            if risk_event:
                self.shutdown_controller.handle_risk_event(risk_event)
            else:
                # æœªè¯†åˆ«çš„å¼‚å¸¸ï¼Œé»˜è®¤ä¸­é£é™©åœæœº
                self.shutdown_controller.handle_risk_event(
                    RiskEvent(
                        event_type=RiskEventType.UNUSUAL_ACTIVITY_ALERT,
                        level=RiskLevel.MEDIUM,
                        timestamp=datetime.now(),
                        description=f"å‘å¸ƒå¼‚å¸¸: {str(e)}",
                        screenshot_path=screenshot
                    )
                )

            raise
```

---

## åã€è¿›ç¨‹å®ˆæŠ¤ä¸å¼‚å¸¸æ¢å¤

### 10.1 å¾®ä¿¡è¿›ç¨‹å®ˆæŠ¤

```python
# core/process_guardian.py

import subprocess
import psutil
import time

class WeChatGuardian:
    """å¾®ä¿¡è¿›ç¨‹å®ˆæŠ¤"""

    WECHAT_PROCESS_NAME = "WeChat.exe"
    WECHAT_DEFAULT_PATH = r"C:\Program Files\Tencent\WeChat\WeChat.exe"

    def __init__(self, wechat_path: str = None):
        self.wechat_path = wechat_path or self.WECHAT_DEFAULT_PATH

    def is_running(self) -> bool:
        """æ£€æŸ¥å¾®ä¿¡æ˜¯å¦åœ¨è¿è¡Œ"""
        for proc in psutil.process_iter(['name']):
            if proc.info['name'] == self.WECHAT_PROCESS_NAME:
                return True
        return False

    def start_wechat(self) -> bool:
        """å¯åŠ¨å¾®ä¿¡"""
        try:
            subprocess.Popen(self.wechat_path)
            logger.info("æ­£åœ¨å¯åŠ¨å¾®ä¿¡...")

            # ç­‰å¾…å¾®ä¿¡çª—å£å‡ºç° (æœ€å¤š60ç§’)
            for _ in range(60):
                time.sleep(1)
                if self.find_main_window():
                    logger.info("å¾®ä¿¡å¯åŠ¨æˆåŠŸ")
                    return True

            logger.error("å¾®ä¿¡å¯åŠ¨è¶…æ—¶")
            return False
        except Exception as e:
            logger.error(f"å¯åŠ¨å¾®ä¿¡å¤±è´¥: {e}")
            return False

    def find_main_window(self):
        """æŸ¥æ‰¾å¾®ä¿¡ä¸»çª—å£"""
        import uiautomation as auto
        try:
            return auto.WindowControl(ClassName='WeChatMainWndForPC', searchDepth=1)
        except Exception:
            return None

    def ensure_running(self) -> bool:
        """ç¡®ä¿å¾®ä¿¡åœ¨è¿è¡Œ"""
        if self.is_running():
            return True

        logger.warning("å¾®ä¿¡æœªè¿è¡Œ, å°è¯•å¯åŠ¨...")
        return self.start_wechat()
```

### 10.2 å¾®ä¿¡ç™»å½•çŠ¶æ€æ£€æµ‹

```python
# core/login_checker.py

import uiautomation as auto
import time

class WeChatLoginState:
    """å¾®ä¿¡ç™»å½•çŠ¶æ€æšä¸¾"""
    LOGGED_IN = "logged_in"           # å·²ç™»å½•
    LOGGED_OUT = "logged_out"         # æœªç™»å½• (æ˜¾ç¤ºäºŒç»´ç )
    LOGGING_IN = "logging_in"         # ç™»å½•ä¸­ (ç­‰å¾…æ‰‹æœºç¡®è®¤)
    UNKNOWN = "unknown"               # æœªçŸ¥çŠ¶æ€


class WeChatLoginChecker:
    """å¾®ä¿¡ç™»å½•çŠ¶æ€æ£€æµ‹å™¨"""

    def __init__(self):
        self.locator = ElementLocator()

    def get_login_state(self) -> str:
        """
        æ£€æµ‹å½“å‰å¾®ä¿¡ç™»å½•çŠ¶æ€

        Returns:
            WeChatLoginState æšä¸¾å€¼
        """
        try:
            # 1. æ£€æŸ¥å¾®ä¿¡ä¸»çª—å£æ˜¯å¦å­˜åœ¨
            main_window = auto.WindowControl(
                ClassName='WeChatMainWndForPC',
                searchDepth=1
            )

            if not main_window.Exists(2):
                # æ£€æŸ¥æ˜¯å¦æ˜¯ç™»å½•çª—å£
                login_window = auto.WindowControl(
                    ClassName='WeChatLoginWndForPC',
                    searchDepth=1
                )
                if login_window.Exists(1):
                    return self._check_login_window_state(login_window)
                return WeChatLoginState.UNKNOWN

            # 2. ä¸»çª—å£å­˜åœ¨, æ£€æŸ¥æ˜¯å¦çœŸæ­£ç™»å½•
            # æ£€æŸ¥èŠå¤©åˆ—è¡¨æ˜¯å¦å¯è§
            chat_list = main_window.ListControl(Name='ä¼šè¯')
            if chat_list and chat_list.Exists(1):
                return WeChatLoginState.LOGGED_IN

            # æ£€æŸ¥æ˜¯å¦æœ‰è”ç³»äººåˆ—è¡¨
            contact_list = main_window.ListControl(Name='è”ç³»äºº')
            if contact_list and contact_list.Exists(1):
                return WeChatLoginState.LOGGED_IN

            return WeChatLoginState.UNKNOWN

        except Exception as e:
            logger.error(f"æ£€æµ‹ç™»å½•çŠ¶æ€å¤±è´¥: {e}")
            return WeChatLoginState.UNKNOWN

    def _check_login_window_state(self, login_window) -> str:
        """æ£€æŸ¥ç™»å½•çª—å£çš„å…·ä½“çŠ¶æ€"""
        try:
            # æ£€æŸ¥æ˜¯å¦æ˜¾ç¤ºäºŒç»´ç 
            qr_image = login_window.ImageControl(searchDepth=5)
            if qr_image and qr_image.Exists(0.5):
                return WeChatLoginState.LOGGED_OUT

            # æ£€æŸ¥æ˜¯å¦æ˜¾ç¤º "è¯·åœ¨æ‰‹æœºä¸Šç¡®è®¤ç™»å½•"
            confirm_text = login_window.TextControl(Name='è¯·åœ¨æ‰‹æœºä¸Šç¡®è®¤ç™»å½•')
            if confirm_text and confirm_text.Exists(0.5):
                return WeChatLoginState.LOGGING_IN

            return WeChatLoginState.LOGGED_OUT
        except Exception:
            return WeChatLoginState.UNKNOWN

    def wait_for_login(self, timeout: int = 120) -> bool:
        """
        ç­‰å¾…ç”¨æˆ·ç™»å½•

        Args:
            timeout: æœ€å¤§ç­‰å¾…æ—¶é—´ (ç§’)

        Returns:
            True å¦‚æœç™»å½•æˆåŠŸ, False å¦‚æœè¶…æ—¶
        """
        start_time = time.time()

        while time.time() - start_time < timeout:
            state = self.get_login_state()

            if state == WeChatLoginState.LOGGED_IN:
                logger.info("å¾®ä¿¡ç™»å½•æˆåŠŸ")
                return True

            if state == WeChatLoginState.LOGGED_OUT:
                logger.info("ç­‰å¾…æ‰«ç ç™»å½•...")
            elif state == WeChatLoginState.LOGGING_IN:
                logger.info("ç­‰å¾…æ‰‹æœºç¡®è®¤...")

            time.sleep(2)

        logger.error(f"ç­‰å¾…ç™»å½•è¶…æ—¶ ({timeout}ç§’)")
        return False

    def ensure_logged_in(self) -> bool:
        """
        ç¡®ä¿å¾®ä¿¡å·²ç™»å½•

        Returns:
            True å¦‚æœå·²ç™»å½•, False å¦‚æœæœªç™»å½•ä¸”ç­‰å¾…è¶…æ—¶
        """
        state = self.get_login_state()

        if state == WeChatLoginState.LOGGED_IN:
            return True

        if state == WeChatLoginState.UNKNOWN:
            logger.warning("æ— æ³•æ£€æµ‹å¾®ä¿¡çŠ¶æ€, è¯·ç¡®ä¿å¾®ä¿¡å·²å¯åŠ¨")
            return False

        # éœ€è¦ç™»å½•
        logger.warning("å¾®ä¿¡æœªç™»å½•, è¯·æ‰«ç ç™»å½•")

        # æ˜¾ç¤ºæé†’ (å¯é€‰: å‘é€é€šçŸ¥)
        self._notify_login_required()

        # ç­‰å¾…ç™»å½•
        return self.wait_for_login()

    def _notify_login_required(self):
        """é€šçŸ¥ç”¨æˆ·éœ€è¦ç™»å½•"""
        # å¯ä»¥å‘é€é‚®ä»¶ã€ç³»ç»Ÿé€šçŸ¥ç­‰
        pass


def check_wechat_ready() -> tuple[bool, str]:
    """
    æ£€æŸ¥å¾®ä¿¡æ˜¯å¦å°±ç»ª (ç»¼åˆæ£€æŸ¥)

    Returns:
        (ready, message)
    """
    guardian = WeChatGuardian()
    login_checker = WeChatLoginChecker()

    # 1. æ£€æŸ¥è¿›ç¨‹
    if not guardian.is_running():
        return False, "å¾®ä¿¡è¿›ç¨‹æœªè¿è¡Œ"

    # 2. æ£€æŸ¥çª—å£
    if not guardian.find_main_window():
        return False, "å¾®ä¿¡çª—å£ä¸å­˜åœ¨"

    # 3. æ£€æŸ¥ç™»å½•çŠ¶æ€
    state = login_checker.get_login_state()
    if state != WeChatLoginState.LOGGED_IN:
        state_msg = {
            WeChatLoginState.LOGGED_OUT: "å¾®ä¿¡æœªç™»å½•, è¯·æ‰«ç ",
            WeChatLoginState.LOGGING_IN: "ç­‰å¾…æ‰‹æœºç¡®è®¤ç™»å½•",
            WeChatLoginState.UNKNOWN: "æ— æ³•ç¡®å®šç™»å½•çŠ¶æ€",
        }
        return False, state_msg.get(state, "æœªçŸ¥çŠ¶æ€")

    return True, "å¾®ä¿¡å·²å°±ç»ª"
```

### 10.3 ä»»åŠ¡æ¢å¤æµç¨‹

```python
def recover_on_startup():
    """å¯åŠ¨æ—¶æ¢å¤æµç¨‹"""

    # 1. æ£€æŸ¥ä¸Šæ¬¡å¼‚å¸¸é€€å‡ºçš„ä»»åŠ¡
    interrupted_tasks = db.query(
        "SELECT * FROM tasks WHERE status = 'running'"
    )

    for task in interrupted_tasks:
        logger.warning(f"å‘ç°ä¸­æ–­çš„ä»»åŠ¡: {task.id}")
        # æ ‡è®°ä¸ºå¤±è´¥, ç­‰å¾…é‡è¯•
        task.status = 'failed'
        task.error_message = "ç¨‹åºå¼‚å¸¸é€€å‡ºå¯¼è‡´ä¸­æ–­"
        task.retry_count += 1
        db.update(task)

    # 2. æ£€æŸ¥æ¼å‘çš„å®šæ—¶ä»»åŠ¡
    missed_tasks = db.query(
        "SELECT * FROM tasks WHERE status = 'scheduled' AND scheduled_time < ?",
        [datetime.now()]
    )

    for task in missed_tasks:
        logger.warning(f"å‘ç°æ¼å‘çš„ä»»åŠ¡: {task.id}, è®¡åˆ’æ—¶é—´: {task.scheduled_time}")
        # å¯é€‰: ç«‹å³æ‰§è¡Œæˆ–æ ‡è®°ä¸º failed (æ¼å‘)
        if should_execute_missed_task(task):
            queue_manager.add_task(task, priority=8)  # é«˜ä¼˜å…ˆçº§è¡¥å‘
        else:
            task.status = 'failed'  # ä½¿ç”¨è§„èŒƒçŠ¶æ€å€¼
            task.failure_reason = 'missed_schedule'  # æ¼å‘æ ‡è®°
            db.update(task)
```

---

## åä¸€ã€å…±äº«æ–‡ä»¶å¤¹å®¹é”™å¤„ç†

### 11.1 æ–‡ä»¶é”ä¸å ç”¨æ£€æµ‹

```python
# data/file_lock.py

import os
import time
import ctypes
from contextlib import contextmanager

class FileLockError(Exception):
    """æ–‡ä»¶é”å¼‚å¸¸"""
    pass

class ExcelOccupiedError(FileLockError):
    """Excel æ–‡ä»¶è¢«å ç”¨"""
    pass

def is_file_locked(filepath: str) -> bool:
    """
    æ£€æµ‹æ–‡ä»¶æ˜¯å¦è¢«å…¶ä»–è¿›ç¨‹é”å®š
    é€‚ç”¨äºæ£€æµ‹ Excel æ–‡ä»¶æ˜¯å¦è¢« Excel ç¨‹åºæ‰“å¼€
    """
    if not os.path.exists(filepath):
        return False

    try:
        # å°è¯•ä»¥ç‹¬å å†™æ¨¡å¼æ‰“å¼€æ–‡ä»¶
        with open(filepath, 'r+b') as f:
            # Windows ç‰¹å®š: å°è¯•è·å–æ–‡ä»¶é”
            if os.name == 'nt':
                import msvcrt
                msvcrt.locking(f.fileno(), msvcrt.LK_NBLCK, 1)
                msvcrt.locking(f.fileno(), msvcrt.LK_UNLCK, 1)
            return False
    except (IOError, OSError, PermissionError):
        return True


def wait_for_file_unlock(filepath: str, timeout: int = 30, interval: float = 1.0) -> bool:
    """
    ç­‰å¾…æ–‡ä»¶è§£é”

    Args:
        filepath: æ–‡ä»¶è·¯å¾„
        timeout: æœ€å¤§ç­‰å¾…æ—¶é—´ (ç§’)
        interval: æ£€æŸ¥é—´éš” (ç§’)

    Returns:
        True å¦‚æœæ–‡ä»¶å·²è§£é”, False å¦‚æœè¶…æ—¶
    """
    start_time = time.time()

    while time.time() - start_time < timeout:
        if not is_file_locked(filepath):
            return True
        logger.debug(f"æ–‡ä»¶è¢«å ç”¨, ç­‰å¾…ä¸­: {filepath}")
        time.sleep(interval)

    return False


@contextmanager
def safe_excel_read(filepath: str, max_retries: int = 3, retry_interval: int = 5):
    """
    å®‰å…¨è¯»å– Excel æ–‡ä»¶çš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨

    ç”¨æ³•:
        with safe_excel_read("data.xlsx") as can_read:
            if can_read:
                df = pd.read_excel("data.xlsx")
    """
    for attempt in range(max_retries):
        if is_file_locked(filepath):
            logger.warning(
                f"Excel æ–‡ä»¶è¢«å ç”¨ (å°è¯• {attempt + 1}/{max_retries}): {filepath}"
            )
            if attempt < max_retries - 1:
                time.sleep(retry_interval)
                continue
            else:
                raise ExcelOccupiedError(
                    f"Excel æ–‡ä»¶è¢«å…¶ä»–ç¨‹åºå ç”¨, è¯·å…³é—­åé‡è¯•: {filepath}"
                )
        else:
            yield True
            return

    yield False


def check_excel_temp_files(filepath: str) -> bool:
    """
    æ£€æŸ¥ Excel ä¸´æ—¶æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    Excel æ‰“å¼€æ–‡ä»¶æ—¶ä¼šåˆ›å»º ~$filename.xlsx ä¸´æ—¶æ–‡ä»¶
    """
    directory = os.path.dirname(filepath)
    filename = os.path.basename(filepath)
    temp_filename = f"~${filename}"
    temp_filepath = os.path.join(directory, temp_filename)

    return os.path.exists(temp_filepath)


class ExcelFileChecker:
    """Excel æ–‡ä»¶æ£€æŸ¥å™¨"""

    def __init__(self, filepath: str):
        self.filepath = filepath

    def can_read(self) -> tuple[bool, str]:
        """
        æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å¯è¯»

        Returns:
            (can_read, message)
        """
        # 1. æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if not os.path.exists(self.filepath):
            return False, f"æ–‡ä»¶ä¸å­˜åœ¨: {self.filepath}"

        # 2. æ£€æŸ¥ä¸´æ—¶æ–‡ä»¶ (å¿«é€Ÿæ£€æµ‹)
        if check_excel_temp_files(self.filepath):
            return False, "æ£€æµ‹åˆ° Excel ä¸´æ—¶æ–‡ä»¶, æ–‡ä»¶å¯èƒ½æ­£åœ¨è¢«ç¼–è¾‘"

        # 3. æ£€æŸ¥æ–‡ä»¶é”
        if is_file_locked(self.filepath):
            return False, "æ–‡ä»¶è¢«å…¶ä»–ç¨‹åºé”å®š, è¯·å…³é—­åé‡è¯•"

        # 4. æ£€æŸ¥æ–‡ä»¶å¤§å°
        if os.path.getsize(self.filepath) == 0:
            return False, "æ–‡ä»¶å¤§å°ä¸º 0, å¯èƒ½æŸå"

        return True, "æ–‡ä»¶å¯è¯»"

    def wait_and_read(self, timeout: int = 30) -> bool:
        """ç­‰å¾…æ–‡ä»¶å¯è¯»"""
        can_read, _ = self.can_read()
        if can_read:
            return True

        logger.info(f"ç­‰å¾…æ–‡ä»¶è§£é” (æœ€å¤š {timeout} ç§’): {self.filepath}")
        return wait_for_file_unlock(self.filepath, timeout)
```

### 11.2 æ–‡ä»¶åŠ è½½ç­–ç•¥

```python
def safe_load_from_share(share_path: str, local_cache_dir: str):
    """å®‰å…¨åŠ è½½å…±äº«æ–‡ä»¶"""

    # 1. æ£€æŸ¥å…±äº«è·¯å¾„å¯è¾¾
    if not os.path.exists(share_path):
        raise ShareNotAccessibleError(f"å…±äº«è·¯å¾„ä¸å¯è¾¾: {share_path}")

    # 2. å¤åˆ¶åˆ°æœ¬åœ°ç¼“å­˜
    filename = os.path.basename(share_path)
    local_path = os.path.join(local_cache_dir, filename)

    try:
        shutil.copy2(share_path, local_path)
    except Exception as e:
        raise FileCopyError(f"å¤åˆ¶æ–‡ä»¶å¤±è´¥: {e}")

    # 3. æ ¡éªŒå®Œæ•´æ€§ (æ–‡ä»¶å¤§å°/MD5)
    if os.path.getsize(local_path) != os.path.getsize(share_path):
        raise FileIntegrityError("æ–‡ä»¶å¤åˆ¶ä¸å®Œæ•´")

    # 4. ä»æœ¬åœ°è¯»å–
    return parse_excel(local_path)
```

### 11.3 å›¾ç‰‡ç¼ºå¤±å¤„ç†

```python
def validate_images(content: Content) -> ValidationResult:
    """æ ¡éªŒå›¾ç‰‡æ–‡ä»¶"""
    result = ValidationResult()

    for i, img_path in enumerate(content.image_paths):
        full_path = resolve_path(img_path)

        if not os.path.exists(full_path):
            result.add_error(f"å›¾ç‰‡ {i+1} ä¸å­˜åœ¨: {img_path}")
        elif os.path.getsize(full_path) == 0:
            result.add_error(f"å›¾ç‰‡ {i+1} å¤§å°ä¸º0: {img_path}")
        elif not is_valid_image(full_path):
            result.add_error(f"å›¾ç‰‡ {i+1} æ ¼å¼æ— æ•ˆ: {img_path}")

    if result.has_errors():
        result.status = "need_confirm"  # éœ€äººå·¥ç¡®è®¤

    return result
```

### 11.4 ç¼“å­˜æ¸…ç†ç­–ç•¥

```yaml
# config.yaml
cache:
  max_age_days: 7           # ç¼“å­˜ä¿ç•™å¤©æ•°
  max_size_mb: 500          # ç¼“å­˜æœ€å¤§å®¹é‡
  cleanup_on_startup: true  # å¯åŠ¨æ—¶æ¸…ç†è¿‡æœŸç¼“å­˜
```

```python
def cleanup_cache():
    """æ¸…ç†è¿‡æœŸç¼“å­˜"""
    cache_dir = config.cache.dir
    max_age = timedelta(days=config.cache.max_age_days)

    for file in os.listdir(cache_dir):
        file_path = os.path.join(cache_dir, file)
        file_age = datetime.now() - datetime.fromtimestamp(os.path.getmtime(file_path))

        if file_age > max_age:
            os.remove(file_path)
            logger.info(f"æ¸…ç†è¿‡æœŸç¼“å­˜: {file}")
```

---

## åäºŒã€å›æ‰§ä¸åé¦ˆé—­ç¯

### 12.1 å›æ‰§æ–‡ä»¶ç”Ÿæˆ

è§£å†³ç”µè„‘ A æ— æ³•ç›´è§‚æŸ¥çœ‹å‘å¸ƒçŠ¶æ€çš„é—®é¢˜:

```python
# data/receipt_generator.py

import openpyxl
from datetime import datetime

class ReceiptGenerator:
    """å›æ‰§æ–‡ä»¶ç”Ÿæˆå™¨"""

    def generate_daily_receipt(self, date: str = None):
        """ç”Ÿæˆæ¯æ—¥å›æ‰§"""
        date = date or datetime.now().strftime('%Y-%m-%d')

        # æŸ¥è¯¢å½“æ—¥ä»»åŠ¡
        tasks = db.query(
            "SELECT * FROM tasks WHERE DATE(created_at) = ?",
            [date]
        )

        # åˆ›å»º Excel
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "å‘å¸ƒå›æ‰§"

        # è¡¨å¤´
        headers = ["äº§å“ç¼–å·", "äº§å“åç§°", "æ¸ é“", "çŠ¶æ€", "è®¡åˆ’æ—¶é—´", "å®é™…æ—¶é—´", "å¤±è´¥åŸå› "]
        ws.append(headers)

        # æ•°æ®è¡Œ
        for task in tasks:
            ws.append([
                task.content_code,
                task.product_name,
                "æœ‹å‹åœˆ" if task.channel == "moment" else "ç¾¤å‘",
                self._status_text(task.status),
                task.scheduled_time,
                task.actual_time,
                task.error_message or ""
            ])

        # ä¿å­˜åˆ°å…±äº«æ–‡ä»¶å¤¹ (æ–‡ä»¶ååŒ…å«ç”Ÿæˆæ—¶é—´æˆ³, é¿å…è¦†ç›–)
        timestamp = datetime.now().strftime('%H%M%S')
        receipt_path = os.path.join(
            config.share_folder,
            f"receipt_{date}_{timestamp}.xlsx"
        )
        wb.save(receipt_path)

        logger.info(f"å›æ‰§æ–‡ä»¶å·²ç”Ÿæˆ: {receipt_path}")
        return receipt_path

    def _status_text(self, status: str) -> str:
        mapping = {
            'success': 'æˆåŠŸ',
            'failed': 'å¤±è´¥',
            'pending': 'å¾…å‘å¸ƒ',
            'scheduled': 'å·²æ’æœŸ',
            'skipped': 'å·²è·³è¿‡'
        }
        return mapping.get(status, status)
```

### 12.2 è‡ªåŠ¨åŒæ­¥å›æ‰§

```yaml
# config.yaml
receipt:
  enabled: true
  auto_generate: true           # è‡ªåŠ¨ç”Ÿæˆ
  generate_time: "22:00"        # æ¯å¤©22ç‚¹ç”Ÿæˆ
  sync_to_share: true           # åŒæ­¥åˆ°å…±äº«æ–‡ä»¶å¤¹
  share_path: "\\\\192.168.1.100\\wechat-export\\receipts"
```

### 12.3 å›æ‰§åˆ†å‘ç­–ç•¥

> **å®‰å…¨è¦æ±‚**: ä¸åŒæ¸ é“åˆ†å‘ä¸åŒç‰ˆæœ¬çš„å›æ‰§ï¼Œé‚®ä»¶åªå‘é€è„±æ•ç‰ˆæœ¬ã€‚

#### 12.3.1 å›æ‰§ç‰ˆæœ¬å®šä¹‰

| ç‰ˆæœ¬ç±»å‹ | åŒ…å«å†…å®¹ | åˆ†å‘æ¸ é“ | æƒé™è¦æ±‚ |
|---------|---------|---------|---------|
| **å®Œæ•´ç‰ˆ** | æ‰€æœ‰å­—æ®µ (å«ç¾¤å/å¾®ä¿¡å·) | ä»…æœ¬åœ°å­˜å‚¨ | ç®¡ç†å‘˜ |
| **è„±æ•ç‰ˆ** | éšè—æ•æ„Ÿå­—æ®µ | é‚®ä»¶/å…±äº«æ–‡ä»¶å¤¹ | æ“ä½œå‘˜ |
| **æ‘˜è¦ç‰ˆ** | ä»…ç»Ÿè®¡æ•°æ® | é’‰é’‰/ä¼å¾®é€šçŸ¥ | æ‰€æœ‰äºº |

#### 12.3.2 è„±æ•è§„åˆ™

```python
# data/receipt_sanitizer.py

from dataclasses import dataclass
from typing import Optional
import re

@dataclass
class SanitizationRule:
    """è„±æ•è§„åˆ™"""
    field: str
    method: str  # mask, hash, remove, aggregate
    params: dict = None

# é»˜è®¤è„±æ•è§„åˆ™
DEFAULT_SANITIZATION_RULES = [
    SanitizationRule(field="group_name", method="mask", params={"keep_first": 2, "keep_last": 0}),
    SanitizationRule(field="wechat_id", method="hash", params={"algorithm": "sha256", "truncate": 8}),
    SanitizationRule(field="phone", method="mask", params={"keep_first": 3, "keep_last": 4}),
    SanitizationRule(field="error_message", method="remove"),  # é”™è¯¯ä¿¡æ¯å¯èƒ½å«æ•æ„Ÿè·¯å¾„
    SanitizationRule(field="screenshot_path", method="remove"),
]

class ReceiptSanitizer:
    """å›æ‰§è„±æ•å™¨"""

    def __init__(self, rules: list = None):
        self.rules = rules or DEFAULT_SANITIZATION_RULES
        self._rule_map = {r.field: r for r in self.rules}

    def sanitize_record(self, record: dict) -> dict:
        """è„±æ•å•æ¡è®°å½•"""
        sanitized = record.copy()

        for field, rule in self._rule_map.items():
            if field not in sanitized:
                continue

            value = sanitized[field]
            if value is None:
                continue

            if rule.method == "mask":
                sanitized[field] = self._mask(str(value), rule.params or {})
            elif rule.method == "hash":
                sanitized[field] = self._hash(str(value), rule.params or {})
            elif rule.method == "remove":
                sanitized[field] = "[å·²è„±æ•]"

        return sanitized

    def _mask(self, value: str, params: dict) -> str:
        """æ©ç è„±æ•: ä¿ç•™é¦–å°¾å­—ç¬¦"""
        keep_first = params.get('keep_first', 1)
        keep_last = params.get('keep_last', 1)

        if len(value) <= keep_first + keep_last:
            return '*' * len(value)

        masked_len = len(value) - keep_first - keep_last
        return value[:keep_first] + '*' * masked_len + value[-keep_last:] if keep_last else value[:keep_first] + '*' * masked_len

    def _hash(self, value: str, params: dict) -> str:
        """å“ˆå¸Œè„±æ•: ä¸å¯é€†"""
        import hashlib
        algorithm = params.get('algorithm', 'sha256')
        truncate = params.get('truncate', 8)

        hash_obj = hashlib.new(algorithm)
        hash_obj.update(value.encode('utf-8'))
        return hash_obj.hexdigest()[:truncate]
```

#### 12.3.3 åˆ†å‘æ‰§è¡Œå™¨

```python
# data/receipt_distributor.py

class ReceiptDistributor:
    """å›æ‰§åˆ†å‘å™¨"""

    def __init__(self, config: dict, sanitizer: ReceiptSanitizer):
        self.config = config
        self.sanitizer = sanitizer

    def distribute(self, receipt_data: list, channels: list = None):
        """
        åˆ†å‘å›æ‰§åˆ°æŒ‡å®šæ¸ é“

        Args:
            receipt_data: å®Œæ•´å›æ‰§æ•°æ®
            channels: åˆ†å‘æ¸ é“åˆ—è¡¨ ['local', 'email', 'share', 'webhook']
        """
        channels = channels or self.config.get('distribution_channels', ['local'])

        for channel in channels:
            if channel == 'local':
                # æœ¬åœ°å­˜å‚¨: å®Œæ•´ç‰ˆ
                self._save_local(receipt_data, sanitized=False)

            elif channel == 'email':
                # é‚®ä»¶: å¼ºåˆ¶è„±æ•ç‰ˆ
                sanitized_data = [self.sanitizer.sanitize_record(r) for r in receipt_data]
                self._send_email(sanitized_data)

            elif channel == 'share':
                # å…±äº«æ–‡ä»¶å¤¹: è„±æ•ç‰ˆ
                sanitized_data = [self.sanitizer.sanitize_record(r) for r in receipt_data]
                self._save_to_share(sanitized_data)

            elif channel == 'webhook':
                # ä¼å¾®/é’‰é’‰: æ‘˜è¦ç‰ˆ
                summary = self._generate_summary(receipt_data)
                self._send_webhook(summary)

    def _save_local(self, data: list, sanitized: bool):
        """ä¿å­˜åˆ°æœ¬åœ° (å®Œæ•´ç‰ˆ)"""
        suffix = "_sanitized" if sanitized else "_full"
        filename = f"receipt_{datetime.now().strftime('%Y%m%d_%H%M%S')}{suffix}.xlsx"
        path = Path("data/receipts") / filename
        path.parent.mkdir(parents=True, exist_ok=True)
        self._write_excel(data, path)
        logger.info(f"æœ¬åœ°å›æ‰§å·²ä¿å­˜: {path}")

    def _send_email(self, data: list):
        """å‘é€é‚®ä»¶ (å¼ºåˆ¶è„±æ•ç‰ˆ)"""
        # ç”Ÿæˆä¸´æ—¶Excel
        temp_path = Path("data/temp") / f"receipt_email_{datetime.now().strftime('%H%M%S')}.xlsx"
        temp_path.parent.mkdir(parents=True, exist_ok=True)
        self._write_excel(data, temp_path)

        # å‘é€é‚®ä»¶
        email_config = self.config.get('email', {})
        if not email_config.get('enabled'):
            logger.warning("é‚®ä»¶å‘é€æœªå¯ç”¨")
            return

        # é‚®ä»¶æ­£æ–‡æ˜ç¡®æ ‡æ³¨è„±æ•
        body = """
        å‘å¸ƒå›æ‰§æŠ¥å‘Š

        é™„ä»¶ä¸ºä»Šæ—¥å‘å¸ƒå›æ‰§ (è„±æ•ç‰ˆ)ã€‚
        å¦‚éœ€å®Œæ•´æ•°æ®ï¼Œè¯·ç™»å½•ç”µè„‘Bæœ¬åœ°æŸ¥çœ‹ã€‚

        ç»Ÿè®¡:
        - æˆåŠŸ: {success_count}
        - å¤±è´¥: {fail_count}
        - è·³è¿‡: {skip_count}
        """.format(
            success_count=sum(1 for r in data if r.get('status') == 'success'),
            fail_count=sum(1 for r in data if r.get('status') == 'failed'),
            skip_count=sum(1 for r in data if r.get('status') == 'skipped'),
        )

        self._send_email_with_attachment(
            subject=f"[å¾®ä¿¡å‘å¸ƒå›æ‰§] {datetime.now().strftime('%Y-%m-%d')} - è„±æ•ç‰ˆ",
            body=body,
            attachment_path=temp_path
        )

        # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        temp_path.unlink(missing_ok=True)

    def _generate_summary(self, data: list) -> dict:
        """ç”Ÿæˆæ‘˜è¦ (ä»…ç»Ÿè®¡æ•°æ®ï¼Œæ— ä»»ä½•æ•æ„Ÿä¿¡æ¯)"""
        return {
            "date": datetime.now().strftime('%Y-%m-%d'),
            "total": len(data),
            "success": sum(1 for r in data if r.get('status') == 'success'),
            "failed": sum(1 for r in data if r.get('status') == 'failed'),
            "skipped": sum(1 for r in data if r.get('status') == 'skipped'),
            "pending": sum(1 for r in data if r.get('status') == 'pending'),
        }

    def _send_webhook(self, summary: dict):
        """å‘é€Webhooké€šçŸ¥ (ä»…æ‘˜è¦)"""
        webhook_url = self.config.get('webhook_url')
        if not webhook_url:
            return

        message = (
            f"ğŸ“Š å¾®ä¿¡å‘å¸ƒæ—¥æŠ¥ {summary['date']}\n"
            f"æ€»è®¡: {summary['total']} | "
            f"æˆåŠŸ: {summary['success']} | "
            f"å¤±è´¥: {summary['failed']} | "
            f"è·³è¿‡: {summary['skipped']}"
        )

        import requests
        requests.post(webhook_url, json={"text": message}, timeout=10)
```

#### 12.3.4 åˆ†å‘é…ç½®

```yaml
# config/receipt_distribution.yaml

receipt_distribution:
  # åˆ†å‘æ¸ é“
  channels:
    - local     # æœ¬åœ°å®Œæ•´ç‰ˆ
    - email     # é‚®ä»¶è„±æ•ç‰ˆ
    - share     # å…±äº«æ–‡ä»¶å¤¹è„±æ•ç‰ˆ
    - webhook   # ä¼å¾®/é’‰é’‰æ‘˜è¦ç‰ˆ

  # é‚®ä»¶é…ç½® (å¼ºåˆ¶è„±æ•)
  email:
    enabled: true
    recipients:
      - "manager@company.com"
    subject_prefix: "[å¾®ä¿¡å‘å¸ƒå›æ‰§]"
    # é‚®ä»¶æ­£æ–‡è‡ªåŠ¨æ ‡æ³¨"è„±æ•ç‰ˆ"

  # å…±äº«æ–‡ä»¶å¤¹ (è„±æ•ç‰ˆ)
  share:
    path: "\\\\192.168.1.100\\wechat-export\\receipts"
    sanitized: true  # å¼ºåˆ¶è„±æ•ï¼Œä¸å¯é…ç½®ä¸ºfalse

  # Webhook (ä»…æ‘˜è¦)
  webhook:
    url: "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxx"
    # åªå‘é€ç»Ÿè®¡æ•°å­—ï¼Œæ— ä»»ä½•ä¸šåŠ¡æ•°æ®

  # è„±æ•è§„åˆ™
  sanitization:
    rules:
      - field: group_name
        method: mask
        keep_first: 2
      - field: wechat_id
        method: hash
      - field: phone
        method: mask
        keep_first: 3
        keep_last: 4
      - field: error_message
        method: remove
```

#### 12.3.5 å¼ºåˆ¶è„±æ•æ ¡éªŒä¸å¤±è´¥é˜»æ–­

> **å®‰å…¨è¦æ±‚**: é‚®ä»¶/å…±äº«æ¸ é“å¿…é¡»å¼ºåˆ¶æ ¡éªŒæ•°æ®å·²è„±æ•ï¼Œæ£€æµ‹åˆ°æœªè„±æ•æ•°æ®æ—¶æ‹’ç»å‘é€å¹¶å‘Šè­¦ã€‚

```python
# data/receipt_security_guard.py

from dataclasses import dataclass
from typing import List, Optional
import re

@dataclass
class SanitizationViolation:
    """è„±æ•è¿è§„è®°å½•"""
    field: str
    value_sample: str  # éƒ¨åˆ†å€¼ç”¨äºæ’æŸ¥ï¼Œä¸å®Œæ•´å±•ç¤º
    violation_type: str  # "unsanitized" | "pattern_match"

class ReceiptSecurityGuard:
    """
    å›æ‰§å®‰å…¨å®ˆå«

    èŒè´£: åœ¨å‘é€å‰å¼ºåˆ¶æ ¡éªŒæ•°æ®å·²è„±æ•ï¼Œé˜²æ­¢è¯¯é…ç½®å¯¼è‡´æ•æ„Ÿä¿¡æ¯æ³„éœ²
    """

    # æ•æ„Ÿå­—æ®µæ­£åˆ™æ¨¡å¼ (ç”¨äºæ£€æµ‹æœªè„±æ•æ•°æ®)
    SENSITIVE_PATTERNS = {
        'phone': r'^1[3-9]\d{9}$',                    # å®Œæ•´æ‰‹æœºå·
        'wechat_id': r'^[a-zA-Z][\w-]{5,19}$',        # å¾®ä¿¡IDæ ¼å¼
        'group_name': r'^[\u4e00-\u9fa5a-zA-Z0-9]{4,}$',  # å®Œæ•´ç¾¤å (4+å­—ç¬¦æ— æ©ç )
    }

    # å¿…é¡»è„±æ•çš„å­—æ®µåˆ—è¡¨
    REQUIRED_SANITIZED_FIELDS = ['group_name', 'wechat_id', 'phone', 'error_message']

    def __init__(self, config: dict, alert_manager: 'AlertManager'):
        self.config = config
        self.alert_manager = alert_manager

    def validate_before_send(
        self,
        data: List[dict],
        channel: str
    ) -> tuple[bool, List[SanitizationViolation]]:
        """
        å‘é€å‰æ ¡éªŒæ•°æ®æ˜¯å¦å·²è„±æ•

        Args:
            data: å¾…å‘é€æ•°æ®
            channel: å‘é€æ¸ é“ (email/share/webhook)

        Returns:
            (is_valid, violations): æ˜¯å¦é€šè¿‡æ ¡éªŒï¼ŒåŠè¿è§„åˆ—è¡¨
        """
        # webhook æ¸ é“åªå‘æ‘˜è¦ï¼Œæ— éœ€æ ¡éªŒ
        if channel == 'webhook':
            return True, []

        # email å’Œ share æ¸ é“å¿…é¡»æ ¡éªŒ
        if channel not in ('email', 'share'):
            return True, []

        violations = []

        for record in data:
            record_violations = self._check_record(record)
            violations.extend(record_violations)

        if violations:
            # è®°å½•å‘Šè­¦
            self._log_and_alert(violations, channel)
            return False, violations

        return True, []

    def _check_record(self, record: dict) -> List[SanitizationViolation]:
        """æ£€æŸ¥å•æ¡è®°å½•"""
        violations = []

        for field in self.REQUIRED_SANITIZED_FIELDS:
            value = record.get(field)
            if value is None or value == '[å·²è„±æ•]':
                continue  # å·²è„±æ•æˆ–ä¸ºç©º

            # æ£€æŸ¥æ˜¯å¦åŒ…å«æ©ç å­—ç¬¦
            if '*' not in str(value) and len(str(value)) > 3:
                # å¯èƒ½æœªè„±æ•ï¼Œè¿›ä¸€æ­¥æ£€æŸ¥
                if self._matches_sensitive_pattern(field, str(value)):
                    violations.append(SanitizationViolation(
                        field=field,
                        value_sample=str(value)[:3] + '***',  # åªæ˜¾ç¤ºå‰3å­—ç¬¦
                        violation_type='pattern_match'
                    ))

        return violations

    def _matches_sensitive_pattern(self, field: str, value: str) -> bool:
        """æ£€æŸ¥å€¼æ˜¯å¦åŒ¹é…æ•æ„Ÿæ•°æ®æ¨¡å¼"""
        pattern = self.SENSITIVE_PATTERNS.get(field)
        if pattern:
            return bool(re.match(pattern, value))

        # æ— ç‰¹å®šæ¨¡å¼ï¼Œæ£€æŸ¥é•¿åº¦å’Œæ©ç 
        return len(value) > 5 and '*' not in value

    def _log_and_alert(self, violations: List[SanitizationViolation], channel: str):
        """è®°å½•è¿è§„å¹¶å‘Šè­¦"""
        logger.error(
            f"[å®‰å…¨è¿è§„] æ£€æµ‹åˆ° {len(violations)} æ¡æœªè„±æ•æ•°æ®ï¼Œ"
            f"å·²é˜»æ­¢å‘é€åˆ° {channel} æ¸ é“"
        )

        for v in violations[:5]:  # åªè®°å½•å‰5æ¡
            logger.error(f"  è¿è§„å­—æ®µ: {v.field}, æ ·æœ¬: {v.value_sample}")

        # å‘é€ç´§æ€¥å‘Šè­¦
        self.alert_manager.send_urgent_alert_custom(
            subject=f"[å®‰å…¨å‘Šè­¦] å›æ‰§å‘é€è¢«é˜»æ­¢ - æ£€æµ‹åˆ°æœªè„±æ•æ•°æ®",
            body=f"""
            ä¸¥é‡: å›æ‰§å‘é€åˆ° {channel} æ¸ é“è¢«é˜»æ­¢

            æ£€æµ‹åˆ° {len(violations)} æ¡æœªè„±æ•æ•æ„Ÿæ•°æ®ã€‚
            è¿™å¯èƒ½æ˜¯é…ç½®é”™è¯¯å¯¼è‡´è„±æ•æµç¨‹è¢«ç»•è¿‡ã€‚

            è¿è§„å­—æ®µç¤ºä¾‹:
            {chr(10).join(f'- {v.field}: {v.value_sample}' for v in violations[:5])}

            è¯·ç«‹å³æ£€æŸ¥:
            1. è„±æ•é…ç½®æ˜¯å¦æ­£ç¡®
            2. ReceiptSanitizer æ˜¯å¦è¢«æ­£ç¡®è°ƒç”¨
            3. æ˜¯å¦æœ‰äººå°è¯•ç»•è¿‡è„±æ•æµç¨‹
            """
        )


class SecureReceiptDistributor(ReceiptDistributor):
    """
    å®‰å…¨å›æ‰§åˆ†å‘å™¨ (ç»§æ‰¿ ReceiptDistributor)

    å¼ºåˆ¶åœ¨å‘é€å‰è¿›è¡Œè„±æ•æ ¡éªŒ
    """

    def __init__(self, config: dict, sanitizer: ReceiptSanitizer,
                 security_guard: ReceiptSecurityGuard):
        super().__init__(config, sanitizer)
        self.security_guard = security_guard

    def _send_email(self, data: list):
        """å‘é€é‚®ä»¶ (å¸¦å¼ºåˆ¶æ ¡éªŒ)"""
        # å¼ºåˆ¶æ ¡éªŒ
        is_valid, violations = self.security_guard.validate_before_send(data, 'email')
        if not is_valid:
            logger.error(f"é‚®ä»¶å‘é€è¢«é˜»æ­¢: æ£€æµ‹åˆ° {len(violations)} æ¡æœªè„±æ•æ•°æ®")
            raise SecurityViolationError(
                f"å›æ‰§åŒ…å«æœªè„±æ•æ•°æ®ï¼Œæ‹’ç»å‘é€é‚®ä»¶ã€‚è¿è§„å­—æ®µ: "
                f"{', '.join(v.field for v in violations)}"
            )

        # é€šè¿‡æ ¡éªŒï¼Œæ‰§è¡Œå‘é€
        super()._send_email(data)

    def _save_to_share(self, data: list):
        """ä¿å­˜åˆ°å…±äº«æ–‡ä»¶å¤¹ (å¸¦å¼ºåˆ¶æ ¡éªŒ)"""
        is_valid, violations = self.security_guard.validate_before_send(data, 'share')
        if not is_valid:
            logger.error(f"å…±äº«æ–‡ä»¶å¤¹ä¿å­˜è¢«é˜»æ­¢: æ£€æµ‹åˆ° {len(violations)} æ¡æœªè„±æ•æ•°æ®")
            raise SecurityViolationError(
                f"å›æ‰§åŒ…å«æœªè„±æ•æ•°æ®ï¼Œæ‹’ç»ä¿å­˜åˆ°å…±äº«æ–‡ä»¶å¤¹ã€‚"
            )

        super()._save_to_share(data)
```

#### 12.3.6 å®Œæ•´ç‰ˆå›æ‰§è®¿é—®æ§åˆ¶

> **å®‰å…¨è¦æ±‚**: å®Œæ•´ç‰ˆå›æ‰§ä»…é™ç®¡ç†å‘˜è®¿é—®ï¼Œéœ€å£ä»¤æ ¡éªŒå’Œå®¡è®¡æ—¥å¿—ã€‚

```python
# data/receipt_access_control.py

import hashlib
import hmac
from datetime import datetime
from pathlib import Path
from typing import Optional

class ReceiptAccessControl:
    """
    å®Œæ•´ç‰ˆå›æ‰§è®¿é—®æ§åˆ¶

    å®‰å…¨æªæ–½:
    1. è§’è‰²æ ¡éªŒ (ä»… admin/super_admin å¯è®¿é—®)
    2. å£ä»¤äºŒæ¬¡éªŒè¯
    3. è®¿é—®å®¡è®¡æ—¥å¿—
    """

    FULL_RECEIPT_DIR = Path("data/receipts/full")
    ACCESS_LOG_FILE = Path("data/audit/receipt_access.jsonl")

    def __init__(self, config: dict, permission_manager: 'ModePermissionManager'):
        self.config = config
        self.permission_manager = permission_manager

        # è®¿é—®å£ä»¤å“ˆå¸Œ (ä»é…ç½®åŠ è½½)
        self._access_password_hash = config.get('full_receipt_password_hash')

    def request_access(
        self,
        operator_id: str,
        password: str,
        receipt_file: str,
        reason: str
    ) -> tuple[bool, Optional[str], str]:
        """
        è¯·æ±‚è®¿é—®å®Œæ•´ç‰ˆå›æ‰§

        Args:
            operator_id: æ“ä½œå‘˜ID
            password: è®¿é—®å£ä»¤
            receipt_file: å›æ‰§æ–‡ä»¶å
            reason: è®¿é—®åŸå› 

        Returns:
            (allowed, file_path, message): æ˜¯å¦å…è®¸ï¼Œæ–‡ä»¶è·¯å¾„ï¼Œæ¶ˆæ¯
        """
        # 1. è§’è‰²æ ¡éªŒ
        operator_level = self.permission_manager._get_operator_level(operator_id)
        if operator_level.value not in ('admin', 'super'):
            self._log_access(operator_id, receipt_file, success=False,
                           reason="æƒé™ä¸è¶³: éœ€è¦ç®¡ç†å‘˜æƒé™")
            return False, None, "æƒé™ä¸è¶³: ä»…ç®¡ç†å‘˜å¯è®¿é—®å®Œæ•´ç‰ˆå›æ‰§"

        # 2. å£ä»¤æ ¡éªŒ
        if not self._verify_password(password):
            self._log_access(operator_id, receipt_file, success=False,
                           reason="å£ä»¤éªŒè¯å¤±è´¥")
            return False, None, "è®¿é—®å£ä»¤é”™è¯¯"

        # 3. æ–‡ä»¶å­˜åœ¨æ€§æ£€æŸ¥
        file_path = self.FULL_RECEIPT_DIR / receipt_file
        if not file_path.exists():
            self._log_access(operator_id, receipt_file, success=False,
                           reason="æ–‡ä»¶ä¸å­˜åœ¨")
            return False, None, f"æ–‡ä»¶ä¸å­˜åœ¨: {receipt_file}"

        # 4. è®°å½•æˆåŠŸè®¿é—®
        self._log_access(operator_id, receipt_file, success=True,
                        reason=reason)

        logger.info(
            f"[å®¡è®¡] å®Œæ•´ç‰ˆå›æ‰§è®¿é—®: operator={operator_id}, "
            f"file={receipt_file}, reason={reason}"
        )

        return True, str(file_path), "è®¿é—®å·²æˆæƒ"

    def _verify_password(self, password: str) -> bool:
        """éªŒè¯è®¿é—®å£ä»¤"""
        if not self._access_password_hash:
            logger.warning("å®Œæ•´ç‰ˆå›æ‰§è®¿é—®å£ä»¤æœªé…ç½®")
            return False

        input_hash = hashlib.sha256(password.encode()).hexdigest()
        return hmac.compare_digest(input_hash, self._access_password_hash)

    def _log_access(self, operator_id: str, file: str,
                   success: bool, reason: str):
        """è®°å½•è®¿é—®æ—¥å¿—"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "operator_id": operator_id,
            "file": file,
            "success": success,
            "reason": reason
        }

        self.ACCESS_LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
        with open(self.ACCESS_LOG_FILE, 'a', encoding='utf-8') as f:
            f.write(json.dumps(log_entry, ensure_ascii=False) + '\n')
```

**è®¿é—®æ§åˆ¶ UI:**

```python
# ui/receipt_access_dialog.py

class FullReceiptAccessDialog(QDialog):
    """å®Œæ•´ç‰ˆå›æ‰§è®¿é—®å¯¹è¯æ¡†"""

    def __init__(self, access_control: ReceiptAccessControl,
                 operator_id: str, parent=None):
        super().__init__(parent)
        self.access_control = access_control
        self.operator_id = operator_id
        self._setup_ui()

    def _setup_ui(self):
        self.setWindowTitle("è®¿é—®å®Œæ•´ç‰ˆå›æ‰§")
        layout = QVBoxLayout(self)

        # è­¦å‘Šæç¤º
        warning = QLabel(
            "âš ï¸ æ‚¨æ­£åœ¨è¯·æ±‚è®¿é—®åŒ…å«æ•æ„Ÿä¿¡æ¯çš„å®Œæ•´ç‰ˆå›æ‰§ã€‚\n"
            "æ­¤æ“ä½œå°†è¢«è®°å½•åˆ°å®¡è®¡æ—¥å¿—ã€‚"
        )
        warning.setStyleSheet("color: orange; font-weight: bold;")
        layout.addWidget(warning)

        # æ–‡ä»¶é€‰æ‹©
        layout.addWidget(QLabel("é€‰æ‹©å›æ‰§æ–‡ä»¶:"))
        self.file_combo = QComboBox()
        self._load_available_files()
        layout.addWidget(self.file_combo)

        # è®¿é—®åŸå› 
        layout.addWidget(QLabel("è®¿é—®åŸå›  (å¿…å¡«):"))
        self.reason_edit = QLineEdit()
        self.reason_edit.setPlaceholderText("è¯·è¯´æ˜è®¿é—®åŸå› ï¼Œå°†è®°å½•åˆ°å®¡è®¡æ—¥å¿—")
        layout.addWidget(self.reason_edit)

        # å£ä»¤è¾“å…¥
        layout.addWidget(QLabel("è®¿é—®å£ä»¤:"))
        self.password_edit = QLineEdit()
        self.password_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(self.password_edit)

        # æŒ‰é’®
        btn_layout = QHBoxLayout()
        self.confirm_btn = QPushButton("ç¡®è®¤è®¿é—®")
        self.confirm_btn.clicked.connect(self._on_confirm)
        self.cancel_btn = QPushButton("å–æ¶ˆ")
        self.cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(self.confirm_btn)
        btn_layout.addWidget(self.cancel_btn)
        layout.addLayout(btn_layout)

    def _on_confirm(self):
        reason = self.reason_edit.text().strip()
        if not reason:
            QMessageBox.warning(self, "é”™è¯¯", "è¯·å¡«å†™è®¿é—®åŸå› ")
            return

        password = self.password_edit.text()
        file_name = self.file_combo.currentText()

        allowed, file_path, message = self.access_control.request_access(
            self.operator_id, password, file_name, reason
        )

        if allowed:
            QMessageBox.information(self, "è®¿é—®å·²æˆæƒ", f"æ–‡ä»¶è·¯å¾„: {file_path}")
            self.accept()
        else:
            QMessageBox.warning(self, "è®¿é—®è¢«æ‹’ç»", message)
```

**é…ç½®:**

```yaml
# config/receipt_access.yaml

receipt_access_control:
  # å®Œæ•´ç‰ˆå›æ‰§è®¿é—®å£ä»¤å“ˆå¸Œ (SHA256)
  # ç”Ÿæˆæ–¹å¼: python -c "import hashlib; print(hashlib.sha256(b'your_password').hexdigest())"
  full_receipt_password_hash: "5e884898da28047d9..."  # æ›¿æ¢ä¸ºå®é™…å“ˆå¸Œ

  # è®¿é—®å®¡è®¡
  audit:
    enabled: true
    log_file: "data/audit/receipt_access.jsonl"

  # å…è®¸è®¿é—®çš„è§’è‰²
  allowed_roles:
    - "admin"
    - "super"
```

---

## åä¸‰ã€UI é€‰æ‹©å™¨å¤–éƒ¨åŒ–

### 13.1 è®¾è®¡ç†å¿µ

å°† UI å…ƒç´ å®šä½ç¬¦ä»ä»£ç ä¸­æŠ½ç¦»åˆ°é…ç½®æ–‡ä»¶, å®ç°:
- å¾®ä¿¡æ›´æ–°æ—¶åªéœ€æ›´æ–°é…ç½®, æ— éœ€é‡æ–°ç¼–è¯‘
- æ”¯æŒå¤šç‰ˆæœ¬å¾®ä¿¡çš„é€‰æ‹©å™¨æ˜ å°„
- ä¾¿äºè°ƒè¯•å’Œç»´æŠ¤

### 13.2 é…ç½®æ–‡ä»¶ç»“æ„

```yaml
# selectors.yaml
#
# ä½¿ç”¨ YAML é”šç‚¹ (&) å’Œåˆ«å (*) å®ç°é…ç½®ç»§æ‰¿, å‡å°‘é‡å¤
# æ–°ç‰ˆæœ¬åªéœ€è¦†ç›–å˜åŒ–çš„é€‰æ‹©å™¨å³å¯

# å¾®ä¿¡ç‰ˆæœ¬æ˜ å°„
version_mapping:
  "3.9.10.27": "v3.9.10"
  "3.9.11.17": "v3.9.11"
  "3.9.12.15": "v3.9.12"
  "default": "v3.9.10"

# ============================================================
# åŸºç¡€é€‰æ‹©å™¨å®šä¹‰ (ä½œä¸ºé”šç‚¹ä¾›åç»­ç‰ˆæœ¬ç»§æ‰¿)
# ============================================================
selectors:
  # åŸºç¡€ç‰ˆæœ¬ (v3.9.10) - å®šä¹‰æ‰€æœ‰é”šç‚¹
  v3.9.10:
    main_window: &main_window_base
      class_name: "WeChatMainWndForPC"

    discover_tab: &discover_tab_base
      method: "name"           # name / class / automation_id / image
      value: "å‘ç°"

    moment_entry: &moment_entry_base
      method: "name"
      value: "æœ‹å‹åœˆ"

    camera_button: &camera_button_base
      method: "image"
      value: "templates/v3.9.10/camera_icon.png"
      confidence: 0.85

    text_input: &text_input_base
      method: "class"
      value: "Edit"
      index: 0

    publish_button: &publish_button_base
      method: "name"
      value: "å‘è¡¨"

    chat_title: &chat_title_base
      method: "automation_id"
      value: "ChatTitle"

    group_search: &group_search_base
      method: "name"
      value: "æœç´¢"

    message_input: &message_input_base
      method: "automation_id"
      value: "ChatInputBox"

    send_button: &send_button_base
      method: "name"
      value: "å‘é€"

    image_preview_container: &image_preview_base
      method: "automation_id"
      value: "ImagePreviewList"

  # ------------------------------------------------------------
  # v3.9.11 - ç»§æ‰¿ v3.9.10, åªè¦†ç›–å˜åŒ–çš„éƒ¨åˆ†
  # ------------------------------------------------------------
  v3.9.11:
    # ç»§æ‰¿æœªå˜åŒ–çš„é€‰æ‹©å™¨
    main_window: *main_window_base
    discover_tab: *discover_tab_base
    moment_entry: *moment_entry_base
    text_input: *text_input_base
    publish_button: *publish_button_base
    chat_title: *chat_title_base
    group_search: *group_search_base
    message_input: *message_input_base
    send_button: *send_button_base
    image_preview_container: *image_preview_base

    # è¦†ç›–å˜åŒ–çš„é€‰æ‹©å™¨
    camera_button:
      method: "image"
      value: "templates/v3.9.11/camera_icon.png"
      confidence: 0.85

  # ------------------------------------------------------------
  # v3.9.12 - ç»§æ‰¿ v3.9.10, ä½¿ç”¨åˆå¹¶é”®ç®€åŒ–
  # ------------------------------------------------------------
  v3.9.12:
    main_window: *main_window_base
    discover_tab: *discover_tab_base
    moment_entry: *moment_entry_base
    text_input: *text_input_base
    publish_button: *publish_button_base
    chat_title: *chat_title_base
    group_search: *group_search_base
    message_input: *message_input_base
    send_button: *send_button_base
    image_preview_container: *image_preview_base

    # è¦†ç›–å˜åŒ–çš„é€‰æ‹©å™¨
    camera_button:
      method: "image"
      value: "templates/v3.9.12/camera_icon.png"
      confidence: 0.9  # æ–°ç‰ˆæœ¬å›¾æ ‡æ›´æ¸…æ™°, æé«˜ç½®ä¿¡åº¦

    # æ–°å¢çš„é€‰æ‹©å™¨ (è¯¥ç‰ˆæœ¬ç‰¹æœ‰)
    quick_reply:
      method: "name"
      value: "å¿«æ·å›å¤"
```

### 13.2.1 é€‰æ‹©å™¨ç»§æ‰¿è¯´æ˜

| ç¬¦å· | å«ä¹‰ | ç¤ºä¾‹ |
|------|------|------|
| `&name` | å®šä¹‰é”šç‚¹ | `&camera_button_base` |
| `*name` | å¼•ç”¨é”šç‚¹ | `camera_button: *camera_button_base` |
| `<<: *name` | åˆå¹¶é”® (ç»§æ‰¿å¹¶å¯è¦†ç›–) | ç”¨äºå¯¹è±¡åˆå¹¶ |

**ä¼˜åŠ¿:**
- æ–°ç‰ˆæœ¬åªéœ€å®šä¹‰å˜åŒ–çš„é€‰æ‹©å™¨
- å‡å°‘é…ç½®æ–‡ä»¶å†—ä½™
- ä¾¿äºç»´æŠ¤å’Œå¯¹æ¯”å·®å¼‚

### 13.3 é€‰æ‹©å™¨åŠ è½½å™¨

```python
# core/element_locator.py

import yaml
import uiautomation as auto

# æ³¨æ„: ElementLocator å®Œæ•´å®ç°è§ä¸‹æ–¹ "SelectorManager ä¸ ElementLocator å®Œæ•´ä¸²è”" ç« èŠ‚
# ä½¿ç”¨æ³¨å…¥å¼è®¾è®¡ï¼Œç”± SelectorManager ç»Ÿä¸€ç®¡ç†ç‰ˆæœ¬æ£€æµ‹å’Œé…ç½®æ³¨å…¥

class ElementLocator:
    """
    å…ƒç´ å®šä½å™¨ - æ³¨å…¥å¼è®¾è®¡

    é‡è¦: æ­¤ç±»é‡‡ç”¨æ³¨å…¥å¼è®¾è®¡ï¼Œä¸åœ¨æ„é€ å‡½æ•°ä¸­è‡ªåŠ¨æ£€æµ‹ç‰ˆæœ¬ã€‚
    å®Œæ•´å®ç°è§ä¸‹æ–¹ "SelectorManager ä¸ ElementLocator å®Œæ•´ä¸²è”" ç« èŠ‚ã€‚

    ä½¿ç”¨æ–¹å¼:
        1. é€šè¿‡ SelectorManager.initialize() åˆå§‹åŒ–
        2. SelectorManager è´Ÿè´£ç‰ˆæœ¬æ£€æµ‹å¹¶è°ƒç”¨ inject_config()
        3. ä¹‹åæ‰èƒ½è°ƒç”¨ locate() æ–¹æ³•å®šä½å…ƒç´ 
    """

    def __init__(self):
        # ç©ºæ„é€ å‡½æ•°ï¼Œé…ç½®ç”± SelectorManager æ³¨å…¥
        self.wechat_version: Optional[str] = None
        self.selector_version: Optional[str] = None
        self.selectors: dict = {}
        self._initialized = False

    def inject_config(self, wechat_version: str, selector_version: str, selectors: dict):
        """æ³¨å…¥é…ç½® (ç”± SelectorManager è°ƒç”¨)"""
        self.wechat_version = wechat_version
        self.selector_version = selector_version
        self.selectors = selectors
        self._initialized = True

    def locate(self, element_name: str, timeout: float = 10.0):
        """å®šä½å…ƒç´  (éœ€å…ˆè°ƒç”¨ inject_config)"""
        if not self._initialized:
            raise RuntimeError("ElementLocator æœªåˆå§‹åŒ–")
        # å®Œæ•´å®šä½é€»è¾‘è§ä¸‹æ–¹ç« èŠ‚
        ...

    def _find_by_image(self, template_path: str, confidence: float):
        """å›¾åƒæ¨¡æ¿åŒ¹é…"""
        import pyautogui
        location = pyautogui.locateOnScreen(template_path, confidence=confidence)
        if location:
            return pyautogui.center(location)
        return None

    def reload(self, selectors: dict):
        """çƒ­é‡è½½é…ç½® (ç”± SelectorManager è°ƒç”¨)"""
        self.selectors = selectors
        logger.info("é€‰æ‹©å™¨é…ç½®å·²é‡æ–°åŠ è½½")
```

### 13.4 ç‰ˆæœ¬æ£€æµ‹ä¸å›é€€ç­–ç•¥

```python
# core/version_detector.py

import os
import re
import subprocess

class WeChatVersionDetector:
    """å¾®ä¿¡ç‰ˆæœ¬æ£€æµ‹å™¨"""

    WECHAT_EXE_PATHS = [
        r"C:\Program Files\Tencent\WeChat\WeChat.exe",
        r"C:\Program Files (x86)\Tencent\WeChat\WeChat.exe",
        os.path.expandvars(r"%APPDATA%\Tencent\WeChat\WeChat.exe"),
    ]

    def detect_version(self) -> str:
        """
        æ£€æµ‹å¾®ä¿¡ç‰ˆæœ¬
        ä¼˜å…ˆçº§: æ–‡ä»¶å±æ€§ > çª—å£æ ‡é¢˜ > æ³¨å†Œè¡¨ > é»˜è®¤å€¼
        """
        version = None

        # 1. å°è¯•ä»æ–‡ä»¶å±æ€§è·å–
        version = self._from_file_version()
        if version:
            logger.info(f"ä»æ–‡ä»¶å±æ€§æ£€æµ‹åˆ°ç‰ˆæœ¬: {version}")
            return version

        # 2. å°è¯•ä»çª—å£æ ‡é¢˜è·å–
        version = self._from_window_title()
        if version:
            logger.info(f"ä»çª—å£æ ‡é¢˜æ£€æµ‹åˆ°ç‰ˆæœ¬: {version}")
            return version

        # 3. å°è¯•ä»æ³¨å†Œè¡¨è·å–
        version = self._from_registry()
        if version:
            logger.info(f"ä»æ³¨å†Œè¡¨æ£€æµ‹åˆ°ç‰ˆæœ¬: {version}")
            return version

        # 4. è¿”å›é»˜è®¤å€¼
        logger.warning("æ— æ³•æ£€æµ‹å¾®ä¿¡ç‰ˆæœ¬, ä½¿ç”¨é»˜è®¤é…ç½®")
        return "default"

    def _from_file_version(self) -> str:
        """ä» WeChat.exe æ–‡ä»¶å±æ€§è·å–ç‰ˆæœ¬"""
        for path in self.WECHAT_EXE_PATHS:
            if os.path.exists(path):
                try:
                    import win32api
                    info = win32api.GetFileVersionInfo(path, "\\")
                    ms = info['FileVersionMS']
                    ls = info['FileVersionLS']
                    version = f"{ms >> 16}.{ms & 0xFFFF}.{ls >> 16}.{ls & 0xFFFF}"
                    return version
                except Exception as e:
                    logger.debug(f"ä»æ–‡ä»¶å±æ€§è·å–ç‰ˆæœ¬å¤±è´¥: {e}")
        return None

    def _from_window_title(self) -> str:
        """ä»çª—å£æ ‡é¢˜è·å–ç‰ˆæœ¬ (å¦‚: å¾®ä¿¡ 3.9.10)"""
        try:
            import uiautomation as auto
            win = auto.WindowControl(ClassName='WeChatMainWndForPC')
            if win.Exists(1):
                title = win.Name
                match = re.search(r'(\d+\.\d+\.\d+)', title)
                if match:
                    return match.group(1)
        except Exception as e:
            logger.debug(f"ä»çª—å£æ ‡é¢˜è·å–ç‰ˆæœ¬å¤±è´¥: {e}")
        return None

    def _from_registry(self) -> str:
        """ä»æ³¨å†Œè¡¨è·å–ç‰ˆæœ¬"""
        try:
            import winreg
            key = winreg.OpenKey(
                winreg.HKEY_CURRENT_USER,
                r"Software\Tencent\WeChat"
            )
            version, _ = winreg.QueryValueEx(key, "Version")
            winreg.CloseKey(key)
            return version
        except Exception as e:
            logger.debug(f"ä»æ³¨å†Œè¡¨è·å–ç‰ˆæœ¬å¤±è´¥: {e}")
        return None


def get_selector_version(wechat_version: str, version_mapping: dict) -> str:
    """
    æ ¹æ®å¾®ä¿¡ç‰ˆæœ¬è·å–é€‰æ‹©å™¨é…ç½®ç‰ˆæœ¬
    æ”¯æŒæ¨¡ç³ŠåŒ¹é…: 3.9.10.27 -> v3.9.10
    """
    # ç²¾ç¡®åŒ¹é…
    if wechat_version in version_mapping:
        return version_mapping[wechat_version]

    # å‰ç¼€åŒ¹é… (3.9.10.27 -> 3.9.10)
    if wechat_version and '.' in wechat_version:
        prefix = '.'.join(wechat_version.split('.')[:3])
        for key, value in version_mapping.items():
            if key.startswith(prefix):
                logger.info(f"ç‰ˆæœ¬æ¨¡ç³ŠåŒ¹é…: {wechat_version} -> {key} -> {value}")
                return value

    # è¿”å›é»˜è®¤
    return version_mapping.get('default', 'v3.9.10')
```

### 13.4.1 é€‰æ‹©å™¨è°ƒç”¨é“¾ä¸å›é€€å‘Šè­¦

```
å¯åŠ¨æµç¨‹:
+-----------------+     +---------------------+     +------------------+
| WeChatVersion   | --> | get_selector_version| --> | ElementLocator   |
| Detector        |     | (version_mapping)   |     | (load selectors) |
+-----------------+     +---------------------+     +------------------+
        |                        |                          |
        v                        v                          v
  æ£€æµ‹å¤±è´¥?               æœªæ‰¾åˆ°åŒ¹é…?                 é€‰æ‹©å™¨ç¼ºå¤±?
        |                        |                          |
        +----------+-------------+--------------------------+
                   |
                   v
          +------------------+
          | å›é€€ + å‘Šè­¦æµç¨‹  |
          +------------------+
```

```python
# core/selector_manager.py

from enum import Enum
from dataclasses import dataclass

class SelectorStatus(Enum):
    OK = "ok"                           # æ­£å¸¸åŒ¹é…
    FALLBACK_PREFIX = "fallback_prefix" # å‰ç¼€æ¨¡ç³ŠåŒ¹é…
    FALLBACK_DEFAULT = "fallback_default" # é™çº§åˆ°é»˜è®¤ç‰ˆæœ¬
    MISSING_TEMPLATE = "missing_template" # ç¼ºå°‘æ¨¡æ¿æ–‡ä»¶

@dataclass
class SelectorLoadResult:
    status: SelectorStatus
    wechat_version: str
    selector_version: str
    message: str
    missing_templates: list = None  # ç¼ºå¤±çš„æ¨¡æ¿æ–‡ä»¶åˆ—è¡¨


**å‘Šè­¦ç­–ç•¥:**

> **æ³¨æ„**: SelectorManager å®Œæ•´å®ç°è§ä¸‹æ–¹"é™çº§æ‰§è¡Œç­–ç•¥"ç« èŠ‚ä¸­çš„ä¿®æ­£ç‰ˆä»£ç ã€‚æ­¤å¤„ä»…åˆ—å‡ºå‘Šè­¦ç­–ç•¥è¡¨ã€‚

| çŠ¶æ€ | æ—¥å¿—çº§åˆ« | UI å¼¹çª— | é‚®ä»¶é€šçŸ¥ |
|------|----------|---------|----------|
| `OK` | INFO | å¦ | å¦ |
| `FALLBACK_PREFIX` | INFO | å¦ | å¦ |
| `FALLBACK_DEFAULT` | WARNING | æ˜¯ (å¯å¿½ç•¥) | å¯é€‰ |
| `MISSING_TEMPLATE` | ERROR | æ˜¯ (éœ€ç¡®è®¤) | æ˜¯ |

**é™çº§æ‰§è¡Œç­–ç•¥:**

å½“é€‰æ‹©å™¨å¤„äºå›é€€æˆ–ç¼ºå¤±çŠ¶æ€æ—¶ï¼Œéœ€è¦æ˜ç¡®çš„é™çº§æ‰§è¡Œç­–ç•¥ï¼š

```python
# core/degraded_execution.py

from enum import Enum
from dataclasses import dataclass
from typing import Optional, Callable

class DegradedMode(Enum):
    """é™çº§æ¨¡å¼"""
    FULL_FUNCTION = "full"           # å®Œæ•´åŠŸèƒ½
    GROUP_ONLY = "group_only"        # ä»…ç¾¤å‘ (ç¦ç”¨æœ‹å‹åœˆ)
    MANUAL_CONFIRM = "manual"        # æ¯æ¬¡éœ€æ‰‹åŠ¨ç¡®è®¤
    QUEUE_PAUSED = "paused"          # æš‚åœé˜Ÿåˆ—ç­‰å¾…ä¿®å¤

@dataclass
class DegradedConfig:
    """é™çº§é…ç½®"""
    on_fallback_default: DegradedMode = DegradedMode.MANUAL_CONFIRM
    on_missing_template: DegradedMode = DegradedMode.QUEUE_PAUSED
    on_fallback_prefix: DegradedMode = DegradedMode.FULL_FUNCTION

    # æ˜¯å¦è¦æ±‚æ˜¾å¼ç¡®è®¤
    require_explicit_confirm: bool = True
    # ç¡®è®¤è¶…æ—¶ (ç§’), è¶…æ—¶åˆ™æš‚åœ
    confirm_timeout: int = 300

class DegradedExecutionManager:
    """é™çº§æ‰§è¡Œç®¡ç†å™¨"""

    def __init__(self, config: DegradedConfig = None):
        self.config = config or DegradedConfig()
        self._confirmed_session = False  # æœ¬æ¬¡ä¼šè¯æ˜¯å¦å·²ç¡®è®¤
        self._confirmed_at: Optional[datetime] = None

    def determine_mode(self, selector_status: SelectorStatus) -> DegradedMode:
        """æ ¹æ®é€‰æ‹©å™¨çŠ¶æ€ç¡®å®šé™çº§æ¨¡å¼"""
        mapping = {
            SelectorStatus.OK: DegradedMode.FULL_FUNCTION,
            SelectorStatus.FALLBACK_PREFIX: self.config.on_fallback_prefix,
            SelectorStatus.FALLBACK_DEFAULT: self.config.on_fallback_default,
            SelectorStatus.MISSING_TEMPLATE: self.config.on_missing_template,
        }
        return mapping.get(selector_status, DegradedMode.QUEUE_PAUSED)

    def can_execute_task(self, task: Task, selector_status: SelectorStatus) -> tuple[bool, str]:
        """
        åˆ¤æ–­ä»»åŠ¡æ˜¯å¦å¯æ‰§è¡Œ

        Returns:
            (can_execute, reason)
        """
        mode = self.determine_mode(selector_status)

        if mode == DegradedMode.FULL_FUNCTION:
            return True, ""

        elif mode == DegradedMode.QUEUE_PAUSED:
            return False, "é€‰æ‹©å™¨å¼‚å¸¸ï¼Œé˜Ÿåˆ—å·²æš‚åœã€‚è¯·æ›´æ–°æ¨¡æ¿åŒ…æˆ–è”ç³»å¼€å‘è€…ã€‚"

        elif mode == DegradedMode.GROUP_ONLY:
            if task.channel == Channel.MOMENT:
                return False, "å½“å‰é™çº§æ¨¡å¼ç¦ç”¨æœ‹å‹åœˆå‘å¸ƒï¼Œä»…æ”¯æŒç¾¤å‘ã€‚"
            return True, ""

        elif mode == DegradedMode.MANUAL_CONFIRM:
            if not self._is_confirmed():
                return False, "é™çº§æ¨¡å¼éœ€è¦æ‰‹åŠ¨ç¡®è®¤åæ‰èƒ½ç»§ç»­æ‰§è¡Œã€‚"
            return True, ""

        return False, "æœªçŸ¥é™çº§æ¨¡å¼"

    def _is_confirmed(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦åœ¨æœ‰æ•ˆç¡®è®¤æœŸå†…"""
        if not self._confirmed_session:
            return False
        if self._confirmed_at is None:
            return False
        # æ£€æŸ¥æ˜¯å¦è¶…æ—¶
        elapsed = (datetime.now() - self._confirmed_at).total_seconds()
        return elapsed < self.config.confirm_timeout

    def request_confirm(self, selector_result: SelectorLoadResult,
                        callback: Callable[[bool], None]):
        """
        è¯·æ±‚ç”¨æˆ·ç¡®è®¤é™çº§æ‰§è¡Œ

        æ˜¾ç¤ºå¯¹è¯æ¡†ï¼Œè¯´æ˜å½“å‰çŠ¶æ€å’Œé£é™©
        """
        from PySide6.QtWidgets import QMessageBox, QCheckBox

        mode = self.determine_mode(selector_result.status)

        msg = QMessageBox()
        msg.setIcon(QMessageBox.Warning)
        msg.setWindowTitle("é™çº§æ‰§è¡Œç¡®è®¤")
        msg.setText(f"æ£€æµ‹åˆ°é€‰æ‹©å™¨å¼‚å¸¸:\n\n{selector_result.message}")

        detail = self._get_mode_description(mode)
        msg.setInformativeText(f"å½“å‰å°†ä»¥ã€Œ{detail}ã€æ¨¡å¼è¿è¡Œã€‚\n\n"
                               f"ç¡®è®¤å {self.config.confirm_timeout // 60} åˆ†é’Ÿå†…æ— éœ€å†æ¬¡ç¡®è®¤ã€‚")

        msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        msg.setDefaultButton(QMessageBox.No)

        result = msg.exec()

        if result == QMessageBox.Yes:
            self._confirmed_session = True
            self._confirmed_at = datetime.now()
            logger.info(f"ç”¨æˆ·ç¡®è®¤é™çº§æ‰§è¡Œ, æ¨¡å¼: {mode.value}")
            callback(True)
        else:
            logger.info("ç”¨æˆ·æ‹’ç»é™çº§æ‰§è¡Œ")
            callback(False)

    def _get_mode_description(self, mode: DegradedMode) -> str:
        """è·å–æ¨¡å¼æè¿°"""
        descriptions = {
            DegradedMode.FULL_FUNCTION: "å®Œæ•´åŠŸèƒ½",
            DegradedMode.GROUP_ONLY: "ä»…ç¾¤å‘ - æœ‹å‹åœˆå‘å¸ƒå·²ç¦ç”¨",
            DegradedMode.MANUAL_CONFIRM: "æ‰‹åŠ¨ç¡®è®¤ - æ¯æ¬¡ä¼šè¯éœ€ç¡®è®¤",
            DegradedMode.QUEUE_PAUSED: "é˜Ÿåˆ—æš‚åœ - ç­‰å¾…é—®é¢˜ä¿®å¤",
        }
        return descriptions.get(mode, "æœªçŸ¥")
```

**SelectorManager ä¸ ElementLocator å®Œæ•´ä¸²è”:**

```python
# core/element_locator.py (ä¿®æ­£ç‰ˆ)

class ElementLocator:
    """å…ƒç´ å®šä½å™¨ - æ¥æ”¶å¤–éƒ¨æ³¨å…¥çš„ç‰ˆæœ¬å’Œé€‰æ‹©å™¨é…ç½®"""

    def __init__(self):
        # ä¸åœ¨æ„é€ å‡½æ•°ä¸­è‡ªåŠ¨æ£€æµ‹ï¼Œç”± SelectorManager æ³¨å…¥
        self.wechat_version: Optional[str] = None
        self.selector_version: Optional[str] = None
        self.selectors: dict = {}
        self._initialized = False

    def inject_config(self, wechat_version: str, selector_version: str, selectors: dict):
        """
        æ³¨å…¥é…ç½® (ç”± SelectorManager è°ƒç”¨)

        Args:
            wechat_version: æ£€æµ‹åˆ°çš„å¾®ä¿¡ç‰ˆæœ¬
            selector_version: ä½¿ç”¨çš„é€‰æ‹©å™¨ç‰ˆæœ¬
            selectors: é€‰æ‹©å™¨é…ç½®å­—å…¸
        """
        self.wechat_version = wechat_version
        self.selector_version = selector_version
        self.selectors = selectors
        self._initialized = True
        logger.info(f"ElementLocator é…ç½®æ³¨å…¥å®Œæˆ: å¾®ä¿¡ {wechat_version} -> é€‰æ‹©å™¨ {selector_version}")

    def locate(self, element_name: str, timeout: float = 10.0):
        """å®šä½å…ƒç´ """
        if not self._initialized:
            raise RuntimeError("ElementLocator æœªåˆå§‹åŒ–ï¼Œè¯·å…ˆè°ƒç”¨ SelectorManager.initialize()")

        selector = self.selectors.get(element_name)
        if not selector:
            raise KeyError(f"æœªæ‰¾åˆ°é€‰æ‹©å™¨é…ç½®: {element_name}")

        # ... å®šä½é€»è¾‘
```

```python
# core/selector_manager.py (ä¿®æ­£ç‰ˆ)

class SelectorManager:
    """é€‰æ‹©å™¨ç®¡ç†å™¨ - æ­£ç¡®ä¸²è”ç‰ˆæœ¬æ£€æµ‹ä¸å…ƒç´ å®šä½"""

    def __init__(self, config_path: str = "selectors.yaml"):
        self.config_path = config_path
        self.version_detector = WeChatVersionDetector()
        self.locator = ElementLocator()  # åˆ›å»ºç©ºçš„å®šä½å™¨
        self.degraded_manager = DegradedExecutionManager()
        self.load_result: Optional[SelectorLoadResult] = None

    def initialize(self) -> SelectorLoadResult:
        """
        åˆå§‹åŒ–é€‰æ‹©å™¨ (å®Œæ•´è°ƒç”¨é“¾)

        è°ƒç”¨é“¾:
        1. WeChatVersionDetector.detect_version() -> wechat_version
        2. ä» config æ˜ å°„ -> selector_version
        3. åŠ è½½é€‰æ‹©å™¨é…ç½® -> selectors dict
        4. ElementLocator.inject_config() -> æ³¨å…¥é…ç½®
        5. éªŒè¯æ¨¡æ¿æ–‡ä»¶
        6. ç¡®å®šé™çº§æ¨¡å¼
        """
        # 1. æ£€æµ‹å¾®ä¿¡ç‰ˆæœ¬ (å¤šç­–ç•¥)
        wechat_version = self.version_detector.detect_version()
        logger.info(f"æ£€æµ‹åˆ°å¾®ä¿¡ç‰ˆæœ¬: {wechat_version}")

        # 2. åŠ è½½é…ç½®æ–‡ä»¶
        with open(self.config_path, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)

        # 3. æ˜ å°„åˆ°é€‰æ‹©å™¨ç‰ˆæœ¬
        version_mapping = config.get('version_mapping', {})
        selector_version = self._map_selector_version(wechat_version, version_mapping)
        logger.info(f"æ˜ å°„åˆ°é€‰æ‹©å™¨ç‰ˆæœ¬: {selector_version}")

        # 4. åŠ è½½é€‰æ‹©å™¨é…ç½®
        selectors = config['selectors'].get(selector_version, {})

        # 5. æ³¨å…¥é…ç½®åˆ° ElementLocator
        self.locator.inject_config(
            wechat_version=wechat_version,
            selector_version=selector_version,
            selectors=selectors
        )

        # 6. åˆ¤æ–­å›é€€çŠ¶æ€
        status = self._determine_status(wechat_version, selector_version, version_mapping)

        # 7. éªŒè¯æ¨¡æ¿æ–‡ä»¶
        missing_templates = self._verify_templates(selectors, selector_version)
        if missing_templates:
            status = SelectorStatus.MISSING_TEMPLATE

        # 8. æ„å»ºç»“æœ
        message = self._build_status_message(status, wechat_version, selector_version, missing_templates)
        self.load_result = SelectorLoadResult(
            status=status,
            wechat_version=wechat_version,
            selector_version=selector_version,
            message=message,
            missing_templates=missing_templates
        )

        # 9. å¤„ç†å‘Šè­¦å’Œé™çº§
        self._handle_alert(self.load_result)

        return self.load_result

    def _map_selector_version(self, wechat_version: str, mapping: dict) -> str:
        """æ˜ å°„å¾®ä¿¡ç‰ˆæœ¬åˆ°é€‰æ‹©å™¨ç‰ˆæœ¬"""
        # ç²¾ç¡®åŒ¹é…
        if wechat_version in mapping:
            return mapping[wechat_version]

        # å‰ç¼€åŒ¹é… (3.9.10.x -> 3.9.10)
        if '.' in wechat_version:
            prefix = '.'.join(wechat_version.split('.')[:3])
            if prefix in mapping:
                return mapping[prefix]

        # é»˜è®¤
        return mapping.get('default', 'v3.9.10')

    def _determine_status(self, wechat_ver: str, selector_ver: str, mapping: dict) -> SelectorStatus:
        """ç¡®å®šé€‰æ‹©å™¨çŠ¶æ€"""
        if wechat_ver == "default" or wechat_ver == "unknown":
            return SelectorStatus.FALLBACK_DEFAULT

        if wechat_ver in mapping:
            return SelectorStatus.OK

        # å‰ç¼€åŒ¹é…æˆåŠŸ
        prefix = '.'.join(wechat_ver.split('.')[:3]) if '.' in wechat_ver else wechat_ver
        if prefix in mapping:
            return SelectorStatus.FALLBACK_PREFIX

        return SelectorStatus.FALLBACK_DEFAULT

    def get_locator(self) -> ElementLocator:
        """è·å–å·²åˆå§‹åŒ–çš„å®šä½å™¨"""
        if not self.load_result:
            raise RuntimeError("è¯·å…ˆè°ƒç”¨ initialize()")
        return self.locator

    def get_degraded_mode(self) -> DegradedMode:
        """è·å–å½“å‰é™çº§æ¨¡å¼"""
        if not self.load_result:
            return DegradedMode.QUEUE_PAUSED
        return self.degraded_manager.determine_mode(self.load_result.status)
```

### 13.4.2 é€‰æ‹©å™¨ä¸æ¨¡æ¿åŒ…å‡çº§/å›æ»šæµç¨‹

#### æ¨¡æ¿åŒ…ç»“æ„

```
templates/
|-- manifest.json           # ç‰ˆæœ¬æ¸…å•
|-- v3.9.10/
|   |-- selectors.yaml      # é€‰æ‹©å™¨é…ç½®
|   +-- images/             # æˆªå›¾æ¨¡æ¿
|-- v3.9.11/
|   +-- ...
+-- backup/                 # å›æ»šå¤‡ä»½
    |-- v3.9.10_20241125/
    +-- v3.9.11_20241125/
```

#### manifest.json æ ¼å¼

```json
{
  "version": "1.2.0",
  "released_at": "2024-11-25T10:00:00+08:00",
  "signature": "sha256:abc123...",
  "supported_wechat_versions": ["3.9.10", "3.9.11", "3.9.12"],
  "changelog": [
    "æ–°å¢ v3.9.12 é€‰æ‹©å™¨",
    "ä¿®å¤æœ‹å‹åœˆç›¸æœºæŒ‰é’®å®šä½"
  ],
  "files": [
    {"path": "v3.9.10/selectors.yaml", "hash": "sha256:..."},
    {"path": "v3.9.10/images/camera_icon.png", "hash": "sha256:..."}
  ]
}
```

#### å‡çº§æµç¨‹

```python
# core/template_updater.py

import hashlib
import shutil
import json
import ssl
import certifi
from datetime import datetime
from urllib.parse import urlparse
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.exceptions import InvalidSignature

class UpdateSecurityError(Exception):
    """æ›´æ–°å®‰å…¨é”™è¯¯"""
    pass

class TemplateUpdater:
    """æ¨¡æ¿åŒ…å‡çº§å™¨ (å¸¦å®‰å…¨éªŒè¯)"""

    # å†…ç½®å…¬é’¥æŒ‡çº¹ (SHA256)
    TRUSTED_PUBLIC_KEY_FINGERPRINT = "sha256:abc123def456..."  # å®é™…éƒ¨ç½²æ—¶æ›¿æ¢

    def __init__(self, templates_dir: str = "templates", config: dict = None):
        self.templates_dir = templates_dir
        self.backup_dir = os.path.join(templates_dir, "backup")
        self.manifest_path = os.path.join(templates_dir, "manifest.json")
        self.public_key_path = os.path.join(templates_dir, "public_key.pem")

        # é…ç½® (å«å®‰å…¨ç­–ç•¥)
        self.config = config or {}

        # å¼ºåˆ¶ HTTPS é…ç½®
        self._session = requests.Session()
        self._session.verify = certifi.where()  # ä½¿ç”¨ certifi è¯ä¹¦åŒ…

    def _validate_url(self, url: str) -> bool:
        """
        éªŒè¯ URL å®‰å…¨æ€§

        å¼ºåˆ¶è¦æ±‚:
        1. å¿…é¡»æ˜¯ HTTPS
        2. åŸŸåç™½åå• (strict_domain_whitelist æ§åˆ¶æ˜¯å¦å¼ºåˆ¶)
        """
        parsed = urlparse(url)

        # å¼ºåˆ¶ HTTPS
        if parsed.scheme != "https":
            raise UpdateSecurityError(f"æ‹’ç»ä¸å®‰å…¨çš„ HTTP è¿æ¥: {url}")

        # åŸŸåç™½åå•æ£€æŸ¥
        allowed_domains = self.config.get('allowed_domains', [
            "releases.wechat-tool.example.com",
            "github.com",
            "raw.githubusercontent.com",
        ])

        if allowed_domains and parsed.netloc not in allowed_domains:
            # ä¸¥æ ¼æ¨¡å¼ (ç”Ÿäº§ç¯å¢ƒé»˜è®¤å¼€å¯)
            if self.config.get('strict_domain_whitelist', True):
                raise UpdateSecurityError(f"æ›´æ–°æº {parsed.netloc} ä¸åœ¨ç™½åå•ä¸­")
            else:
                logger.warning(f"æ›´æ–°æº {parsed.netloc} ä¸åœ¨ç™½åå•ä¸­ (éä¸¥æ ¼æ¨¡å¼ï¼Œå…è®¸ç»§ç»­)")

        return True

    def _verify_signature(self, manifest: dict) -> bool:
        """
        éªŒè¯ manifest ç­¾å

        ç­¾åæ ¼å¼: Ed25519 æˆ– RSA-PSS
        éªŒè¯æµç¨‹:
        1. æå–ç­¾åå­—æ®µ
        2. é‡å»ºå¾…ç­¾åæ•°æ®
        3. ä½¿ç”¨å…¬é’¥éªŒè¯
        4. éªŒè¯å…¬é’¥æŒ‡çº¹
        """
        signature_b64 = manifest.get('signature')
        if not signature_b64:
            raise UpdateSecurityError("manifest ç¼ºå°‘ç­¾åå­—æ®µ")

        # ç§»é™¤ç­¾åå­—æ®µ, é‡å»ºå¾…ç­¾åæ•°æ®
        manifest_copy = {k: v for k, v in manifest.items() if k != 'signature'}
        data_to_verify = json.dumps(manifest_copy, sort_keys=True, ensure_ascii=False).encode('utf-8')

        try:
            import base64
            signature = base64.b64decode(signature_b64)

            # åŠ è½½å…¬é’¥
            with open(self.public_key_path, 'rb') as f:
                public_key = serialization.load_pem_public_key(f.read())

            # éªŒè¯å…¬é’¥æŒ‡çº¹
            key_fingerprint = self._get_key_fingerprint(public_key)
            if key_fingerprint != self.TRUSTED_PUBLIC_KEY_FINGERPRINT:
                raise UpdateSecurityError(f"å…¬é’¥æŒ‡çº¹ä¸åŒ¹é…: {key_fingerprint}")

            # RSA-PSS éªŒè¯
            public_key.verify(
                signature,
                data_to_verify,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )

            logger.info("ç­¾åéªŒè¯é€šè¿‡")
            return True

        except InvalidSignature:
            raise UpdateSecurityError("ç­¾åéªŒè¯å¤±è´¥: ç­¾åæ— æ•ˆ")
        except FileNotFoundError:
            raise UpdateSecurityError(f"å…¬é’¥æ–‡ä»¶ä¸å­˜åœ¨: {self.public_key_path}")
        except Exception as e:
            raise UpdateSecurityError(f"ç­¾åéªŒè¯å¼‚å¸¸: {e}")

    def _get_key_fingerprint(self, public_key) -> str:
        """è®¡ç®—å…¬é’¥æŒ‡çº¹"""
        key_bytes = public_key.public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        fingerprint = hashlib.sha256(key_bytes).hexdigest()
        return f"sha256:{fingerprint}"

    def check_update(self, update_url: str) -> dict:
        """
        æ£€æŸ¥æ›´æ–° (å¸¦å®‰å…¨éªŒè¯)

        Returns:
            {'available': bool, 'current': str, 'latest': str, 'changelog': list, 'error': str}
        """
        current = self._get_current_version()

        try:
            # éªŒè¯ URL å®‰å…¨æ€§
            self._validate_url(update_url)

            # ä½¿ç”¨å®‰å…¨ä¼šè¯
            response = self._session.get(f"{update_url}/manifest.json", timeout=10)
            response.raise_for_status()
            latest_manifest = response.json()

            # é¢„éªŒè¯ç­¾å (ä»…æ£€æŸ¥æ˜¯å¦å­˜åœ¨)
            if 'signature' not in latest_manifest:
                logger.warning("è¿œç¨‹ manifest ç¼ºå°‘ç­¾å, å¯èƒ½æ˜¯ä¸å®‰å…¨çš„æº")

            latest = latest_manifest.get('version', '0.0.0')

            return {
                'available': self._version_compare(latest, current) > 0,
                'current': current,
                'latest': latest,
                'changelog': latest_manifest.get('changelog', []),
                'signed': 'signature' in latest_manifest
            }
        except UpdateSecurityError as e:
            logger.error(f"å®‰å…¨æ£€æŸ¥å¤±è´¥: {e}")
            return {'available': False, 'current': current, 'latest': None, 'error': str(e)}
        except Exception as e:
            logger.error(f"æ£€æŸ¥æ›´æ–°å¤±è´¥: {e}")
            return {'available': False, 'current': current, 'latest': None, 'error': str(e)}

    def upgrade(self, update_url: str, backup: bool = True) -> bool:
        """
        æ‰§è¡Œå‡çº§ (å¸¦å®Œæ•´å®‰å…¨éªŒè¯)

        å®‰å…¨æªæ–½:
        1. å¼ºåˆ¶ HTTPS
        2. è¯ä¹¦éªŒè¯ (ä½¿ç”¨ certifi)
        3. ç­¾åéªŒè¯ (RSA-PSS + SHA256)
        4. å…¬é’¥æŒ‡çº¹æ ¡éªŒ
        5. æ–‡ä»¶å“ˆå¸Œæ ¡éªŒ

        Args:
            update_url: æ›´æ–°æœåŠ¡å™¨åœ°å€ (å¿…é¡» HTTPS)
            backup: æ˜¯å¦å¤‡ä»½å½“å‰ç‰ˆæœ¬
        """
        try:
            # 0. éªŒè¯ URL å®‰å…¨æ€§
            self._validate_url(update_url)

            # 1. ä¸‹è½½æ–° manifest (HTTPS)
            response = self._session.get(f"{update_url}/manifest.json", timeout=30)
            response.raise_for_status()
            new_manifest = response.json()

            # 2. éªŒè¯ç­¾å (å¼ºåˆ¶)
            self._verify_signature(new_manifest)

            # 3. å¤‡ä»½å½“å‰ç‰ˆæœ¬
            if backup:
                self._backup_current()

            # 4. ä¸‹è½½å¹¶æ ¡éªŒæ–‡ä»¶
            for file_info in new_manifest.get('files', []):
                file_path = file_info['path']
                expected_hash = file_info['hash']

                # ä¸‹è½½æ–‡ä»¶ (HTTPS)
                file_url = f"{update_url}/{file_path}"
                self._validate_url(file_url)
                file_response = self._session.get(file_url, timeout=30)
                file_response.raise_for_status()
                file_content = file_response.content

                # æ ¡éªŒå“ˆå¸Œ
                actual_hash = f"sha256:{hashlib.sha256(file_content).hexdigest()}"
                if actual_hash != expected_hash:
                    raise UpdateSecurityError(f"æ–‡ä»¶æ ¡éªŒå¤±è´¥: {file_path}, æœŸæœ› {expected_hash}, å®é™… {actual_hash}")

                # å†™å…¥æ–‡ä»¶
                full_path = os.path.join(self.templates_dir, file_path)
                os.makedirs(os.path.dirname(full_path), exist_ok=True)
                with open(full_path, 'wb') as f:
                    f.write(file_content)

            # 5. æ›´æ–° manifest
            with open(self.manifest_path, 'w', encoding='utf-8') as f:
                json.dump(new_manifest, f, indent=2, ensure_ascii=False)

            logger.info(f"æ¨¡æ¿åŒ…å‡çº§æˆåŠŸ: {new_manifest.get('version')}")
            return True

        except UpdateSecurityError as e:
            logger.error(f"å®‰å…¨éªŒè¯å¤±è´¥, å‡çº§ä¸­æ­¢: {e}")
            raise  # å®‰å…¨é”™è¯¯ä¸é™é»˜å¤„ç†
        except Exception as e:
            logger.error(f"å‡çº§å¤±è´¥: {e}")
            # å°è¯•å›æ»š
            self._rollback_latest()
            return False

    def rollback(self, version: str = None) -> bool:
        """
        å›æ»šåˆ°æŒ‡å®šç‰ˆæœ¬

        Args:
            version: ç›®æ ‡ç‰ˆæœ¬, None åˆ™å›æ»šåˆ°ä¸Šä¸€ç‰ˆæœ¬
        """
        try:
            if version:
                backup_path = self._find_backup(version)
            else:
                backup_path = self._get_latest_backup()

            if not backup_path:
                logger.error("æœªæ‰¾åˆ°å¯ç”¨çš„å¤‡ä»½")
                return False

            # æ¢å¤å¤‡ä»½
            for item in os.listdir(backup_path):
                src = os.path.join(backup_path, item)
                dst = os.path.join(self.templates_dir, item)

                if os.path.isdir(src):
                    if os.path.exists(dst):
                        shutil.rmtree(dst)
                    shutil.copytree(src, dst)
                else:
                    shutil.copy2(src, dst)

            logger.info(f"å·²å›æ»šåˆ°å¤‡ä»½: {backup_path}")
            return True

        except Exception as e:
            logger.error(f"å›æ»šå¤±è´¥: {e}")
            return False

    def _backup_current(self):
        """å¤‡ä»½å½“å‰ç‰ˆæœ¬"""
        current_version = self._get_current_version()
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        backup_name = f"{current_version}_{timestamp}"
        backup_path = os.path.join(self.backup_dir, backup_name)

        os.makedirs(backup_path, exist_ok=True)

        # å¤åˆ¶éœ€è¦å¤‡ä»½çš„ç›®å½•
        for version_dir in os.listdir(self.templates_dir):
            if version_dir.startswith('v') and os.path.isdir(os.path.join(self.templates_dir, version_dir)):
                shutil.copytree(
                    os.path.join(self.templates_dir, version_dir),
                    os.path.join(backup_path, version_dir)
                )

        # å¤åˆ¶ manifest
        if os.path.exists(self.manifest_path):
            shutil.copy2(self.manifest_path, backup_path)

        logger.info(f"å·²å¤‡ä»½å½“å‰ç‰ˆæœ¬åˆ°: {backup_path}")

    def _get_current_version(self) -> str:
        """è·å–å½“å‰ç‰ˆæœ¬"""
        if os.path.exists(self.manifest_path):
            with open(self.manifest_path, 'r', encoding='utf-8') as f:
                manifest = json.load(f)
                return manifest.get('version', '0.0.0')
        return '0.0.0'

    def _version_compare(self, v1: str, v2: str) -> int:
        """æ¯”è¾ƒç‰ˆæœ¬å·, è¿”å› 1(v1>v2), 0(ç›¸ç­‰), -1(v1<v2)"""
        parts1 = [int(x) for x in v1.split('.')]
        parts2 = [int(x) for x in v2.split('.')]

        for p1, p2 in zip(parts1, parts2):
            if p1 > p2:
                return 1
            elif p1 < p2:
                return -1
        return 0
```

#### é…ç½®ä¸ UI

```yaml
# config.yaml
template_update:
  # æ›´æ–°æ£€æŸ¥
  auto_check: true              # è‡ªåŠ¨æ£€æŸ¥æ›´æ–°
  check_interval_hours: 24      # æ£€æŸ¥é—´éš” (å°æ—¶)
  update_url: "https://example.com/wechat-templates"

  # æ›´æ–°ç­–ç•¥
  auto_upgrade: false           # è‡ªåŠ¨å‡çº§ (å»ºè®®å…³é—­)
  auto_backup: true             # å‡çº§å‰è‡ªåŠ¨å¤‡ä»½
  max_backups: 5                # æœ€å¤§å¤‡ä»½æ•°é‡

  # ç­¾åéªŒè¯
  verify_signature: true        # éªŒè¯ç­¾å
  public_key_path: "keys/template_pub.pem"

  # å®‰å…¨ç­–ç•¥
  strict_domain_whitelist: true # ä¸¥æ ¼åŸŸåç™½åå• (ç”Ÿäº§ç¯å¢ƒå¿…é¡»ä¸º true)
  allowed_domains:              # å…è®¸çš„æ›´æ–°æºåŸŸå
    - "releases.wechat-tool.example.com"
    - "github.com"
    - "raw.githubusercontent.com"
```

**strict_domain_whitelist ç­–ç•¥:**

| ç¯å¢ƒ | é»˜è®¤å€¼ | è¡Œä¸º |
|------|--------|------|
| ç”Ÿäº§ | `true` (å¼ºåˆ¶) | éç™½åå•åŸŸåç›´æ¥æ‹’ç» |
| æµ‹è¯• | `true` (æ¨è) | éç™½åå•åŸŸåç›´æ¥æ‹’ç» |
| å¼€å‘ | `false` (å¯é€‰) | éç™½åå•åŸŸåä»…è­¦å‘Š |

#### 13.4.4 æ¨¡æ¿ç­¾åè¿ç»´æµç¨‹

> **æ ¸å¿ƒåŸåˆ™**: ç­¾åå¯†é’¥æ˜¯æ¨¡æ¿å®‰å…¨çš„æ ¹åŸºï¼Œå¿…é¡»æœ‰å®Œæ•´çš„å¯†é’¥ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€å›æ»šå’Œç¦»çº¿ä¿®å¤æµç¨‹ã€‚

##### å¯†é’¥ç”Ÿå‘½å‘¨æœŸç®¡ç†

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å¯†é’¥ç”Ÿå‘½å‘¨æœŸ (Key Lifecycle)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚  [ç”Ÿæˆ] â”€â”€â–º [åˆ†å‘] â”€â”€â–º [ä½¿ç”¨] â”€â”€â–º [è½®æ¢] â”€â”€â–º [å½’æ¡£/é”€æ¯]              â”‚
â”‚                                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ å¯†é’¥ç”Ÿæˆ (ç¦»çº¿ç¯å¢ƒ)                                              â”‚  â”‚
â”‚  â”‚ $ openssl genrsa -out template_priv.pem 4096                   â”‚  â”‚
â”‚  â”‚ $ openssl rsa -in template_priv.pem -pubout -out template_pub.pem â”‚
â”‚  â”‚ $ openssl dgst -sha256 -binary template_pub.pem | xxd -p      â”‚  â”‚
â”‚  â”‚ # è®°å½•å…¬é’¥æŒ‡çº¹: sha256:abc123...                                 â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ å¯†é’¥åˆ†å‘                                                        â”‚  â”‚
â”‚  â”‚ â€¢ ç§é’¥: ä»…å­˜äºæ„å»ºæœåŠ¡å™¨ (HSM æˆ–åŠ å¯†å­˜å‚¨)                         â”‚  â”‚
â”‚  â”‚ â€¢ å…¬é’¥: å†…åµŒäºå®¢æˆ·ç«¯ keys/template_pub.pem                       â”‚  â”‚
â”‚  â”‚ â€¢ æŒ‡çº¹: ç¡¬ç¼–ç äºä»£ç  TRUSTED_PUBLIC_KEY_FINGERPRINT              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

##### å¯†é’¥è½®æ¢æµç¨‹

| é˜¶æ®µ | æ“ä½œ | è´Ÿè´£äºº | éªŒè¯ç‚¹ |
|------|------|--------|--------|
| 1. å‡†å¤‡ | åœ¨ç¦»çº¿ç¯å¢ƒç”Ÿæˆæ–°å¯†é’¥å¯¹ | å®‰å…¨ç®¡ç†å‘˜ | ç§é’¥ä¸å‡ºç¦»çº¿ç¯å¢ƒ |
| 2. åŒç­¾ | æ–°æ—§å¯†é’¥åŒæ—¶ç­¾åæ¨¡æ¿åŒ… (è¿‡æ¸¡æœŸ) | æ„å»ºç³»ç»Ÿ | ä¸¤ä¸ªç­¾åéƒ½æœ‰æ•ˆ |
| 3. æ¨é€ | å‘å¸ƒæ–°ç‰ˆå®¢æˆ·ç«¯ (å†…åµŒæ–°å…¬é’¥+åŒæŒ‡çº¹) | å‘å¸ƒç®¡ç†å‘˜ | å®¢æˆ·ç«¯ç‰ˆæœ¬ â‰¥ N |
| 4. åˆ‡æ¢ | æ¨¡æ¿åŒ…ä»…ä½¿ç”¨æ–°å¯†é’¥ç­¾å | æ„å»ºç³»ç»Ÿ | æ—§å®¢æˆ·ç«¯æŠ¥é”™ä½†ä¸å´©æºƒ |
| 5. å½’æ¡£ | æ—§ç§é’¥å®‰å…¨å½’æ¡£ (ç”¨äºç´§æ€¥å›æ»š) | å®‰å…¨ç®¡ç†å‘˜ | åŠ å¯†å­˜å‚¨ + è®¿é—®å®¡è®¡ |

##### å…¬é’¥å›æ»šæµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å…¬é’¥ç´§æ€¥å›æ»šæµç¨‹                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  [è§¦å‘æ¡ä»¶] æ–°å¯†é’¥æ³„éœ² / ç­¾åç®—æ³•æ¼æ´ / ç´§æ€¥å®‰å…¨äº‹ä»¶                    â”‚
â”‚                                                                     â”‚
â”‚  æ­¥éª¤ 1: åœæ­¢æ¨¡æ¿åˆ†å‘                                                â”‚
â”‚  â”œâ”€â”€ æ›´æ–°æœåŠ¡å™¨ä¸‹çº¿æˆ–è¿”å›ç©º manifest                                  â”‚
â”‚  â””â”€â”€ é€šçŸ¥æ‰€æœ‰å®¢æˆ·ç«¯æš‚åœè‡ªåŠ¨æ›´æ–°                                       â”‚
â”‚                                                                     â”‚
â”‚  æ­¥éª¤ 2: å‡†å¤‡å›æ»šåŒ…                                                  â”‚
â”‚  â”œâ”€â”€ ä½¿ç”¨å½’æ¡£çš„æ—§ç§é’¥ç­¾åå½“å‰æ¨¡æ¿                                     â”‚
â”‚  â”œâ”€â”€ ç”Ÿæˆ rollback_manifest.json (å« emergency_rollback æ ‡è®°)       â”‚
â”‚  â””â”€â”€ éªŒè¯ç­¾å: æ—§å…¬é’¥ + æ—§æŒ‡çº¹                                       â”‚
â”‚                                                                     â”‚
â”‚  æ­¥éª¤ 3: å®¢æˆ·ç«¯å¼ºåˆ¶å›æ»š                                              â”‚
â”‚  â”œâ”€â”€ å‘å¸ƒç´§æ€¥æ›´æ–° (å†…åµŒæ—§å…¬é’¥)                                        â”‚
â”‚  â”œâ”€â”€ æˆ–: ç”¨æˆ·æ‰‹åŠ¨æ›¿æ¢ keys/template_pub.pem                         â”‚
â”‚  â””â”€â”€ æˆ–: è¿œç¨‹é…ç½®æ¨é€æ–°çš„ä¿¡ä»»æŒ‡çº¹åˆ—è¡¨                                 â”‚
â”‚                                                                     â”‚
â”‚  æ­¥éª¤ 4: æ¢å¤æœåŠ¡                                                   â”‚
â”‚  â”œâ”€â”€ ç¡®è®¤æ‰€æœ‰å®¢æˆ·ç«¯å›æ»šå®Œæˆ                                          â”‚
â”‚  â””â”€â”€ é‡æ–°å¼€å§‹å¯†é’¥è½®æ¢æµç¨‹ (ä½¿ç”¨å…¨æ–°å¯†é’¥)                              â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

##### ç¦»çº¿ä¿®å¤æµç¨‹

å½“å®¢æˆ·ç«¯æ— æ³•è¿æ¥æ›´æ–°æœåŠ¡å™¨æˆ–ç­¾åéªŒè¯æŒç»­å¤±è´¥æ—¶:

```bash
# ç¦»çº¿ä¿®å¤è„šæœ¬ (offline_repair.bat)
# ç®¡ç†å‘˜ä»¥ USB æ–¹å¼åˆ†å‘

@echo off
echo === æ¨¡æ¿ç­¾åç¦»çº¿ä¿®å¤å·¥å…· ===

:: 1. å¤‡ä»½å½“å‰æ¨¡æ¿
xcopy /E /I templates templates_backup_%DATE:~0,10%

:: 2. éªŒè¯ä¿®å¤åŒ…ç­¾å (ä½¿ç”¨å¤‡ç”¨å…¬é’¥)
python verify_offline_package.py repair_pack.zip

:: 3. è§£å‹ä¿®å¤åŒ…
7z x repair_pack.zip -otemplates -y

:: 4. æ›´æ–°å…¬é’¥ (å¦‚æœéœ€è¦)
if exist new_template_pub.pem (
    copy /Y new_template_pub.pem keys\template_pub.pem
)

:: 5. æ¸…é™¤å¤±è´¥æ ‡è®°
if exist templates\.update_failed del templates\.update_failed

echo === ä¿®å¤å®Œæˆï¼Œè¯·é‡å¯ç¨‹åº ===
pause
```

##### ç­¾åè¿ç»´æ£€æŸ¥æ¸…å•

| å‘¨æœŸ | æ£€æŸ¥é¡¹ | æ“ä½œ | è´Ÿè´£äºº |
|------|--------|------|--------|
| æ¯æ—¥ | ç­¾åéªŒè¯æˆåŠŸç‡ | ç›‘æ§é¢æ¿æŸ¥çœ‹ | è¿ç»´ |
| æ¯å‘¨ | è¯ä¹¦æœ‰æ•ˆæœŸ | æå‰ 30 å¤©å‘Šè­¦ | è‡ªåŠ¨åŒ– |
| æ¯æœˆ | å¯†é’¥è®¿é—®å®¡è®¡æ—¥å¿— | å®‰å…¨å®¡æŸ¥ | å®‰å…¨å›¢é˜Ÿ |
| æ¯å­£åº¦ | ç¦»çº¿ä¿®å¤åŒ…æ›´æ–° | é‡æ–°ç­¾åå¹¶åˆ†å‘ | å®‰å…¨ç®¡ç†å‘˜ |
| æ¯å¹´ | å¯†é’¥è½®æ¢ | æ‰§è¡Œå®Œæ•´è½®æ¢æµç¨‹ | å®‰å…¨ç®¡ç†å‘˜ |

#### 13.4.5 æ›´æ–°å¤±è´¥å¤„ç†ç­–ç•¥

> **æ ¸å¿ƒåŸåˆ™**: æ›´æ–°å¤±è´¥æ—¶ä¼˜å…ˆä¿è¯ç³»ç»Ÿå¯ç”¨æ€§ï¼Œè‡ªåŠ¨å›æ»šåˆ°æœ€è¿‘å¯ç”¨ç‰ˆæœ¬ï¼Œå¹¶é˜»æ­¢ä¸å®Œæ•´æ›´æ–°è¢«ä½¿ç”¨ã€‚

```python
# services/template_update_policy.py

from enum import Enum
from dataclasses import dataclass
from datetime import datetime
from typing import Optional
import json

class UpdateFailureAction(Enum):
    """æ›´æ–°å¤±è´¥å¤„ç†åŠ¨ä½œ"""
    ROLLBACK_AND_BLOCK = "rollback_block"   # å›æ»šå¹¶é˜»æ­¢å¯åŠ¨ (æœ€å®‰å…¨)
    ROLLBACK_AND_WARN = "rollback_warn"     # å›æ»šå¹¶è­¦å‘Šï¼Œå…è®¸ç»§ç»­
    BLOCK_ONLY = "block_only"               # ä»…é˜»æ­¢ï¼Œä¸å›æ»š

@dataclass
class UpdateFailureEvent:
    """æ›´æ–°å¤±è´¥äº‹ä»¶"""
    timestamp: datetime
    attempted_version: str
    current_version: str
    error_type: str
    error_message: str
    files_affected: list
    rollback_attempted: bool
    rollback_success: Optional[bool]

class TemplateUpdateFailureHandler:
    """æ¨¡æ¿æ›´æ–°å¤±è´¥å¤„ç†å™¨"""

    FAILURE_FLAG_FILE = "templates/.update_failed"

    def __init__(self, config: dict, template_updater: 'TemplateUpdater',
                 alert_manager: 'AlertManager'):
        self.config = config
        self.template_updater = template_updater
        self.alert_manager = alert_manager
        self.policy = UpdateFailureAction(
            config.get('update_failure_action', 'rollback_block')
        )

    def handle_update_failure(
        self,
        error: Exception,
        attempted_version: str,
        files_downloaded: list = None
    ) -> dict:
        """
        å¤„ç†æ›´æ–°å¤±è´¥

        Returns:
            {'action': str, 'success': bool, 'message': str}
        """
        event = UpdateFailureEvent(
            timestamp=datetime.now(),
            attempted_version=attempted_version,
            current_version=self.template_updater._get_current_version(),
            error_type=type(error).__name__,
            error_message=str(error),
            files_affected=files_downloaded or [],
            rollback_attempted=False,
            rollback_success=None
        )

        # 1. è®°å½•å¤±è´¥äº‹ä»¶
        self._log_failure(event)

        # 2. æ ¹æ®ç­–ç•¥å¤„ç†
        if self.policy == UpdateFailureAction.ROLLBACK_AND_BLOCK:
            return self._rollback_and_block(event)

        elif self.policy == UpdateFailureAction.ROLLBACK_AND_WARN:
            return self._rollback_and_warn(event)

        elif self.policy == UpdateFailureAction.BLOCK_ONLY:
            return self._block_only(event)

    def _rollback_and_block(self, event: UpdateFailureEvent) -> dict:
        """å›æ»šå¹¶é˜»æ­¢å¯åŠ¨"""
        # å°è¯•å›æ»š
        event.rollback_attempted = True
        try:
            rollback_success = self.template_updater.rollback()
            event.rollback_success = rollback_success
        except Exception as e:
            logger.error(f"å›æ»šå¤±è´¥: {e}")
            event.rollback_success = False

        # å†™å…¥å¤±è´¥æ ‡è®°æ–‡ä»¶ (é˜»æ­¢ä¸‹æ¬¡å¯åŠ¨ä½¿ç”¨ä¸å®Œæ•´æ¨¡æ¿)
        self._write_failure_flag(event)

        # å‘é€å‘Šè­¦
        self._send_alert(event, urgent=True)

        if event.rollback_success:
            return {
                'action': 'rollback_and_block',
                'success': True,
                'message': (
                    f"æ›´æ–°å¤±è´¥å·²å›æ»šåˆ°ç‰ˆæœ¬ {event.current_version}ã€‚"
                    f"å·²å†™å…¥å¤±è´¥æ ‡è®°ï¼Œéœ€è¦äººå·¥ç¡®è®¤åæ‰èƒ½ç»§ç»­ä½¿ç”¨ã€‚"
                )
            }
        else:
            return {
                'action': 'rollback_and_block',
                'success': False,
                'message': (
                    f"æ›´æ–°å¤±è´¥ä¸”å›æ»šå¤±è´¥ï¼ç³»ç»Ÿå¤„äºä¸ç¨³å®šçŠ¶æ€ã€‚"
                    f"å·²å†™å…¥å¤±è´¥æ ‡è®°ï¼Œå¿…é¡»äººå·¥ä»‹å…¥ä¿®å¤ã€‚"
                )
            }

    def _rollback_and_warn(self, event: UpdateFailureEvent) -> dict:
        """å›æ»šå¹¶è­¦å‘Šï¼Œå…è®¸ç»§ç»­"""
        event.rollback_attempted = True
        try:
            rollback_success = self.template_updater.rollback()
            event.rollback_success = rollback_success
        except Exception as e:
            logger.error(f"å›æ»šå¤±è´¥: {e}")
            event.rollback_success = False

        # å‘é€è­¦å‘Š (éç´§æ€¥)
        self._send_alert(event, urgent=False)

        if event.rollback_success:
            return {
                'action': 'rollback_and_warn',
                'success': True,
                'message': f"æ›´æ–°å¤±è´¥ï¼Œå·²å›æ»šåˆ° {event.current_version}ï¼Œç³»ç»Ÿå¯ç»§ç»­ä½¿ç”¨ã€‚"
            }
        else:
            # å›æ»šä¹Ÿå¤±è´¥ï¼Œå‡çº§ä¸ºé˜»æ­¢
            self._write_failure_flag(event)
            return {
                'action': 'escalated_to_block',
                'success': False,
                'message': "æ›´æ–°å’Œå›æ»šå‡å¤±è´¥ï¼Œå·²å‡çº§ä¸ºé˜»æ­¢æ¨¡å¼ã€‚"
            }

    def _block_only(self, event: UpdateFailureEvent) -> dict:
        """ä»…é˜»æ­¢ï¼Œä¸å›æ»š"""
        self._write_failure_flag(event)
        self._send_alert(event, urgent=True)

        return {
            'action': 'block_only',
            'success': True,
            'message': "æ›´æ–°å¤±è´¥ï¼Œå·²é˜»æ­¢ä½¿ç”¨ä¸å®Œæ•´æ¨¡æ¿ã€‚éœ€è¦äººå·¥ä¿®å¤ã€‚"
        }

    def _write_failure_flag(self, event: UpdateFailureEvent):
        """å†™å…¥å¤±è´¥æ ‡è®°æ–‡ä»¶"""
        flag_data = {
            "failure_time": event.timestamp.isoformat(),
            "attempted_version": event.attempted_version,
            "current_version": event.current_version,
            "error_type": event.error_type,
            "error_message": event.error_message,
            "rollback_success": event.rollback_success,
            "requires_manual_fix": True,
            "recovery_steps": [
                "1. æ£€æŸ¥ç½‘ç»œè¿æ¥å’Œæ›´æ–°æºå¯ç”¨æ€§",
                "2. éªŒè¯æ¨¡æ¿ç­¾åå¯†é’¥é…ç½®",
                "3. æ‰‹åŠ¨ä¸‹è½½å¹¶éªŒè¯æ¨¡æ¿åŒ…",
                "4. åˆ é™¤æ­¤æ ‡è®°æ–‡ä»¶: templates/.update_failed",
                "5. é‡æ–°å¯åŠ¨ç¨‹åº"
            ]
        }

        with open(self.FAILURE_FLAG_FILE, 'w', encoding='utf-8') as f:
            json.dump(flag_data, f, ensure_ascii=False, indent=2)

        logger.warning(f"å·²å†™å…¥æ›´æ–°å¤±è´¥æ ‡è®°: {self.FAILURE_FLAG_FILE}")

    def _log_failure(self, event: UpdateFailureEvent):
        """è®°å½•å¤±è´¥æ—¥å¿—"""
        logger.error(
            f"[æ¨¡æ¿æ›´æ–°å¤±è´¥] ç‰ˆæœ¬ {event.attempted_version}, "
            f"é”™è¯¯: {event.error_type}: {event.error_message}"
        )

    def _send_alert(self, event: UpdateFailureEvent, urgent: bool):
        """å‘é€å‘Šè­¦"""
        subject = f"[{'ç´§æ€¥' if urgent else 'è­¦å‘Š'}] æ¨¡æ¿æ›´æ–°å¤±è´¥ - {event.error_type}"

        body = f"""
        æ¨¡æ¿æ›´æ–°å¤±è´¥æŠ¥å‘Š

        æ—¶é—´: {event.timestamp.strftime('%Y-%m-%d %H:%M:%S')}
        å°è¯•æ›´æ–°ç‰ˆæœ¬: {event.attempted_version}
        å½“å‰ç‰ˆæœ¬: {event.current_version}
        é”™è¯¯ç±»å‹: {event.error_type}
        é”™è¯¯ä¿¡æ¯: {event.error_message}
        å›æ»šå°è¯•: {'æ˜¯' if event.rollback_attempted else 'å¦'}
        å›æ»šç»“æœ: {'æˆåŠŸ' if event.rollback_success else 'å¤±è´¥' if event.rollback_success is False else 'æœªæ‰§è¡Œ'}

        å½±å“æ–‡ä»¶: {len(event.files_affected)} ä¸ª
        """

        if urgent:
            self.alert_manager.send_urgent_alert_custom(subject=subject, body=body)
        else:
            self.alert_manager.send_normal_alert_custom(subject=subject, body=body)

    @classmethod
    def check_can_start(cls) -> tuple[bool, Optional[dict]]:
        """å¯åŠ¨å‰æ£€æŸ¥æ˜¯å¦æœ‰æœªå¤„ç†çš„æ›´æ–°å¤±è´¥"""
        if not os.path.exists(cls.FAILURE_FLAG_FILE):
            return True, None

        try:
            with open(cls.FAILURE_FLAG_FILE, 'r', encoding='utf-8') as f:
                failure_info = json.load(f)
            return False, failure_info
        except (json.JSONDecodeError, IOError):
            return True, None
```

**é…ç½®:**

```yaml
# config.yaml
template_update:
  # ... å…¶ä»–é…ç½® ...

  # æ›´æ–°å¤±è´¥å¤„ç†ç­–ç•¥
  failure_handling:
    # rollback_block: å›æ»šå¹¶é˜»æ­¢å¯åŠ¨ (æœ€å®‰å…¨ï¼Œæ¨è)
    # rollback_warn: å›æ»šå¹¶è­¦å‘Šï¼Œå…è®¸ç»§ç»­
    # block_only: ä»…é˜»æ­¢ï¼Œä¸å°è¯•å›æ»š
    action: "rollback_block"

    # è¿ç»­å¤±è´¥é˜ˆå€¼ (è¶…è¿‡åè‡ªåŠ¨ç¦ç”¨è‡ªåŠ¨æ›´æ–°)
    max_consecutive_failures: 3

    # å¤±è´¥åå†·å´æœŸ (å°æ—¶)
    cooldown_hours: 24
```

**å¯åŠ¨é›†æˆ:**

```python
# åœ¨ä¸»ç¨‹åºå¯åŠ¨æ—¶æ£€æŸ¥
def main():
    # æ£€æŸ¥æ¨¡æ¿æ›´æ–°å¤±è´¥æ ‡è®°
    can_start, failure_info = TemplateUpdateFailureHandler.check_can_start()
    if not can_start:
        print("\n" + "="*60)
        print("âš ï¸  æ£€æµ‹åˆ°æ¨¡æ¿æ›´æ–°å¤±è´¥ï¼Œéœ€è¦äººå·¥å¤„ç†åæ‰èƒ½å¯åŠ¨")
        print("="*60)
        print(f"å¤±è´¥æ—¶é—´: {failure_info.get('failure_time')}")
        print(f"é”™è¯¯ç±»å‹: {failure_info.get('error_type')}")
        print(f"æ¢å¤æ­¥éª¤:")
        for step in failure_info.get('recovery_steps', []):
            print(f"  {step}")
        print("="*60)
        sys.exit(1)

    # æ­£å¸¸å¯åŠ¨...
```

---

## åå››ã€æœ‹å‹åœˆå¤šå›¾å‘å¸ƒç»†èŠ‚

### 14.1 å›¾ç‰‡çº¦æŸè§„èŒƒ

#### 14.1.1 æ•°é‡é™åˆ¶

| æ¸ é“ | æœ€å°æ•°é‡ | æœ€å¤§æ•°é‡ | è¯´æ˜ |
|------|----------|----------|------|
| æœ‹å‹åœˆ | 0 | **9** | å¾®ä¿¡æœ‹å‹åœˆæœ€å¤š 9 å¼ å›¾ |
| ç¾¤æ¶ˆæ¯ | 0 | 9 | å»ºè®®ä¸è¶…è¿‡ 9 å¼  |

#### 14.1.2 å°ºå¯¸ä¸æ ¼å¼é™åˆ¶

| å±æ€§ | é™åˆ¶ | è¯´æ˜ |
|------|------|------|
| **å•å¼ å¤§å°** | <= 10MB | è¶…è¿‡éœ€å‹ç¼© |
| **æ¨èå°ºå¯¸** | 1080x1080 æˆ– 1080x1440 | æ­£æ–¹å½¢æˆ– 3:4 ç«–å›¾æœ€ä½³ |
| **æœ€å°å°ºå¯¸** | 200x200 | å¤ªå°ä¼šæ¨¡ç³Š |
| **æ”¯æŒæ ¼å¼** | JPG, PNG, GIF, BMP, WEBP | GIF ä»…ä¿ç•™ç¬¬ä¸€å¸§ |

#### 14.1.3 å›¾ç‰‡æ ¡éªŒå™¨

```python
# data/image_validator.py

from PIL import Image
import os

class ImageConstraints:
    """å›¾ç‰‡çº¦æŸå¸¸é‡"""
    MAX_COUNT_MOMENT = 9      # æœ‹å‹åœˆæœ€å¤š 9 å¼ 
    MAX_COUNT_GROUP = 9       # ç¾¤æ¶ˆæ¯å»ºè®®æœ€å¤š 9 å¼ 
    MAX_SIZE_MB = 10          # å•å¼ æœ€å¤§ 10MB
    MAX_SIZE_BYTES = MAX_SIZE_MB * 1024 * 1024

    MIN_WIDTH = 200
    MIN_HEIGHT = 200

    SUPPORTED_FORMATS = {'JPEG', 'JPG', 'PNG', 'GIF', 'BMP', 'WEBP'}

class ImageValidationResult:
    """å›¾ç‰‡æ ¡éªŒç»“æœ"""

    def __init__(self):
        self.valid = True
        self.errors = []
        self.warnings = []

    def add_error(self, msg: str):
        self.valid = False
        self.errors.append(msg)

    def add_warning(self, msg: str):
        self.warnings.append(msg)


def validate_image(image_path: str) -> ImageValidationResult:
    """
    æ ¡éªŒå•å¼ å›¾ç‰‡

    Returns:
        ImageValidationResult
    """
    result = ImageValidationResult()

    # 1. æ£€æŸ¥æ–‡ä»¶å­˜åœ¨
    if not os.path.exists(image_path):
        result.add_error(f"å›¾ç‰‡ä¸å­˜åœ¨: {image_path}")
        return result

    # 2. æ£€æŸ¥æ–‡ä»¶å¤§å°
    file_size = os.path.getsize(image_path)
    if file_size == 0:
        result.add_error(f"å›¾ç‰‡æ–‡ä»¶å¤§å°ä¸º 0: {image_path}")
        return result

    if file_size > ImageConstraints.MAX_SIZE_BYTES:
        size_mb = file_size / (1024 * 1024)
        result.add_error(
            f"å›¾ç‰‡å¤§å° ({size_mb:.1f}MB) è¶…è¿‡é™åˆ¶ ({ImageConstraints.MAX_SIZE_MB}MB): {image_path}"
        )

    # 3. æ£€æŸ¥å›¾ç‰‡æ ¼å¼å’Œå°ºå¯¸
    try:
        with Image.open(image_path) as img:
            # æ ¼å¼æ£€æŸ¥
            img_format = img.format.upper() if img.format else 'UNKNOWN'
            if img_format not in ImageConstraints.SUPPORTED_FORMATS:
                result.add_error(f"ä¸æ”¯æŒçš„å›¾ç‰‡æ ¼å¼ ({img_format}): {image_path}")

            # å°ºå¯¸æ£€æŸ¥
            width, height = img.size
            if width < ImageConstraints.MIN_WIDTH or height < ImageConstraints.MIN_HEIGHT:
                result.add_warning(
                    f"å›¾ç‰‡å°ºå¯¸è¿‡å° ({width}x{height}), å»ºè®®è‡³å°‘ {ImageConstraints.MIN_WIDTH}x{ImageConstraints.MIN_HEIGHT}"
                )

            # GIF è­¦å‘Š
            if img_format == 'GIF' and getattr(img, 'n_frames', 1) > 1:
                result.add_warning("GIF åŠ¨å›¾å°†åªä¿ç•™ç¬¬ä¸€å¸§")

    except Exception as e:
        result.add_error(f"æ— æ³•è¯»å–å›¾ç‰‡ ({e}): {image_path}")

    return result


def validate_images_for_moment(image_paths: list) -> ImageValidationResult:
    """
    æ ¡éªŒæœ‹å‹åœˆå›¾ç‰‡åˆ—è¡¨

    Args:
        image_paths: å›¾ç‰‡è·¯å¾„åˆ—è¡¨

    Returns:
        ImageValidationResult
    """
    result = ImageValidationResult()

    # æ•°é‡æ£€æŸ¥
    count = len(image_paths)
    if count > ImageConstraints.MAX_COUNT_MOMENT:
        result.add_error(
            f"å›¾ç‰‡æ•°é‡ ({count}) è¶…è¿‡æœ‹å‹åœˆé™åˆ¶ ({ImageConstraints.MAX_COUNT_MOMENT})"
        )
        # åªæ ¡éªŒå‰ 9 å¼ 
        image_paths = image_paths[:ImageConstraints.MAX_COUNT_MOMENT]

    # é€å¼ æ ¡éªŒ
    for i, path in enumerate(image_paths):
        img_result = validate_image(path)
        for error in img_result.errors:
            result.add_error(f"å›¾ç‰‡ {i+1}: {error}")
        for warning in img_result.warnings:
            result.add_warning(f"å›¾ç‰‡ {i+1}: {warning}")

    return result


def get_file_md5(file_path: str) -> str:
    """è®¡ç®—æ–‡ä»¶ MD5 å“ˆå¸Œ"""
    import hashlib
    hash_md5 = hashlib.md5()
    with open(file_path, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()


def get_cached_compressed_path(original_path: str, cache_dir: str = "cache/compressed") -> str:
    """
    è·å–ç¼“å­˜çš„å‹ç¼©å›¾ç‰‡è·¯å¾„

    ä½¿ç”¨åŸå›¾ MD5 ä½œä¸ºç¼“å­˜é”®ï¼Œé¿å…é‡å¤å‹ç¼©åŒä¸€å¼ å›¾ç‰‡
    ç‰¹åˆ«é€‚ç”¨äºå¤šç¾¤ç¾¤å‘åŒä¸€å¼ å¤§å›¾çš„åœºæ™¯
    """
    os.makedirs(cache_dir, exist_ok=True)
    md5 = get_file_md5(original_path)
    ext = os.path.splitext(original_path)[1].lower()
    # å‹ç¼©åç»Ÿä¸€ä¸º jpg
    cached_path = os.path.join(cache_dir, f"{md5}.jpg")
    return cached_path


def compress_image_if_needed(image_path: str, output_path: str = None, max_size_mb: float = 10) -> str:
    """
    å¦‚æœå›¾ç‰‡è¶…è¿‡å¤§å°é™åˆ¶, è‡ªåŠ¨å‹ç¼©

    ä¼˜åŒ–: ä½¿ç”¨ MD5 ç¼“å­˜ï¼Œé¿å…é‡å¤å‹ç¼©åŒä¸€å¼ å›¾ç‰‡

    Returns:
        è¾“å‡ºæ–‡ä»¶è·¯å¾„
    """
    max_size_bytes = max_size_mb * 1024 * 1024

    if os.path.getsize(image_path) <= max_size_bytes:
        return image_path  # æ— éœ€å‹ç¼©

    # æ£€æŸ¥ MD5 ç¼“å­˜
    cached_path = get_cached_compressed_path(image_path)
    if os.path.exists(cached_path) and os.path.getsize(cached_path) <= max_size_bytes:
        logger.info(f"ä½¿ç”¨ç¼“å­˜çš„å‹ç¼©å›¾ç‰‡: {cached_path}")
        return cached_path

    output_path = output_path or cached_path  # é»˜è®¤è¾“å‡ºåˆ°ç¼“å­˜ç›®å½•

    with Image.open(image_path) as img:
        # è½¬æ¢ä¸º RGB (å»é™¤ alpha é€šé“)
        if img.mode in ('RGBA', 'P'):
            img = img.convert('RGB')

        # é€æ­¥é™ä½è´¨é‡ç›´åˆ°æ»¡è¶³å¤§å°è¦æ±‚
        quality = 95
        while quality > 10:
            img.save(output_path, 'JPEG', quality=quality, optimize=True)
            if os.path.getsize(output_path) <= max_size_bytes:
                logger.info(f"å›¾ç‰‡å·²å‹ç¼© (quality={quality}): {output_path}")
                return output_path
            quality -= 10

        # å¦‚æœè¿˜æ˜¯å¤ªå¤§, ç¼©å°å°ºå¯¸
        width, height = img.size
        while os.path.getsize(output_path) > max_size_bytes and width > 800:
            width = int(width * 0.8)
            height = int(height * 0.8)
            img_resized = img.resize((width, height), Image.LANCZOS)
            img_resized.save(output_path, 'JPEG', quality=85, optimize=True)
            logger.info(f"å›¾ç‰‡å·²ç¼©å° ({width}x{height}): {output_path}")

    return output_path
```

#### 14.1.4 å›¾ç‰‡å‹ç¼©å‰¯ä½œç”¨ä¸æ³¨æ„äº‹é¡¹

**å‹ç¼©å¯èƒ½å¸¦æ¥çš„å½±å“:**

| å½±å“ | è¯´æ˜ | åº”å¯¹æªæ–½ |
|------|------|----------|
| **ç”»è´¨æŸå¤±** | JPEG å‹ç¼©ä¼šé™ä½æ¸…æ™°åº¦ | æä¾›å‹ç¼©å‰åå¯¹æ¯”é¢„è§ˆ |
| **è‰²å½©åå·®** | è‰²å½©ç©ºé—´è½¬æ¢å¯èƒ½å¯¼è‡´è½»å¾®åè‰² | ä½¿ç”¨ sRGB è‰²å½©ç©ºé—´ |
| **é€æ˜åº¦ä¸¢å¤±** | PNG è½¬ JPEG ä¼šä¸¢å¤±é€æ˜é€šé“ | ç”¨ç™½è‰²èƒŒæ™¯å¡«å…… |
| **åŠ¨å›¾å˜é™å›¾** | GIF åªä¿ç•™ç¬¬ä¸€å¸§ | UI æ˜ç¡®è­¦å‘Šç”¨æˆ· |
| **EXIF ä¸¢å¤±** | å‹ç¼©ä¼šç§»é™¤å…ƒæ•°æ® | å¦‚éœ€ä¿ç•™éœ€é¢å¤–å¤„ç† |

**UI æç¤ºç­–ç•¥:**

```python
class ImageCompressionWarning:
    """å›¾ç‰‡å‹ç¼©è­¦å‘Š"""

    @staticmethod
    def check_and_warn(images: list) -> list:
        """æ£€æŸ¥å›¾ç‰‡å¹¶è¿”å›è­¦å‘Šä¿¡æ¯"""
        warnings = []

        for i, img_path in enumerate(images):
            img_warnings = []

            # æ£€æŸ¥å¤§å°
            size_mb = os.path.getsize(img_path) / (1024 * 1024)
            if size_mb > 10:
                img_warnings.append(f"å°†è¢«å‹ç¼© (å½“å‰ {size_mb:.1f}MB)")

            # æ£€æŸ¥æ ¼å¼
            with Image.open(img_path) as img:
                if img.format == 'PNG' and img.mode == 'RGBA':
                    img_warnings.append("é€æ˜èƒŒæ™¯å°†å˜ä¸ºç™½è‰²")

                if img.format == 'GIF' and getattr(img, 'n_frames', 1) > 1:
                    img_warnings.append("åŠ¨å›¾å°†åªä¿ç•™ç¬¬ä¸€å¸§")

            if img_warnings:
                warnings.append({
                    'index': i + 1,
                    'path': img_path,
                    'warnings': img_warnings
                })

        return warnings

    @staticmethod
    def show_warning_dialog(warnings: list) -> bool:
        """æ˜¾ç¤ºå‹ç¼©è­¦å‘Šå¯¹è¯æ¡†, è¿”å›ç”¨æˆ·æ˜¯å¦ç¡®è®¤"""
        if not warnings:
            return True

        msg = "ä»¥ä¸‹å›¾ç‰‡å°†è¢«å¤„ç†:\n\n"
        for w in warnings:
            msg += f"å›¾ç‰‡ {w['index']}:\n"
            for warning in w['warnings']:
                msg += f"  - {warning}\n"

        msg += "\næ˜¯å¦ç»§ç»­?"

        reply = QMessageBox.question(
            None, "å›¾ç‰‡å¤„ç†æé†’", msg,
            QMessageBox.Yes | QMessageBox.No
        )
        return reply == QMessageBox.Yes
```

**é…ç½®é€‰é¡¹:**

```yaml
# config.yaml
image_processing:
  # å‹ç¼©è®¾ç½®
  auto_compress: true           # è‡ªåŠ¨å‹ç¼©è¶…é™å›¾ç‰‡
  compress_quality: 85          # å‹ç¼©è´¨é‡ (1-100)
  max_resize_iterations: 5      # æœ€å¤§ç¼©æ”¾æ¬¡æ•°

  # åŸå›¾ä¿ç•™ (è¯¦è§ä¸‹æ–¹ç­–ç•¥)
  keep_original: true           # ä¿ç•™åŸå›¾åˆ°å¤‡ä»½ç›®å½•
  original_backup_dir: "cache/original_images"
  original_retention_days: 7    # åŸå›¾ä¿ç•™å¤©æ•°

  # é¢„è§ˆ
  show_compress_preview: true   # æ˜¾ç¤ºå‹ç¼©å‰åå¯¹æ¯”
  show_compress_warning: true   # æ˜¾ç¤ºå‹ç¼©è­¦å‘Š

  # GIF å¤„ç† (è¯¦è§ä¸‹æ–¹å¼ºåˆ¶é¢„è­¦ç­–ç•¥)
  gif_warning: true             # GIF åŠ¨å›¾è­¦å‘Š
  gif_extract_frame: 0          # æå–å¸§å· (0=ç¬¬ä¸€å¸§)
  gif_force_confirm: true       # GIF å¼ºåˆ¶ç¡®è®¤ (ä¸å¯è·³è¿‡)
```

#### 14.1.5 åŸå›¾ä¿ç•™ç­–ç•¥è¯¦è§£

**å­˜å‚¨ç»“æ„:**

```
cache/
|-- original_images/
|   |-- 2024-11-25/
|   |   |-- P001_moment_1_original.jpg      # åŸå›¾ (ä»»åŠ¡ID_æ¸ é“_åºå·_original.æ‰©å±•å)
|   |   |-- P001_moment_1_compressed.jpg    # å‹ç¼©å
|   |   |-- P001_moment_2_original.png
|   |   |-- P001_moment_2_compressed.jpg
|   |   +-- manifest.json                   # å½“æ—¥ç´¢å¼•
|   |-- 2024-11-24/
|   +-- ...
```

**manifest.json æ ¼å¼:**

```json
{
  "date": "2024-11-25",
  "files": [
    {
      "task_id": "P001",
      "channel": "moment",
      "index": 1,
      "original": "P001_moment_1_original.jpg",
      "compressed": "P001_moment_1_compressed.jpg",
      "original_size": 5242880,
      "compressed_size": 1048576,
      "compression_ratio": 0.2,
      "created_at": "2024-11-25T10:30:00"
    }
  ],
  "total_original_size": 52428800,
  "total_compressed_size": 10485760,
  "space_saved": 41943040
}
```

**åŸå›¾ç®¡ç†å™¨:**

```python
# services/original_image_manager.py

from pathlib import Path
from datetime import datetime, timedelta
import json
import shutil

class OriginalImageManager:
    """åŸå›¾ç®¡ç†å™¨"""

    def __init__(self, config: dict):
        self.config = config
        self.base_dir = Path(config.get('original_backup_dir', 'cache/original_images'))
        self.retention_days = config.get('original_retention_days', 7)
        self.base_dir.mkdir(parents=True, exist_ok=True)

    def backup_original(self, task_id: str, channel: str, index: int,
                        original_path: Path, compressed_path: Path) -> dict:
        """
        å¤‡ä»½åŸå›¾

        Args:
            task_id: ä»»åŠ¡ID
            channel: æ¸ é“
            index: å›¾ç‰‡åºå·
            original_path: åŸå›¾è·¯å¾„
            compressed_path: å‹ç¼©åè·¯å¾„

        Returns:
            å¤‡ä»½ä¿¡æ¯å­—å…¸
        """
        date_str = datetime.now().strftime('%Y-%m-%d')
        date_dir = self.base_dir / date_str
        date_dir.mkdir(exist_ok=True)

        # æ„å»ºç›®æ ‡æ–‡ä»¶å
        ext = original_path.suffix
        original_name = f"{task_id}_{channel}_{index}_original{ext}"
        compressed_name = f"{task_id}_{channel}_{index}_compressed{compressed_path.suffix}"

        # å¤åˆ¶æ–‡ä»¶
        original_backup = date_dir / original_name
        compressed_backup = date_dir / compressed_name

        shutil.copy2(original_path, original_backup)
        shutil.copy2(compressed_path, compressed_backup)

        # è®°å½•åˆ° manifest
        backup_info = {
            'task_id': task_id,
            'channel': channel,
            'index': index,
            'original': original_name,
            'compressed': compressed_name,
            'original_size': original_path.stat().st_size,
            'compressed_size': compressed_path.stat().st_size,
            'compression_ratio': compressed_path.stat().st_size / original_path.stat().st_size,
            'created_at': datetime.now().isoformat()
        }

        self._update_manifest(date_dir, backup_info)
        logger.debug(f"åŸå›¾å·²å¤‡ä»½: {original_backup}")

        return backup_info

    def _update_manifest(self, date_dir: Path, file_info: dict):
        """æ›´æ–°å½“æ—¥ manifest"""
        manifest_path = date_dir / 'manifest.json'

        if manifest_path.exists():
            with open(manifest_path, 'r', encoding='utf-8') as f:
                manifest = json.load(f)
        else:
            manifest = {
                'date': date_dir.name,
                'files': [],
                'total_original_size': 0,
                'total_compressed_size': 0,
                'space_saved': 0
            }

        manifest['files'].append(file_info)
        manifest['total_original_size'] += file_info['original_size']
        manifest['total_compressed_size'] += file_info['compressed_size']
        manifest['space_saved'] = manifest['total_original_size'] - manifest['total_compressed_size']

        with open(manifest_path, 'w', encoding='utf-8') as f:
            json.dump(manifest, f, ensure_ascii=False, indent=2)

    def cleanup_expired(self) -> dict:
        """æ¸…ç†è¿‡æœŸåŸå›¾"""
        cutoff_date = datetime.now() - timedelta(days=self.retention_days)
        cleaned = {'dirs': 0, 'files': 0, 'bytes': 0}

        for date_dir in self.base_dir.iterdir():
            if not date_dir.is_dir():
                continue

            try:
                dir_date = datetime.strptime(date_dir.name, '%Y-%m-%d')
                if dir_date < cutoff_date:
                    # ç»Ÿè®¡å¤§å°
                    for file in date_dir.rglob('*'):
                        if file.is_file():
                            cleaned['bytes'] += file.stat().st_size
                            cleaned['files'] += 1

                    # åˆ é™¤ç›®å½•
                    shutil.rmtree(date_dir)
                    cleaned['dirs'] += 1
                    logger.info(f"å·²æ¸…ç†è¿‡æœŸåŸå›¾ç›®å½•: {date_dir.name}")

            except ValueError:
                # ç›®å½•åä¸æ˜¯æ—¥æœŸæ ¼å¼, è·³è¿‡
                continue

        return cleaned

    def get_original(self, task_id: str, channel: str, index: int, date: str) -> Optional[Path]:
        """è·å–åŸå›¾è·¯å¾„"""
        date_dir = self.base_dir / date
        if not date_dir.exists():
            return None

        # æŸ¥æ‰¾åŒ¹é…çš„åŸå›¾
        pattern = f"{task_id}_{channel}_{index}_original.*"
        matches = list(date_dir.glob(pattern))
        return matches[0] if matches else None
```

#### 14.1.6 æ‰§è¡Œå™¨å›¾ç‰‡è·¯å¾„é€‰æ‹©ç­–ç•¥

**æ ¸å¿ƒåŸåˆ™**: æ‰§è¡Œå™¨å§‹ç»ˆä½¿ç”¨**å‹ç¼©åè·¯å¾„**å‘é€ï¼ŒåŸå›¾ä»…ç”¨äºå¤‡ä»½å’Œå›æº¯ã€‚

```python
# core/image_path_resolver.py

class ImagePathResolver:
    """å›¾ç‰‡è·¯å¾„è§£æå™¨ - å†³å®šæ‰§è¡Œå™¨ä½¿ç”¨å“ªä¸ªè·¯å¾„"""

    def __init__(self, config: dict, original_manager: OriginalImageManager):
        self.config = config
        self.original_manager = original_manager
        self.auto_compress = config.get('image_processing', {}).get('auto_compress', True)
        self.max_size_mb = config.get('image_processing', {}).get('max_size_mb', 10)

    def resolve_paths(self, task_id: str, channel: str, image_paths: list) -> list:
        """
        è§£æå›¾ç‰‡è·¯å¾„ï¼Œè¿”å›æ‰§è¡Œå™¨å®é™…ä½¿ç”¨çš„è·¯å¾„åˆ—è¡¨

        å¤„ç†æµç¨‹:
        1. æ£€æŸ¥æ¯å¼ å›¾ç‰‡å¤§å°
        2. è¶…é™å›¾ç‰‡è¿›è¡Œå‹ç¼©
        3. å¤‡ä»½åŸå›¾åˆ° original_images ç›®å½•
        4. è¿”å›å‹ç¼©åè·¯å¾„åˆ—è¡¨

        Args:
            task_id: ä»»åŠ¡ID
            channel: æ¸ é“ (moment/group)
            image_paths: åŸå§‹å›¾ç‰‡è·¯å¾„åˆ—è¡¨

        Returns:
            æ‰§è¡Œå™¨ä½¿ç”¨çš„å›¾ç‰‡è·¯å¾„åˆ—è¡¨ (å‹ç¼©åè·¯å¾„)
        """
        resolved_paths = []
        max_size_bytes = self.max_size_mb * 1024 * 1024

        for i, original_path in enumerate(image_paths):
            original_path = Path(original_path)
            file_size = original_path.stat().st_size

            if file_size <= max_size_bytes:
                # æ— éœ€å‹ç¼©ï¼Œç›´æ¥ä½¿ç”¨åŸè·¯å¾„
                resolved_paths.append(str(original_path))
                logger.debug(f"å›¾ç‰‡ {i+1} æ— éœ€å‹ç¼©: {original_path.name}")
            else:
                # éœ€è¦å‹ç¼©
                if not self.auto_compress:
                    raise ImageTooLargeError(
                        f"å›¾ç‰‡ {original_path.name} ({file_size / 1024 / 1024:.1f}MB) "
                        f"è¶…è¿‡é™åˆ¶ ({self.max_size_mb}MB)ï¼Œä¸”è‡ªåŠ¨å‹ç¼©å·²ç¦ç”¨"
                    )

                # ç”Ÿæˆå‹ç¼©åè·¯å¾„ (ä¸´æ—¶ç›®å½•)
                compressed_path = self._get_compressed_path(original_path)

                # æ‰§è¡Œå‹ç¼©
                compress_image_if_needed(
                    str(original_path),
                    str(compressed_path),
                    self.max_size_mb
                )

                # å¤‡ä»½åŸå›¾ (å¼‚æ­¥ï¼Œä¸é˜»å¡å‘é€)
                self.original_manager.backup_original(
                    task_id=task_id,
                    channel=channel,
                    index=i + 1,
                    original_path=original_path,
                    compressed_path=compressed_path
                )

                # ä½¿ç”¨å‹ç¼©åè·¯å¾„
                resolved_paths.append(str(compressed_path))
                logger.info(
                    f"å›¾ç‰‡ {i+1} å·²å‹ç¼©: "
                    f"{file_size / 1024 / 1024:.1f}MB -> "
                    f"{compressed_path.stat().st_size / 1024 / 1024:.1f}MB"
                )

        return resolved_paths

    def _get_compressed_path(self, original_path: Path) -> Path:
        """ç”Ÿæˆå‹ç¼©åæ–‡ä»¶è·¯å¾„"""
        cache_dir = Path(self.config.get('cache_dir', 'cache')) / 'compressed'
        cache_dir.mkdir(parents=True, exist_ok=True)

        # ä½¿ç”¨æ—¶é—´æˆ³é¿å…å†²çª
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S%f')
        compressed_name = f"{original_path.stem}_{timestamp}_compressed.jpg"
        return cache_dir / compressed_name
```

**è·¯å¾„ä½¿ç”¨è§„èŒƒ:**

| é˜¶æ®µ | ä½¿ç”¨è·¯å¾„ | è¯´æ˜ |
|------|----------|------|
| å¯¼å…¥/æ ¡éªŒ | åŸå§‹è·¯å¾„ | ä» Excel è¯»å–çš„åŸå§‹è·¯å¾„ |
| å‹ç¼©å¤„ç† | åŸå§‹ â†’ å‹ç¼© | è¶…é™å›¾ç‰‡ç”Ÿæˆå‹ç¼©å‰¯æœ¬ |
| æ‰§è¡Œå‘é€ | **å‹ç¼©åè·¯å¾„** | æ‰§è¡Œå™¨å§‹ç»ˆä½¿ç”¨è§£æåçš„è·¯å¾„ |
| åŸå›¾å¤‡ä»½ | åŸå§‹è·¯å¾„ â†’ å¤‡ä»½ç›®å½• | å¼‚æ­¥å¤‡ä»½ï¼Œä¸é˜»å¡å‘é€ |
| å›æ‰§è®°å½• | è®°å½•ä¸¤è€… | åŒæ—¶è®°å½•åŸå§‹å’Œå‹ç¼©åè·¯å¾„ |

**æ‰§è¡Œå™¨è°ƒç”¨ç¤ºä¾‹:**

```python
# åœ¨ä»»åŠ¡æ‰§è¡Œå‰è§£æè·¯å¾„
def execute_task(task):
    resolver = ImagePathResolver(config, original_manager)

    # è§£æè·¯å¾„ - è¿”å›å‹ç¼©åè·¯å¾„åˆ—è¡¨
    image_paths = resolver.resolve_paths(
        task_id=task.id,
        channel=task.channel,
        image_paths=task.image_paths  # åŸå§‹è·¯å¾„
    )

    # æ‰§è¡Œå‘é€ - ä½¿ç”¨å‹ç¼©åè·¯å¾„
    if task.channel == 'moment':
        send_moment_with_images(task.text, image_paths)  # å‹ç¼©åè·¯å¾„
    else:
        send_group_message(task.group_name, task.text, image_paths)
```

#### 14.1.7 GIF åŠ¨å›¾å¼ºåˆ¶é¢„è­¦ç­–ç•¥

GIF åŠ¨å›¾å‘é€æ—¶åªä¼šä¿ç•™ç¬¬ä¸€å¸§ï¼Œè¿™å¯èƒ½å¯¼è‡´ç”¨æˆ·é¢„æœŸä¸å®é™…æ•ˆæœä¸ç¬¦ã€‚å¿…é¡»åœ¨å‘é€å‰å¼ºåˆ¶æé†’å¹¶è·å¾—ç¡®è®¤ã€‚

**å¼ºåˆ¶é¢„è­¦æœºåˆ¶:**

```python
# services/gif_warning.py

from PySide6.QtWidgets import QMessageBox, QCheckBox
from PySide6.QtCore import Qt

class GifWarningHandler:
    """GIF è­¦å‘Šå¤„ç†å™¨"""

    def __init__(self, config: dict):
        self.force_confirm = config.get('gif_force_confirm', True)
        self._session_confirmed = set()  # æœ¬æ¬¡ä¼šè¯å·²ç¡®è®¤çš„ä»»åŠ¡

    def check_gif_images(self, images: list) -> list:
        """æ£€æŸ¥æ˜¯å¦åŒ…å« GIF åŠ¨å›¾"""
        gif_warnings = []

        for i, img_path in enumerate(images):
            try:
                with Image.open(img_path) as img:
                    if img.format == 'GIF' and getattr(img, 'n_frames', 1) > 1:
                        gif_warnings.append({
                            'index': i + 1,
                            'path': img_path,
                            'frames': img.n_frames,
                            'duration': img.info.get('duration', 0)
                        })
            except Exception as e:
                logger.warning(f"æ£€æŸ¥å›¾ç‰‡å¤±è´¥: {img_path}, {e}")

        return gif_warnings

    def show_gif_warning(self, task_id: str, gif_warnings: list) -> bool:
        """
        æ˜¾ç¤º GIF è­¦å‘Šå¯¹è¯æ¡†

        å¼ºåˆ¶æ¨¡å¼ä¸‹:
        - ç”¨æˆ·å¿…é¡»é˜…è¯»å®Œæ•´è­¦å‘Š
        - å‹¾é€‰ç¡®è®¤æ¡†æ‰èƒ½ç»§ç»­
        - ä¸å¯é€šè¿‡å…³é—­çª—å£ç»•è¿‡

        Returns:
            ç”¨æˆ·æ˜¯å¦ç¡®è®¤ç»§ç»­
        """
        if not gif_warnings:
            return True

        # æ£€æŸ¥ä¼šè¯ç¼“å­˜
        cache_key = f"{task_id}_gif_confirmed"
        if cache_key in self._session_confirmed:
            return True

        # æ„å»ºè­¦å‘Šæ¶ˆæ¯
        msg = "âš ï¸ æ£€æµ‹åˆ° GIF åŠ¨å›¾!\n\n"
        msg += "å¾®ä¿¡å‘é€æ—¶ GIF åŠ¨å›¾ä¼šå˜æˆé™æ€å›¾ç‰‡ (ä»…ä¿ç•™ç¬¬ä¸€å¸§)\n\n"
        msg += "æ¶‰åŠçš„å›¾ç‰‡:\n"

        for w in gif_warnings:
            msg += f"  â€¢ å›¾ç‰‡ {w['index']}: {w['frames']} å¸§åŠ¨å›¾\n"

        msg += "\nè¿™å¯èƒ½å¯¼è‡´:\n"
        msg += "  â€¢ åŠ¨æ€æ•ˆæœä¸¢å¤±\n"
        msg += "  â€¢ å±•ç¤ºæ•ˆæœä¸é¢„æœŸä¸ç¬¦\n"
        msg += "  â€¢ æ— æ³•æ¢å¤åŠ¨ç”»æ•ˆæœ\n"

        if self.force_confirm:
            return self._show_force_confirm_dialog(task_id, msg)
        else:
            return self._show_normal_warning_dialog(msg)

    def _show_force_confirm_dialog(self, task_id: str, msg: str) -> bool:
        """æ˜¾ç¤ºå¼ºåˆ¶ç¡®è®¤å¯¹è¯æ¡†"""
        dialog = QMessageBox()
        dialog.setIcon(QMessageBox.Warning)
        dialog.setWindowTitle("GIF åŠ¨å›¾è­¦å‘Š")
        dialog.setText(msg)

        # æ·»åŠ ç¡®è®¤å‹¾é€‰æ¡†
        confirm_checkbox = QCheckBox("æˆ‘å·²äº†è§£ GIF å°†å˜ä¸ºé™æ€å›¾ç‰‡ï¼Œç¡®è®¤ç»§ç»­å‘é€")
        dialog.setCheckBox(confirm_checkbox)

        # åªæœ‰ç¡®è®¤æŒ‰é’® (ç¦ç”¨å…³é—­æŒ‰é’®ç»•è¿‡)
        dialog.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        dialog.setDefaultButton(QMessageBox.Cancel)

        # ç¡®è®¤æŒ‰é’®é»˜è®¤ç¦ç”¨ï¼Œå‹¾é€‰åå¯ç”¨
        ok_button = dialog.button(QMessageBox.Ok)
        ok_button.setEnabled(False)
        ok_button.setText("ç¡®è®¤å‘é€")

        confirm_checkbox.stateChanged.connect(
            lambda state: ok_button.setEnabled(state == Qt.Checked)
        )

        result = dialog.exec()

        if result == QMessageBox.Ok and confirm_checkbox.isChecked():
            self._session_confirmed.add(f"{task_id}_gif_confirmed")
            logger.info(f"ç”¨æˆ·ç¡®è®¤ GIF è­¦å‘Š: {task_id}")
            return True

        logger.info(f"ç”¨æˆ·å–æ¶ˆ GIF å‘é€: {task_id}")
        return False

    def _show_normal_warning_dialog(self, msg: str) -> bool:
        """æ˜¾ç¤ºæ™®é€šè­¦å‘Šå¯¹è¯æ¡†"""
        reply = QMessageBox.warning(
            None, "GIF åŠ¨å›¾æé†’",
            msg + "\n\næ˜¯å¦ç»§ç»­å‘é€?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        return reply == QMessageBox.Yes
```

**æ—¥å¿—è®°å½•è¦æ±‚:**

GIF å˜é™å›¾å¿…é¡»åœ¨å‘é€å‰å¼ºåˆ¶è®°å½•æ—¥å¿—:

```python
# åœ¨ WeChatPublisher.publish() ä¸­

gif_warnings = gif_handler.check_gif_images(task.images)
if gif_warnings:
    # å¼ºåˆ¶è®°å½•æ—¥å¿— (ä¸å¯é…ç½®å…³é—­)
    for w in gif_warnings:
        logger.warning(
            f"[GIF->é™å›¾] ä»»åŠ¡ {task.id} å›¾ç‰‡ {w['index']} "
            f"å°†ä» {w['frames']} å¸§åŠ¨å›¾å˜ä¸ºé™æ€å›¾ç‰‡"
        )

    # æ˜¾ç¤ºè­¦å‘Šå¯¹è¯æ¡†
    if not gif_handler.show_gif_warning(task.id, gif_warnings):
        return {'status': 'cancelled', 'reason': 'ç”¨æˆ·å–æ¶ˆ GIF å‘é€'}
```

#### 14.1.8 GIF æ— äººå€¼å®ˆç­–ç•¥

> **æ ¸å¿ƒåŸåˆ™**: æ— äººå€¼å®ˆæ¨¡å¼ä¸‹ï¼ŒGIF ä»»åŠ¡æ— æ³•è·å¾—äººå·¥ç¡®è®¤ï¼Œåº”è‡ªåŠ¨å–æ¶ˆå¹¶å‘Šè­¦ã€‚

```python
# services/gif_unattended_policy.py

from enum import Enum

class UnattendedGifPolicy(Enum):
    """æ— äººå€¼å®ˆæ—¶ GIF å¤„ç†ç­–ç•¥"""
    CANCEL = "cancel"           # å–æ¶ˆä»»åŠ¡ (æ¨è/é»˜è®¤)
    CONVERT_SILENT = "convert"  # é™é»˜è½¬æ¢ (æœ‰é£é™©)
    QUEUE_FOR_MANUAL = "queue"  # æ’é˜Ÿç­‰å¾…äººå·¥å¤„ç†

class GifUnattendedHandler:
    """GIF æ— äººå€¼å®ˆå¤„ç†å™¨"""

    def __init__(self, config: dict, alert_manager: 'AlertManager'):
        self.config = config
        self.alert_manager = alert_manager
        self.policy = UnattendedGifPolicy(
            config.get('gif_unattended_policy', 'cancel')
        )

    def handle_gif_in_unattended_mode(
        self,
        task,
        gif_warnings: list
    ) -> dict:
        """
        æ— äººå€¼å®ˆæ¨¡å¼ä¸‹å¤„ç† GIF ä»»åŠ¡

        Returns:
            {'action': 'cancel'|'proceed'|'queue', 'reason': str}
        """
        if not gif_warnings:
            return {'action': 'proceed', 'reason': ''}

        if self.policy == UnattendedGifPolicy.CANCEL:
            # é»˜è®¤ç­–ç•¥: å–æ¶ˆä»»åŠ¡ + å‘é€å‘Šè­¦
            self._log_and_alert(task, gif_warnings, action='å–æ¶ˆ')

            return {
                'action': 'cancel',
                'reason': (
                    f"æ— äººå€¼å®ˆæ¨¡å¼ä¸‹æ£€æµ‹åˆ° GIF åŠ¨å›¾ï¼Œä»»åŠ¡å·²è‡ªåŠ¨å–æ¶ˆã€‚"
                    f"æ¶‰åŠ {len(gif_warnings)} å¼  GIF å›¾ç‰‡ã€‚"
                )
            }

        elif self.policy == UnattendedGifPolicy.CONVERT_SILENT:
            # é™é»˜è½¬æ¢ (é«˜é£é™©: ç”¨æˆ·å¯èƒ½ä¸çŸ¥æƒ…)
            logger.warning(
                f"[é£é™©] æ— äººå€¼å®ˆé™é»˜è½¬æ¢ GIF: task={task.id}, "
                f"gif_count={len(gif_warnings)}"
            )
            self._log_and_alert(task, gif_warnings, action='é™é»˜è½¬æ¢')

            return {'action': 'proceed', 'reason': 'é™é»˜è½¬æ¢ä¸ºé™æ€å›¾'}

        elif self.policy == UnattendedGifPolicy.QUEUE_FOR_MANUAL:
            # æ’é˜Ÿç­‰å¾…äººå·¥
            self._queue_for_manual(task, gif_warnings)

            return {
                'action': 'queue',
                'reason': f"GIF ä»»åŠ¡å·²æ’é˜Ÿç­‰å¾…äººå·¥ç¡®è®¤"
            }

    def _log_and_alert(self, task, gif_warnings: list, action: str):
        """è®°å½•æ—¥å¿—å¹¶å‘é€å‘Šè­¦"""
        # è¯¦ç»†æ—¥å¿—
        for w in gif_warnings:
            logger.warning(
                f"[GIFæ— äººå€¼å®ˆ] ä»»åŠ¡ {task.id} å›¾ç‰‡ {w['index']}: "
                f"{w['frames']} å¸§åŠ¨å›¾ -> å¤„ç†: {action}"
            )

        # å‘é€å‘Šè­¦é‚®ä»¶
        self.alert_manager.send_normal_alert_custom(
            subject=f"[GIFå‘Šè­¦] æ— äººå€¼å®ˆæ¨¡å¼æ£€æµ‹åˆ° GIF åŠ¨å›¾ - {action}",
            body=f"""
            ä»»åŠ¡ID: {task.id}
            äº§å“å: {task.product_name}
            GIF æ•°é‡: {len(gif_warnings)} å¼ 
            å¤„ç†åŠ¨ä½œ: {action}

            è¯¦ç»†ä¿¡æ¯:
            {self._format_gif_details(gif_warnings)}

            è¯·åœ¨æœ‰äººå€¼å®ˆæ—¶é‡æ–°æäº¤åŒ…å« GIF çš„ä»»åŠ¡ã€‚
            """
        )

    def _format_gif_details(self, gif_warnings: list) -> str:
        """æ ¼å¼åŒ– GIF è¯¦æƒ…"""
        lines = []
        for w in gif_warnings:
            lines.append(f"- å›¾ç‰‡ {w['index']}: {w['frames']} å¸§, {w.get('path', 'æœªçŸ¥è·¯å¾„')}")
        return '\n'.join(lines)

    def _queue_for_manual(self, task, gif_warnings: list):
        """å°†ä»»åŠ¡æ’å…¥äººå·¥å¤„ç†é˜Ÿåˆ— (ä½¿ç”¨ paused çŠ¶æ€ä¿æŒæšä¸¾ä¸€è‡´)"""
        task.status = 'paused'  # è§„èŒƒçŠ¶æ€å€¼
        task.pause_reason = 'manual_review'  # äººå·¥å®¡æ ¸æ ‡è®°
        task.pause_detail = f"åŒ…å« {len(gif_warnings)} å¼  GIF åŠ¨å›¾"
        # ä¿å­˜åˆ°æ•°æ®åº“
        db.update_task(task)
        logger.info(f"ä»»åŠ¡ {task.id} å·²æ’å…¥äººå·¥å®¡æ ¸é˜Ÿåˆ— (çŠ¶æ€: paused)")
```

**é…ç½®:**

```yaml
# config.yaml

image_processing:
  # GIF æ— äººå€¼å®ˆç­–ç•¥
  gif_unattended_policy: "cancel"  # cancel (æ¨è) | convert | queue

  # æ— äººå€¼å®ˆæ£€æµ‹
  unattended_detection:
    # è¶…è¿‡æ­¤æ—¶é—´æ— é¼ æ ‡/é”®ç›˜æ´»åŠ¨è§†ä¸ºæ— äººå€¼å®ˆ
    idle_threshold_minutes: 10
    # æ£€æµ‹æ–¹æ³•
    method: "idle_time"  # idle_time | explicit_flag | schedule
    # æ£€æµ‹å¤±è´¥æ—¶çš„é»˜è®¤è¡Œä¸º (é‡è¦!)
    detection_failure_is_unattended: true  # æ£€æµ‹å¤±è´¥ = è§†ä¸ºæ— äººå€¼å®ˆ (æ›´å®‰å…¨)
```

**æ— äººå€¼å®ˆæ£€æµ‹å™¨ (å«å¤±è´¥å®‰å…¨å¤„ç†):**

> **å…³é”®é—­ç¯**: æ£€æµ‹å¤±è´¥æ—¶é»˜è®¤è§†ä¸ºæ— äººå€¼å®ˆï¼Œç¡®ä¿ GIF ä»»åŠ¡ä¸ä¼šåœ¨æ— äººç›‘ç£æ—¶æ„å¤–å‘å¸ƒã€‚

```python
# services/unattended_detector.py

import ctypes
from datetime import datetime, timedelta
from typing import Tuple, Optional
from dataclasses import dataclass

@dataclass
class DetectionResult:
    """æ£€æµ‹ç»“æœ"""
    is_unattended: bool
    confidence: float          # ç½®ä¿¡åº¦ 0-1
    detection_method: str      # ä½¿ç”¨çš„æ£€æµ‹æ–¹æ³•
    error: Optional[str]       # æ£€æµ‹é”™è¯¯ (å¦‚æœæœ‰)

class UnattendedDetector:
    """
    æ— äººå€¼å®ˆæ£€æµ‹å™¨

    æ ¸å¿ƒåŸåˆ™: æ£€æµ‹å¤±è´¥æ—¶é»˜è®¤è§†ä¸ºæ— äººå€¼å®ˆ (fail-safe)
    ç†ç”±: GIF åœ¨æ— äººå€¼å®ˆæ—¶å‘é€ä¼šå¯¼è‡´æ— æ³•å–æ¶ˆçš„é”™è¯¯ï¼Œå®å¯è¯¯åˆ¤ä¹Ÿä¸èƒ½æ¼åˆ¤
    """

    def __init__(self, config: dict):
        self.config = config.get('unattended_detection', {})
        self.idle_threshold = self.config.get('idle_threshold_minutes', 10) * 60  # è½¬ä¸ºç§’
        self.method = self.config.get('method', 'idle_time')
        # å…³é”®é…ç½®: æ£€æµ‹å¤±è´¥æ˜¯å¦è§†ä¸ºæ— äººå€¼å®ˆ
        self.failure_is_unattended = self.config.get(
            'detection_failure_is_unattended', True  # é»˜è®¤ True (å®‰å…¨)
        )

    def is_unattended(self) -> DetectionResult:
        """
        æ£€æµ‹å½“å‰æ˜¯å¦æ— äººå€¼å®ˆ

        Returns:
            DetectionResult: åŒ…å«æ£€æµ‹ç»“æœã€ç½®ä¿¡åº¦å’Œå¯èƒ½çš„é”™è¯¯
        """
        try:
            if self.method == 'idle_time':
                return self._detect_by_idle_time()
            elif self.method == 'explicit_flag':
                return self._detect_by_explicit_flag()
            elif self.method == 'schedule':
                return self._detect_by_schedule()
            else:
                # æœªçŸ¥æ–¹æ³•: æŠ¥é”™å¹¶è¿”å›å®‰å…¨é»˜è®¤å€¼
                return DetectionResult(
                    is_unattended=self.failure_is_unattended,
                    confidence=0.0,
                    detection_method='unknown',
                    error=f"æœªçŸ¥æ£€æµ‹æ–¹æ³•: {self.method}"
                )

        except Exception as e:
            # ä»»ä½•æ£€æµ‹å¼‚å¸¸: è¿”å›å®‰å…¨é»˜è®¤å€¼
            logger.error(f"æ— äººå€¼å®ˆæ£€æµ‹å¤±è´¥: {e}")
            return DetectionResult(
                is_unattended=self.failure_is_unattended,
                confidence=0.0,
                detection_method=self.method,
                error=str(e)
            )

    def _detect_by_idle_time(self) -> DetectionResult:
        """
        é€šè¿‡ç³»ç»Ÿç©ºé—²æ—¶é—´æ£€æµ‹

        ä½¿ç”¨ Windows API GetLastInputInfo è·å–æœ€åè¾“å…¥æ—¶é—´
        """
        try:
            class LASTINPUTINFO(ctypes.Structure):
                _fields_ = [
                    ('cbSize', ctypes.c_uint),
                    ('dwTime', ctypes.c_ulong)
                ]

            lii = LASTINPUTINFO()
            lii.cbSize = ctypes.sizeof(LASTINPUTINFO)

            if not ctypes.windll.user32.GetLastInputInfo(ctypes.byref(lii)):
                # API è°ƒç”¨å¤±è´¥
                raise RuntimeError("GetLastInputInfo è°ƒç”¨å¤±è´¥")

            # è®¡ç®—ç©ºé—²æ—¶é—´
            tick_count = ctypes.windll.kernel32.GetTickCount()
            idle_seconds = (tick_count - lii.dwTime) / 1000.0

            is_idle = idle_seconds > self.idle_threshold

            return DetectionResult(
                is_unattended=is_idle,
                confidence=0.9,  # Windows API é€šå¸¸å¯é 
                detection_method='idle_time',
                error=None
            )

        except Exception as e:
            # æ£€æµ‹å¤±è´¥: è¿”å›å®‰å…¨é»˜è®¤å€¼
            logger.warning(f"ç©ºé—²æ—¶é—´æ£€æµ‹å¤±è´¥: {e}ï¼ŒæŒ‰é…ç½®è¿”å›é»˜è®¤å€¼")
            return DetectionResult(
                is_unattended=self.failure_is_unattended,
                confidence=0.0,
                detection_method='idle_time',
                error=str(e)
            )

    def _detect_by_explicit_flag(self) -> DetectionResult:
        """
        é€šè¿‡æ˜¾å¼æ ‡è®°æ£€æµ‹

        æ£€æŸ¥ data/unattended_mode.flag æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        """
        from pathlib import Path

        flag_file = Path("data/unattended_mode.flag")

        try:
            if flag_file.exists():
                # è¯»å–æ ‡è®°æ–‡ä»¶å†…å®¹ (å¯èƒ½åŒ…å«è®¾ç½®æ—¶é—´)
                content = flag_file.read_text().strip()
                return DetectionResult(
                    is_unattended=True,
                    confidence=1.0,  # æ˜¾å¼æ ‡è®°æœ€å¯é 
                    detection_method='explicit_flag',
                    error=None
                )
            else:
                return DetectionResult(
                    is_unattended=False,
                    confidence=1.0,
                    detection_method='explicit_flag',
                    error=None
                )

        except Exception as e:
            # æ–‡ä»¶è®¿é—®å¤±è´¥: è¿”å›å®‰å…¨é»˜è®¤å€¼
            logger.warning(f"æ ‡è®°æ–‡ä»¶æ£€æµ‹å¤±è´¥: {e}ï¼ŒæŒ‰é…ç½®è¿”å›é»˜è®¤å€¼")
            return DetectionResult(
                is_unattended=self.failure_is_unattended,
                confidence=0.0,
                detection_method='explicit_flag',
                error=str(e)
            )

    def _detect_by_schedule(self) -> DetectionResult:
        """
        é€šè¿‡æ—¶é—´è¡¨æ£€æµ‹

        æ ¹æ®é…ç½®çš„å·¥ä½œæ—¶é—´åˆ¤æ–­æ˜¯å¦æ— äººå€¼å®ˆ
        """
        try:
            schedule = self.config.get('schedule', {})
            work_hours_start = schedule.get('work_hours_start', 9)
            work_hours_end = schedule.get('work_hours_end', 18)
            work_days = schedule.get('work_days', [0, 1, 2, 3, 4])  # å‘¨ä¸€åˆ°å‘¨äº”

            now = datetime.now()
            current_hour = now.hour
            current_weekday = now.weekday()

            # éå·¥ä½œæ—¥ = æ— äººå€¼å®ˆ
            if current_weekday not in work_days:
                return DetectionResult(
                    is_unattended=True,
                    confidence=0.8,
                    detection_method='schedule',
                    error=None
                )

            # éå·¥ä½œæ—¶é—´ = æ— äººå€¼å®ˆ
            if current_hour < work_hours_start or current_hour >= work_hours_end:
                return DetectionResult(
                    is_unattended=True,
                    confidence=0.8,
                    detection_method='schedule',
                    error=None
                )

            # å·¥ä½œæ—¶é—´ = æœ‰äººå€¼å®ˆ
            return DetectionResult(
                is_unattended=False,
                confidence=0.7,  # æ—¶é—´è¡¨ä¸ä¸€å®šå‡†ç¡®
                detection_method='schedule',
                error=None
            )

        except Exception as e:
            # æ£€æµ‹å¤±è´¥: è¿”å›å®‰å…¨é»˜è®¤å€¼
            logger.warning(f"æ—¶é—´è¡¨æ£€æµ‹å¤±è´¥: {e}ï¼ŒæŒ‰é…ç½®è¿”å›é»˜è®¤å€¼")
            return DetectionResult(
                is_unattended=self.failure_is_unattended,
                confidence=0.0,
                detection_method='schedule',
                error=str(e)
            )


# åœ¨ WeChatPublisher ä¸­ä½¿ç”¨
class WeChatPublisher:
    """å¾®ä¿¡å‘å¸ƒå™¨"""

    def __init__(self, config: dict, ...):
        # ...
        self.unattended_detector = UnattendedDetector(config)
        self.gif_unattended_handler = GifUnattendedHandler(config, self.alert_manager)

    def is_unattended_mode(self) -> bool:
        """
        æ£€æµ‹æ˜¯å¦ä¸ºæ— äººå€¼å®ˆæ¨¡å¼

        æ³¨æ„: æ£€æµ‹å¤±è´¥æ—¶é»˜è®¤è¿”å› True (æ— äººå€¼å®ˆ)ï¼Œè¿™æ˜¯ fail-safe è®¾è®¡
        """
        result = self.unattended_detector.is_unattended()

        if result.error:
            logger.warning(
                f"æ— äººå€¼å®ˆæ£€æµ‹å¼‚å¸¸: {result.error}ï¼Œ"
                f"é»˜è®¤è¿”å›: {'æ— äººå€¼å®ˆ' if result.is_unattended else 'æœ‰äººå€¼å®ˆ'}"
            )

        return result.is_unattended
```

> **fail-safe åŸåˆ™è¯´æ˜**:
> - æ£€æµ‹å¤±è´¥ (API è°ƒç”¨å¤±è´¥ã€æ–‡ä»¶è®¿é—®å¤±è´¥ç­‰) æ—¶ï¼Œé»˜è®¤è¿”å›"æ— äººå€¼å®ˆ"
> - è¿™ç¡®ä¿ GIF ä»»åŠ¡åœ¨æ£€æµ‹ä¸ç¡®å®šæ—¶ä¼šè¢«å–æ¶ˆï¼Œè€Œä¸æ˜¯é”™è¯¯å‘é€
> - å¯é€šè¿‡ `detection_failure_is_unattended: false` é…ç½®æ”¹å˜æ­¤è¡Œä¸º (ä¸æ¨è)

**ä¸å‘å¸ƒæµç¨‹é›†æˆ:**

```python
# åœ¨ WeChatPublisher.publish() ä¸­

gif_warnings = gif_handler.check_gif_images(task.images)
if gif_warnings:
    # æ£€æŸ¥æ˜¯å¦æ— äººå€¼å®ˆæ¨¡å¼
    if self.is_unattended_mode():
        # ä½¿ç”¨æ— äººå€¼å®ˆç­–ç•¥å¤„ç†
        result = self.gif_unattended_handler.handle_gif_in_unattended_mode(
            task, gif_warnings
        )

        if result['action'] == 'cancel':
            return {
                'status': 'cancelled',
                'reason': result['reason'],
                'gif_unattended': True
            }
        elif result['action'] == 'queue':
            return {
                'status': 'queued_for_manual',
                'reason': result['reason']
            }
        # action == 'proceed' ç»§ç»­æ‰§è¡Œ

    else:
        # æœ‰äººå€¼å®ˆ: æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
        if not gif_handler.show_gif_warning(task.id, gif_warnings):
            return {'status': 'cancelled', 'reason': 'ç”¨æˆ·å–æ¶ˆ GIF å‘é€'}
```

### 14.2 é¡ºåºä¿è¯

```python
def send_moment_with_images(text: str, image_paths: list):
    """å‘é€å›¾æ–‡æœ‹å‹åœˆ (ä¿è¯å›¾ç‰‡é¡ºåº)"""

    # 1. ç‚¹å‡»ç›¸æœºå›¾æ ‡
    click_element('camera_button')
    wait_random(0.5, 1.0)

    # 2. é€å¼ ä¸Šä¼ å›¾ç‰‡ (ä¿è¯é¡ºåº)
    for i, img_path in enumerate(image_paths):
        # å¤åˆ¶å›¾ç‰‡åˆ°å‰ªè´´æ¿
        copy_image_to_clipboard(img_path)

        # ç²˜è´´
        pyautogui.hotkey('ctrl', 'v')
        wait_random(0.3, 0.6)

        # éªŒè¯å›¾ç‰‡å·²æ·»åŠ  (æ£€æŸ¥é¢„è§ˆåŒºå…ƒç´ æ•°é‡)
        expected_count = i + 1
        actual_count = get_image_preview_count()

        if actual_count != expected_count:
            raise ImageUploadError(f"å›¾ç‰‡ {i+1} ä¸Šä¼ å¤±è´¥, é¢„æœŸ {expected_count} å¼ , å®é™… {actual_count} å¼ ")

        logger.info(f"å›¾ç‰‡ {i+1}/{len(image_paths)} ä¸Šä¼ æˆåŠŸ")

    # 3. è¾“å…¥æ–‡æ¡ˆ
    click_element('text_input')
    safe_paste_text(text)

    # 4. å‘è¡¨
    click_element('publish_button')
```

### 14.3 å›¾ç‰‡æ•°é‡æ£€æµ‹

```python
def get_image_preview_count() -> int:
    """è·å–æœ‹å‹åœˆç¼–è¾‘ç•Œé¢å·²æ·»åŠ çš„å›¾ç‰‡æ•°é‡"""
    preview_container = locator.find('image_preview_container')
    if preview_container:
        # ç»Ÿè®¡å­å…ƒç´ æ•°é‡
        return len(preview_container.GetChildren())
    return 0
```

---

## åäº”ã€éšç§è„±æ•ä¸æ•°æ®ç•™å­˜

### 15.1 è„±æ•ç­–ç•¥

#### 15.1.1 æ•æ„Ÿå­—æ®µå®šä¹‰

| å­—æ®µç±»å‹ | ç¤ºä¾‹ | è„±æ•æ–¹å¼ | é…ç½®å¼€å…³ |
|----------|------|----------|----------|
| **ç¾¤å** | "å®¶åº­ç¾¤" | å‰åå„æ˜¾ç¤º1å­—, ä¸­é—´ç”¨ * | `mask_group_name` |
| **äº§å“å** | "äº‘å—çº¢ç³–" | æ˜¾ç¤ºå‰2å­— + ** | `mask_product_name` |
| **æ–‡æ¡ˆå†…å®¹** | "ä»Šæ—¥ç‰¹ä»·..." | æˆªæ–­å‰20å­— + ... | `truncate_content` |
| **æ‰‹æœºå·** | 13812345678 | 138****5678 | `mask_phone` |
| **å¾®ä¿¡ID** | wxid_abc123 | wxid_***123 | `mask_wechat_id` |

#### 15.1.2 è„±æ•é…ç½®

**ç”Ÿäº§ç¯å¢ƒé»˜è®¤å€¼ (å¼ºåˆ¶ç”Ÿæ•ˆ):**

| é…ç½®é¡¹ | ç”Ÿäº§é»˜è®¤ | å¼€å‘é»˜è®¤ | è¯´æ˜ |
|--------|----------|----------|------|
| `enabled` | `true` | `false` | æ€»å¼€å…³ |
| `mask_group_name` | `true` | `false` | ç¾¤åè„±æ• |
| `mask_product_name` | `true` | `false` | äº§å“åè„±æ• |
| `truncate_content` | `true` | `false` | æ–‡æ¡ˆæˆªæ–­ |
| `mask_phone` | `true` | `true` | æ‰‹æœºå·å§‹ç»ˆè„±æ• |
| `mask_wechat_id` | `true` | `true` | å¾®ä¿¡IDå§‹ç»ˆè„±æ• |

> **é‡è¦**: æ‰‹æœºå·å’Œå¾®ä¿¡IDåœ¨ä»»ä½•ç¯å¢ƒä¸‹éƒ½é»˜è®¤è„±æ•ï¼Œä¸å¯å…³é—­ã€‚

```yaml
# config.yaml
privacy:
  # è„±æ•å¼€å…³ (ç”Ÿäº§ç¯å¢ƒå¼ºåˆ¶ true)
  enabled: true

  # å„å­—æ®µè„±æ•è®¾ç½® (ç”Ÿäº§ç¯å¢ƒé»˜è®¤å€¼)
  mask_group_name: true       # ç¾¤åè„±æ• (ç”Ÿäº§é»˜è®¤å¼€)
  mask_product_name: true     # äº§å“åè„±æ• (ç”Ÿäº§é»˜è®¤å¼€)
  truncate_content: true      # æ–‡æ¡ˆæˆªæ–­ (ç”Ÿäº§é»˜è®¤å¼€)
  truncate_length: 20         # æˆªæ–­é•¿åº¦
  mask_phone: true            # æ‰‹æœºå·è„±æ• (ä¸å¯å…³é—­)
  mask_wechat_id: true        # å¾®ä¿¡IDè„±æ• (ä¸å¯å…³é—­)

  # è„±æ•èŒƒå›´ (æ˜ç¡®æ¯ä¸ªè¾“å‡ºæ¸ é“çš„é»˜è®¤å€¼)
  apply_to:
    logs: true                # æ—¥å¿—æ–‡ä»¶ (é»˜è®¤å¼€)
    notifications: true       # æ‰˜ç›˜é€šçŸ¥ (é»˜è®¤å¼€)
    emails: true              # é‚®ä»¶é€šçŸ¥ (é»˜è®¤å¼€)
    receipts: false           # å›æ‰§æ–‡ä»¶ - è§ä¸‹æ–¹åŒç‰ˆæœ¬ç­–ç•¥
    ui_display: false         # UIæ˜¾ç¤º (æ“ä½œè€…éœ€çœ‹åˆ°å®Œæ•´ä¿¡æ¯)
```

#### 15.1.3 å›æ‰§æ–‡ä»¶åŒç‰ˆæœ¬ç­–ç•¥

å›æ‰§æ–‡ä»¶éœ€è¦ä¿ç•™å®Œæ•´ä¿¡æ¯ç”¨äºå¯¹è´¦å’Œå®¡è®¡ï¼Œä½†åˆ†å‘æ—¶éœ€è¦è„±æ•ç‰ˆæœ¬ã€‚

**åŒç‰ˆæœ¬æœºåˆ¶:**

```python
# services/receipt_manager.py

from dataclasses import dataclass
from pathlib import Path

@dataclass
class ReceiptVersions:
    """å›æ‰§åŒç‰ˆæœ¬"""
    full_path: Path       # å®Œæ•´ç‰ˆè·¯å¾„ (ä»…æœ¬åœ°å­˜å‚¨)
    masked_path: Path     # è„±æ•ç‰ˆè·¯å¾„ (å¯å‘é€/å½’æ¡£)

class ReceiptManager:
    """å›æ‰§ç®¡ç†å™¨ - æ”¯æŒåŒç‰ˆæœ¬"""

    def __init__(self, config: dict, masker: PrivacyMasker):
        self.config = config
        self.masker = masker
        self.receipt_dir = Path(config.get('receipt_dir', 'receipts'))
        self.keep_full_version = config.get('keep_full_version', True)

    def generate_receipt(self, task, execution_result) -> ReceiptVersions:
        """
        ç”Ÿæˆå›æ‰§ (å®Œæ•´ç‰ˆ + è„±æ•ç‰ˆ)

        å­˜å‚¨ç»“æ„:
        receipts/
        |-- 2024-11-25/
        |   |-- task_001_full.json      # å®Œæ•´ç‰ˆ (ä»…æœ¬åœ°)
        |   |-- task_001_masked.json    # è„±æ•ç‰ˆ (å¯åˆ†å‘)
        """
        date_str = task.scheduled_time.strftime('%Y-%m-%d')
        task_dir = self.receipt_dir / date_str
        task_dir.mkdir(parents=True, exist_ok=True)

        # 1. ç”Ÿæˆå®Œæ•´ç‰ˆæ•°æ®
        full_data = {
            'task_id': task.id,
            'content_code': task.content_code,
            'product_name': task.product_name,
            'group_name': task.group_name,
            'content': task.content,
            'channel': task.channel,
            'scheduled_time': task.scheduled_time.isoformat(),
            'executed_time': execution_result.executed_time.isoformat(),  # ç»Ÿä¸€ä½¿ç”¨ executed_time
            'status': execution_result.status,
            'error_message': execution_result.error_message,
            'screenshot_path': str(execution_result.screenshot_path) if execution_result.screenshot_path else None,
        }

        # 2. ç”Ÿæˆè„±æ•ç‰ˆæ•°æ®
        masked_data = {
            'task_id': task.id,
            'content_code': task.content_code,
            'product_name': self.masker.mask_product_name(task.product_name),
            'group_name': self.masker.mask_group_name(task.group_name) if task.group_name else None,
            'content': self.masker.truncate_content(task.content),
            'channel': task.channel,
            'scheduled_time': task.scheduled_time.isoformat(),
            'executed_time': execution_result.executed_time.isoformat(),  # ç»Ÿä¸€ä½¿ç”¨ executed_time
            'status': execution_result.status,
            'error_message': execution_result.error_message,
            # æˆªå›¾è·¯å¾„ä¸åŒ…å«åœ¨è„±æ•ç‰ˆä¸­
        }

        # 3. å†™å…¥æ–‡ä»¶
        full_path = task_dir / f"task_{task.id}_full.json"
        masked_path = task_dir / f"task_{task.id}_masked.json"

        if self.keep_full_version:
            with open(full_path, 'w', encoding='utf-8') as f:
                json.dump(full_data, f, ensure_ascii=False, indent=2)

        with open(masked_path, 'w', encoding='utf-8') as f:
            json.dump(masked_data, f, ensure_ascii=False, indent=2)

        logger.info(f"å›æ‰§ç”Ÿæˆå®Œæˆ: {task.id}, å®Œæ•´ç‰ˆ: {self.keep_full_version}")

        return ReceiptVersions(
            full_path=full_path if self.keep_full_version else None,
            masked_path=masked_path
        )

    def get_receipt_for_email(self, task_id: int) -> Path:
        """è·å–ç”¨äºé‚®ä»¶å‘é€çš„å›æ‰§ (å§‹ç»ˆè¿”å›è„±æ•ç‰ˆ)"""
        # ... æŸ¥æ‰¾è„±æ•ç‰ˆæ–‡ä»¶
        return self._find_masked_receipt(task_id)

    def get_receipt_for_audit(self, task_id: int) -> Path:
        """è·å–ç”¨äºå®¡è®¡çš„å›æ‰§ (è¿”å›å®Œæ•´ç‰ˆ, éœ€æƒé™éªŒè¯)"""
        # ... æŸ¥æ‰¾å®Œæ•´ç‰ˆæ–‡ä»¶
        return self._find_full_receipt(task_id)
```

**é…ç½®:**

```yaml
privacy:
  receipts:
    keep_full_version: true       # ä¿ç•™å®Œæ•´ç‰ˆ (æœ¬åœ°å­˜å‚¨)
    full_version_retention: 90    # å®Œæ•´ç‰ˆç•™å­˜å¤©æ•°
    masked_version_retention: 30  # è„±æ•ç‰ˆç•™å­˜å¤©æ•°

    # å®Œæ•´ç‰ˆè®¿é—®æ§åˆ¶
    full_version_access:
      require_password: true      # è®¿é—®å®Œæ•´ç‰ˆéœ€è¦å¯†ç 
      allowed_operations:
        - view                    # å…è®¸æŸ¥çœ‹
        - export                  # å…è®¸å¯¼å‡º (éœ€äºŒæ¬¡ç¡®è®¤)
```

**Masked ç‰ˆæœ¬å­—æ®µæ¸…å•:**

| å­—æ®µ | æ˜¯å¦åŒ…å« | å¤„ç†æ–¹å¼ | è¯´æ˜ |
|------|----------|----------|------|
| `task_id` | åŒ…å« | åŸå€¼ | ä»»åŠ¡æ ‡è¯†ï¼Œç”¨äºå…³è” |
| `content_code` | åŒ…å« | åŸå€¼ | å†…å®¹ç¼–ç ï¼Œç”¨äºå¯¹è´¦ |
| `product_name` | åŒ…å« | è„±æ• | å¦‚ "äº‘å—çº¢ç³–" â†’ "äº‘å—**" |
| `group_name` | åŒ…å« | è„±æ• | å¦‚ "å®¶åº­ç¾¤" â†’ "å®¶*ç¾¤" |
| `content` | åŒ…å« | æˆªæ–­ | ä»…ä¿ç•™å‰100å­—ç¬¦ |
| `channel` | åŒ…å« | åŸå€¼ | å‘å¸ƒæ¸ é“ |
| `scheduled_time` | åŒ…å« | åŸå€¼ | æ’æœŸæ—¶é—´ |
| `executed_time` | åŒ…å« | åŸå€¼ | å®é™…æ‰§è¡Œæ—¶é—´ |
| `status` | åŒ…å« | åŸå€¼ | æ‰§è¡ŒçŠ¶æ€ |
| `error_message` | åŒ…å« | åŸå€¼ | é”™è¯¯ä¿¡æ¯ |
| `screenshot_path` | **ä¸åŒ…å«** | æ’é™¤ | æˆªå›¾å¯èƒ½å«æ•æ„Ÿä¿¡æ¯ |
| `image_paths` | **ä¸åŒ…å«** | æ’é™¤ | å›¾ç‰‡è·¯å¾„ä¸æš´éœ² |
| `phone` | **ä¸åŒ…å«** | æ’é™¤ | æ•æ„Ÿä¿¡æ¯ä¸å…¥ masked ç‰ˆ |
| `wechat_id` | **ä¸åŒ…å«** | æ’é™¤ | æ•æ„Ÿä¿¡æ¯ä¸å…¥ masked ç‰ˆ |

**è®¿é—®æ§åˆ¶é»˜è®¤å€¼:**

| é…ç½®é¡¹ | ç”Ÿäº§ç¯å¢ƒé»˜è®¤ | å¼€å‘ç¯å¢ƒé»˜è®¤ | è¯´æ˜ |
|--------|--------------|--------------|------|
| `keep_full_version` | `true` | `true` | æ˜¯å¦ä¿ç•™å®Œæ•´ç‰ˆ |
| `full_version_retention` | `90` å¤© | `30` å¤© | å®Œæ•´ç‰ˆç•™å­˜æœŸ |
| `masked_version_retention` | `30` å¤© | `7` å¤© | è„±æ•ç‰ˆç•™å­˜æœŸ |
| `require_password` | `true` | `false` | è®¿é—®å®Œæ•´ç‰ˆæ˜¯å¦éœ€å¯†ç  |
| `allowed_operations` | `['view']` | `['view', 'export']` | å…è®¸çš„æ“ä½œ |

```python
# é»˜è®¤å€¼åŠ è½½é€»è¾‘
def get_privacy_defaults(env: str) -> dict:
    """æ ¹æ®ç¯å¢ƒè·å–éšç§é…ç½®é»˜è®¤å€¼"""
    if env == 'production':
        return {
            'receipts': {
                'keep_full_version': True,
                'full_version_retention': 90,
                'masked_version_retention': 30,
                'full_version_access': {
                    'require_password': True,
                    'allowed_operations': ['view']  # ç”Ÿäº§ç¯å¢ƒé»˜è®¤ä»…æŸ¥çœ‹
                }
            }
        }
    else:  # development / test
        return {
            'receipts': {
                'keep_full_version': True,
                'full_version_retention': 30,
                'masked_version_retention': 7,
                'full_version_access': {
                    'require_password': False,
                    'allowed_operations': ['view', 'export']
                }
            }
        }
```

#### 15.1.4 è„±æ•å·¥å…·ç±»

```python
# services/privacy_mask.py

import re

class PrivacyMasker:
    """éšç§è„±æ•å·¥å…·"""

    def __init__(self, config: dict):
        self.config = config
        self.enabled = config.get('enabled', True)

    def mask_group_name(self, name: str) -> str:
        """ç¾¤åè„±æ•: å®¶åº­ç¾¤ -> å®¶*ç¾¤"""
        if not self.enabled or not self.config.get('mask_group_name', True):
            return name
        if not name or len(name) <= 2:
            return name
        return name[0] + '*' * (len(name) - 2) + name[-1]

    def mask_product_name(self, name: str) -> str:
        """äº§å“åè„±æ•: äº‘å—çº¢ç³– -> äº‘å—**"""
        if not self.enabled or not self.config.get('mask_product_name', False):
            return name
        if not name or len(name) <= 2:
            return name
        return name[:2] + '*' * (len(name) - 2)

    def truncate_content(self, content: str) -> str:
        """æ–‡æ¡ˆæˆªæ–­"""
        if not self.enabled or not self.config.get('truncate_content', True):
            return content
        max_len = self.config.get('truncate_length', 20)
        if len(content) <= max_len:
            return content
        return content[:max_len] + '...'

    def mask_phone(self, phone: str) -> str:
        """æ‰‹æœºå·è„±æ•: 13812345678 -> 138****5678"""
        if not self.enabled or not self.config.get('mask_phone', True):
            return phone
        return re.sub(r'(\d{3})\d{4}(\d{4})', r'\1****\2', phone)

    def mask_wechat_id(self, wxid: str) -> str:
        """å¾®ä¿¡IDè„±æ•: wxid_abc123 -> wxid_***123"""
        if not self.enabled or not self.config.get('mask_wechat_id', True):
            return wxid
        if not wxid or len(wxid) <= 6:
            return wxid
        return wxid[:5] + '***' + wxid[-3:]

    def mask_for_log(self, task) -> dict:
        """ä¸ºæ—¥å¿—è¾“å‡ºè„±æ•ä»»åŠ¡ä¿¡æ¯"""
        return {
            'task_id': task.id,
            'product': self.mask_product_name(task.product_name),
            'group': self.mask_group_name(task.group_name) if task.group_name else None,
            'content': self.truncate_content(task.content),
            'status': task.status
        }

    def mask_for_notification(self, message: str, context: dict) -> str:
        """ä¸ºé€šçŸ¥è„±æ•æ¶ˆæ¯"""
        result = message
        if context.get('group_name'):
            result = result.replace(
                context['group_name'],
                self.mask_group_name(context['group_name'])
            )
        if context.get('product_name'):
            result = result.replace(
                context['product_name'],
                self.mask_product_name(context['product_name'])
            )
        return result


# å…¨å±€å®ä¾‹
masker = PrivacyMasker(config.get('privacy', {}))
```

### 15.2 æ•°æ®ç•™å­˜ç­–ç•¥

#### 15.2.1 ç•™å­˜å‘¨æœŸ

| æ•°æ®ç±»å‹ | é»˜è®¤ç•™å­˜ | å¯é…ç½®èŒƒå›´ | æ¸…ç†æ–¹å¼ | è¯´æ˜ |
|----------|----------|------------|----------|------|
| **è¿è¡Œæ—¥å¿—** | 90 å¤© | 7-365 å¤© | æŒ‰æ—¥æœŸåˆ é™¤ | ä¸ 15.10.1 å†³ç­–çŸ©é˜µä¸€è‡´ |
| **ä»»åŠ¡è®°å½• (ä¸»åº“)** | 90 å¤© | 30-365 å¤© | å½’æ¡£åˆ° archive.db | è¶…è¿‡ç•™å­˜æœŸçš„ä»»åŠ¡ç§»è‡³å½’æ¡£åº“ |
| **ä»»åŠ¡å½’æ¡£ (å½’æ¡£åº“)** | æ°¸ä¹… | - | ä¸æ¸…ç† | archive.db æ°¸ä¹…ä¿ç•™å®Œæ•´å†å² |
| **å›æ‰§æ–‡ä»¶ (å®Œæ•´ç‰ˆ)** | 365 å¤© | 90-730 å¤© | ç§»åŠ¨åˆ°å½’æ¡£ | éœ€å®¡è®¡æ—¶å‚è€ƒ |
| **å›æ‰§æ–‡ä»¶ (è„±æ•ç‰ˆ)** | 365 å¤© | 90-730 å¤© | åˆ é™¤æ–‡ä»¶ | æ—¥å¸¸æŸ¥é˜…ä½¿ç”¨ |
| **æœ¬åœ°ç¼“å­˜** | 7 å¤© | 1-30 å¤© | åˆ é™¤æ–‡ä»¶ | ä¸´æ—¶å¤„ç†æ•°æ® |
| **æˆªå›¾è¯æ®** | 30 å¤© | 7-90 å¤© | åˆ é™¤æ–‡ä»¶ | ä¸ 15.10.1 å†³ç­–çŸ©é˜µä¸€è‡´ |

#### 15.2.2 ç•™å­˜é…ç½®

```yaml
# config.yaml
# æ³¨æ„: ç•™å­˜å‘¨æœŸéœ€ä¸ 15.10.1 å†³ç­–çŸ©é˜µä¿æŒä¸€è‡´
retention:
  logs:
    days: 90                   # é»˜è®¤ 90 å¤© (ä¸å†³ç­–çŸ©é˜µä¸€è‡´)
    compress_after: 7          # 7å¤©åå‹ç¼©å½’æ¡£

  tasks:
    days: 90                   # ä¸»åº“ä¿ç•™ 90 å¤©
    archive_to: "archive.db"   # å½’æ¡£åˆ°å•ç‹¬æ•°æ®åº“
    archive_retention: -1      # å½’æ¡£åº“æ°¸ä¹…ä¿ç•™ (-1 è¡¨ç¤ºæ°¸ä¹…)

  receipts:
    full_days: 365             # å®Œæ•´ç‰ˆ 365 å¤©
    masked_days: 365           # è„±æ•ç‰ˆ 365 å¤©

  cache:
    days: 7
    max_size_mb: 500           # æ€»å®¹é‡é™åˆ¶

  screenshots:
    days: 30                   # é»˜è®¤ 30 å¤© (ä¸å†³ç­–çŸ©é˜µä¸€è‡´)
    enabled: true              # æ˜¯å¦ä¿å­˜æˆªå›¾è¯æ®
```

#### 15.2.3 è‡ªåŠ¨æ¸…ç†ä»»åŠ¡

```python
# services/retention_cleaner.py

from apscheduler.schedulers.background import BackgroundScheduler

class RetentionCleaner:
    """æ•°æ®ç•™å­˜æ¸…ç†å™¨"""

    def __init__(self, config: dict):
        self.config = config
        self.scheduler = BackgroundScheduler()

    def start(self):
        """å¯åŠ¨å®šæ—¶æ¸…ç†ä»»åŠ¡ (æ¯å¤©å‡Œæ™¨3ç‚¹)"""
        self.scheduler.add_job(
            self.cleanup_all,
            'cron',
            hour=3,
            minute=0
        )
        self.scheduler.start()

    def cleanup_all(self):
        """æ‰§è¡Œå…¨éƒ¨æ¸…ç†"""
        logger.info("å¼€å§‹æ‰§è¡Œæ•°æ®ç•™å­˜æ¸…ç†...")

        self.cleanup_logs()
        self.cleanup_receipts()
        self.cleanup_cache()
        self.cleanup_screenshots()
        self.archive_old_tasks()

        logger.info("æ•°æ®ç•™å­˜æ¸…ç†å®Œæˆ")

    def cleanup_logs(self):
        """æ¸…ç†è¿‡æœŸæ—¥å¿—"""
        # é»˜è®¤ 90 å¤©ï¼Œä¸ 15.2.1 ç•™å­˜å‘¨æœŸè¡¨å’Œ 15.10.1 å†³ç­–çŸ©é˜µä¸€è‡´
        retention_days = self.config.get('logs', {}).get('days', 90)
        compress_after = self.config.get('logs', {}).get('compress_after', 7)

        log_dir = 'logs'
        cutoff_date = datetime.now() - timedelta(days=retention_days)
        compress_date = datetime.now() - timedelta(days=compress_after)

        for filename in os.listdir(log_dir):
            filepath = os.path.join(log_dir, filename)
            file_date = self._parse_log_date(filename)

            if file_date:
                if file_date < cutoff_date:
                    os.remove(filepath)
                    logger.info(f"åˆ é™¤è¿‡æœŸæ—¥å¿—: {filename}")
                elif file_date < compress_date and not filename.endswith('.gz'):
                    self._compress_file(filepath)

    def archive_old_tasks(self):
        """å½’æ¡£æ—§ä»»åŠ¡"""
        retention_days = self.config.get('tasks', {}).get('days', 90)
        cutoff_date = datetime.now() - timedelta(days=retention_days)

        # ç§»åŠ¨åˆ°å½’æ¡£æ•°æ®åº“
        old_tasks = db.query(
            "SELECT * FROM tasks WHERE created_at < ?",
            [cutoff_date]
        )

        if old_tasks:
            archive_db = self.config.get('tasks', {}).get('archive_to', 'archive.db')
            # ... å½’æ¡£é€»è¾‘
            logger.info(f"å½’æ¡£ {len(old_tasks)} æ¡æ—§ä»»åŠ¡")
```

### 15.3 ä»»åŠ¡å½’æ¡£è¯¦ç»†ç­–ç•¥

#### 15.3.1 å½’æ¡£è¡¨ç»“æ„

å½’æ¡£æ•°æ®åº“ä¸ä¸»æ•°æ®åº“ç»“æ„ä¸€è‡´ï¼Œå¢åŠ å½’æ¡£å…ƒæ•°æ®ï¼š

```sql
-- archive.db è¡¨ç»“æ„

-- ä»»åŠ¡å½’æ¡£è¡¨ (å®Œæ•´é•œåƒ tasks è¡¨ + å½’æ¡£å…ƒæ•°æ®)
-- æ³¨æ„: æ­¤è¡¨å®Œæ•´å¤åˆ¶ tasks è¡¨æ‰€æœ‰å­—æ®µï¼Œç¡®ä¿å†å²æ•°æ®å¯å®Œæ•´è¿½æº¯
CREATE TABLE archived_tasks (
    id INTEGER PRIMARY KEY,
    content_code TEXT NOT NULL,
    channel TEXT NOT NULL,
    product_name TEXT,
    group_name TEXT,
    content TEXT,
    images TEXT,                          -- JSON æ•°ç»„
    scheduled_time DATETIME,
    scheduled_date TEXT,                  -- æ’æœŸæ—¥æœŸ (ä» tasks è¡¨å¤åˆ¶)
    executed_time DATETIME,               -- å®é™…æ‰§è¡Œæ—¶é—´ (ä¸ tasks è¡¨ä¸€è‡´)
    status TEXT NOT NULL,
    error_message TEXT,
    screenshot_path TEXT,                 -- æˆªå›¾è·¯å¾„
    retry_count INTEGER DEFAULT 0,
    max_retry INTEGER DEFAULT 3,
    reschedule_count INTEGER DEFAULT 0,
    priority INTEGER DEFAULT 5,
    failure_reason TEXT,
    pause_reason TEXT,
    pause_detail TEXT,
    skip_reason TEXT,
    note TEXT,
    paused_at DATETIME,
    created_at DATETIME NOT NULL,
    updated_at DATETIME,

    -- å½’æ¡£å…ƒæ•°æ®
    archived_at DATETIME NOT NULL,        -- å½’æ¡£æ—¶é—´
    archive_batch TEXT NOT NULL,          -- å½’æ¡£æ‰¹æ¬¡å·
    original_db_path TEXT,                -- åŸæ•°æ®åº“è·¯å¾„
    archive_reason TEXT                   -- å½’æ¡£åŸå›  (expired/manual/cleanup)
);

-- å½’æ¡£æ‰¹æ¬¡è¡¨
CREATE TABLE archive_batches (
    batch_id TEXT PRIMARY KEY,
    archived_at DATETIME NOT NULL,
    task_count INTEGER,
    date_range_start DATETIME,
    date_range_end DATETIME,
    archive_reason TEXT,
    checksum TEXT                         -- æ•°æ®å®Œæ•´æ€§æ ¡éªŒ
);

-- ç´¢å¼•
CREATE INDEX idx_archived_tasks_content_code ON archived_tasks(content_code);
CREATE INDEX idx_archived_tasks_scheduled_time ON archived_tasks(scheduled_time);
CREATE INDEX idx_archived_tasks_batch ON archived_tasks(archive_batch);
CREATE INDEX idx_archived_tasks_group ON archived_tasks(group_name);
```

#### 15.3.2 å½’æ¡£æµç¨‹å®ç°

```python
# services/task_archiver.py

import sqlite3
import hashlib
import json
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional

# å½’æ¡£æ•°æ®åº“ Schema (ä¸ 15.3.1 å®šä¹‰çš„ archived_tasks è¡¨ç»“æ„ä¸€è‡´)
# æ³¨æ„: å½’æ¡£è¡¨å®Œæ•´é•œåƒ tasks è¡¨å­—æ®µï¼Œç¡®ä¿å†å²æ•°æ®å®Œæ•´å¯æŸ¥
ARCHIVE_SCHEMA = """
-- ä»»åŠ¡å½’æ¡£è¡¨ (å®Œæ•´é•œåƒ tasks è¡¨ + å½’æ¡£å…ƒæ•°æ®)
CREATE TABLE IF NOT EXISTS archived_tasks (
    id INTEGER PRIMARY KEY,
    content_code TEXT NOT NULL,
    channel TEXT NOT NULL,
    product_name TEXT,
    group_name TEXT,
    content TEXT,
    images TEXT,                              -- JSON æ•°ç»„
    scheduled_time DATETIME,
    scheduled_date TEXT,                      -- æ’æœŸæ—¥æœŸ (ä» tasks è¡¨å¤åˆ¶)
    executed_time DATETIME,                   -- å®é™…æ‰§è¡Œæ—¶é—´ (ä¸ tasks è¡¨ä¸€è‡´)
    status TEXT NOT NULL,
    error_message TEXT,
    screenshot_path TEXT,
    retry_count INTEGER DEFAULT 0,
    max_retry INTEGER DEFAULT 3,
    reschedule_count INTEGER DEFAULT 0,
    priority INTEGER DEFAULT 5,
    failure_reason TEXT,
    pause_reason TEXT,
    pause_detail TEXT,
    skip_reason TEXT,
    note TEXT,
    paused_at DATETIME,
    created_at DATETIME NOT NULL,
    updated_at DATETIME,
    -- å½’æ¡£å…ƒæ•°æ®
    archived_at DATETIME NOT NULL,
    archive_batch TEXT NOT NULL,
    original_db_path TEXT,
    archive_reason TEXT
);

-- å½’æ¡£æ‰¹æ¬¡è¡¨
CREATE TABLE IF NOT EXISTS archive_batches (
    batch_id TEXT PRIMARY KEY,
    archived_at DATETIME NOT NULL,
    task_count INTEGER NOT NULL,
    date_range_start TEXT,
    date_range_end TEXT,
    archive_reason TEXT,
    checksum TEXT
);

-- ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_archived_tasks_content_code ON archived_tasks(content_code);
CREATE INDEX IF NOT EXISTS idx_archived_tasks_scheduled_time ON archived_tasks(scheduled_time);
CREATE INDEX IF NOT EXISTS idx_archived_tasks_batch ON archived_tasks(archive_batch);
CREATE INDEX IF NOT EXISTS idx_archived_tasks_group ON archived_tasks(group_name);
"""

class TaskArchiver:
    """ä»»åŠ¡å½’æ¡£å™¨"""

    def __init__(self, config: dict):
        self.config = config
        self.main_db_path = config.get('main_db', 'data/tasks.db')
        self.archive_db_path = config.get('archive_db', 'data/archive.db')
        self.retention_days = config.get('retention_days', 90)

    def archive_expired_tasks(self) -> dict:
        """
        å½’æ¡£è¿‡æœŸä»»åŠ¡

        Returns:
            {'batch_id': str, 'count': int, 'date_range': tuple}
        """
        cutoff_date = datetime.now() - timedelta(days=self.retention_days)

        # 1. æŸ¥è¯¢å¾…å½’æ¡£ä»»åŠ¡
        with sqlite3.connect(self.main_db_path) as main_db:
            main_db.row_factory = sqlite3.Row
            tasks = main_db.execute(
                """SELECT * FROM tasks
                   WHERE created_at < ?
                   AND status IN ('success', 'failed', 'cancelled', 'skipped')""",
                [cutoff_date.isoformat()]
            ).fetchall()

        if not tasks:
            logger.info("æ— ä»»åŠ¡éœ€è¦å½’æ¡£")
            return {'batch_id': None, 'count': 0}

        # 2. ç”Ÿæˆæ‰¹æ¬¡å·
        batch_id = f"ARCHIVE_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

        # 3. å†™å…¥å½’æ¡£æ•°æ®åº“
        self._ensure_archive_db()

        with sqlite3.connect(self.archive_db_path) as archive_db:
            for task in tasks:
                task_dict = dict(task)
                task_dict['archived_at'] = datetime.now().isoformat()
                task_dict['archive_batch'] = batch_id
                task_dict['original_db_path'] = str(self.main_db_path)
                task_dict['archive_reason'] = 'expired'

                # æ’å…¥å½’æ¡£
                columns = ', '.join(task_dict.keys())
                placeholders = ', '.join(['?' for _ in task_dict])
                archive_db.execute(
                    f"INSERT INTO archived_tasks ({columns}) VALUES ({placeholders})",
                    list(task_dict.values())
                )

            # 4. è®°å½•æ‰¹æ¬¡
            date_range = self._get_date_range(tasks)
            checksum = self._calculate_batch_checksum(tasks)

            archive_db.execute(
                """INSERT INTO archive_batches
                   (batch_id, archived_at, task_count, date_range_start, date_range_end, archive_reason, checksum)
                   VALUES (?, ?, ?, ?, ?, ?, ?)""",
                [batch_id, datetime.now().isoformat(), len(tasks),
                 date_range[0], date_range[1], 'expired', checksum]
            )
            archive_db.commit()

        # 5. ä»ä¸»åº“åˆ é™¤
        with sqlite3.connect(self.main_db_path) as main_db:
            task_ids = [t['id'] for t in tasks]
            placeholders = ','.join(['?' for _ in task_ids])
            main_db.execute(
                f"DELETE FROM tasks WHERE id IN ({placeholders})",
                task_ids
            )
            main_db.commit()

        logger.info(f"å½’æ¡£å®Œæˆ: æ‰¹æ¬¡ {batch_id}, ä»»åŠ¡æ•° {len(tasks)}")

        return {
            'batch_id': batch_id,
            'count': len(tasks),
            'date_range': date_range
        }

    def _calculate_batch_checksum(self, tasks: list) -> str:
        """è®¡ç®—æ‰¹æ¬¡æ•°æ®æ ¡éªŒå’Œ"""
        data = json.dumps([dict(t) for t in tasks], sort_keys=True)
        return hashlib.sha256(data.encode()).hexdigest()

    def _get_date_range(self, tasks: list) -> tuple:
        """è·å–ä»»åŠ¡æ—¶é—´èŒƒå›´"""
        dates = [t['created_at'] for t in tasks if t['created_at']]
        return (min(dates), max(dates)) if dates else (None, None)

    def _ensure_archive_db(self):
        """ç¡®ä¿å½’æ¡£æ•°æ®åº“å­˜åœ¨"""
        if not Path(self.archive_db_path).exists():
            with sqlite3.connect(self.archive_db_path) as db:
                db.executescript(ARCHIVE_SCHEMA)  # ä¸Šé¢å®šä¹‰çš„ SQL
```

### 15.4 è¯æ®ä¿å…¨ç­–ç•¥

æŸäº›åœºæ™¯ä¸‹éœ€è¦ä¿ç•™å®Œæ•´æ‰§è¡Œè®°å½•ä½œä¸ºè¯æ®ï¼ˆå¦‚å•†ä¸šçº çº·ã€å®¡è®¡ç­‰ï¼‰ï¼Œè¿™äº›æ•°æ®ä¸åº”è¢«è‡ªåŠ¨æ¸…ç†ã€‚

#### 15.4.1 è¯æ®ä¿å…¨æ ‡è®°

```python
# models/evidence.py

from enum import Enum

class EvidenceLevel(Enum):
    """è¯æ®ä¿å…¨çº§åˆ«"""
    NONE = "none"                 # æ— ä¿å…¨ï¼Œæ­£å¸¸æ¸…ç†
    STANDARD = "standard"         # æ ‡å‡†ä¿å…¨ï¼Œå»¶é•¿ç•™å­˜
    LEGAL_HOLD = "legal_hold"     # æ³•å¾‹ä¿å…¨ï¼Œç¦æ­¢åˆ é™¤

@dataclass
class EvidenceMarker:
    """è¯æ®ä¿å…¨æ ‡è®°"""
    task_id: int
    level: EvidenceLevel
    reason: str                   # ä¿å…¨åŸå› 
    marked_by: str                # æ ‡è®°äºº
    marked_at: datetime
    expires_at: Optional[datetime]  # ä¿å…¨åˆ°æœŸæ—¶é—´ (æ³•å¾‹ä¿å…¨æ— æœŸé™)
    related_case: Optional[str]   # å…³è”æ¡ˆä»¶å·
```

#### 15.4.2 è¯æ®ä¿å…¨å½±å“

| ä¿å…¨çº§åˆ« | ä»»åŠ¡è®°å½• | æˆªå›¾ | å›æ‰§ | æ—¥å¿— | è‡ªåŠ¨æ¸…ç† |
|----------|----------|------|------|------|----------|
| NONE | 90å¤© | 7å¤© | 30å¤© | 30å¤© | å…è®¸ |
| STANDARD | 1å¹´ | 90å¤© | 1å¹´ | 90å¤© | å»¶æœŸ |
| LEGAL_HOLD | æ°¸ä¹… | æ°¸ä¹… | æ°¸ä¹… | æ°¸ä¹… | ç¦æ­¢ |

#### 15.4.3 è¯æ®ä¿å…¨ç®¡ç†å™¨

```python
# services/evidence_manager.py

class EvidenceManager:
    """è¯æ®ä¿å…¨ç®¡ç†å™¨"""

    def __init__(self, config: dict):
        self.config = config

    def mark_for_preservation(self, task_ids: list, level: EvidenceLevel,
                               reason: str, marked_by: str,
                               expires_at: datetime = None,
                               related_case: str = None) -> int:
        """
        æ ‡è®°ä»»åŠ¡ä¸ºè¯æ®ä¿å…¨

        Args:
            task_ids: ä»»åŠ¡IDåˆ—è¡¨
            level: ä¿å…¨çº§åˆ«
            reason: ä¿å…¨åŸå› 
            marked_by: æ“ä½œäºº
            expires_at: åˆ°æœŸæ—¶é—´ (LEGAL_HOLD æ—¶å¿½ç•¥)
            related_case: å…³è”æ¡ˆä»¶

        Returns:
            æ ‡è®°æˆåŠŸçš„ä»»åŠ¡æ•°
        """
        if level == EvidenceLevel.LEGAL_HOLD:
            expires_at = None  # æ³•å¾‹ä¿å…¨æ— åˆ°æœŸæ—¶é—´

        count = 0
        for task_id in task_ids:
            marker = EvidenceMarker(
                task_id=task_id,
                level=level,
                reason=reason,
                marked_by=marked_by,
                marked_at=datetime.now(),
                expires_at=expires_at,
                related_case=related_case
            )

            db.execute(
                """INSERT OR REPLACE INTO evidence_markers
                   (task_id, level, reason, marked_by, marked_at, expires_at, related_case)
                   VALUES (?, ?, ?, ?, ?, ?, ?)""",
                [task_id, level.value, reason, marked_by,
                 marker.marked_at, expires_at, related_case]
            )
            count += 1

            logger.info(f"ä»»åŠ¡ {task_id} å·²æ ‡è®°ä¸º {level.value} ä¿å…¨")

        return count

    def is_protected(self, task_id: int) -> tuple[bool, EvidenceLevel]:
        """æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å—ä¿æŠ¤"""
        marker = db.query_one(
            "SELECT * FROM evidence_markers WHERE task_id = ?",
            [task_id]
        )

        if not marker:
            return False, EvidenceLevel.NONE

        # æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
        if marker['expires_at']:
            if datetime.fromisoformat(marker['expires_at']) < datetime.now():
                return False, EvidenceLevel.NONE

        return True, EvidenceLevel(marker['level'])

    def get_protected_task_ids(self) -> set:
        """è·å–æ‰€æœ‰å—ä¿æŠ¤çš„ä»»åŠ¡ID"""
        rows = db.query(
            """SELECT task_id FROM evidence_markers
               WHERE expires_at IS NULL OR expires_at > ?""",
            [datetime.now().isoformat()]
        )
        return {r['task_id'] for r in rows}

    def get_marker(self, task_id: int) -> Optional[EvidenceMarker]:
        """
        è·å–ä»»åŠ¡çš„ä¿å…¨æ ‡è®°

        Args:
            task_id: ä»»åŠ¡ID

        Returns:
            EvidenceMarker æˆ– None
        """
        row = db.query_one(
            "SELECT * FROM evidence_markers WHERE task_id = ?",
            [task_id]
        )

        if not row:
            return None

        return EvidenceMarker(
            task_id=row['task_id'],
            level=EvidenceLevel(row['level']),
            reason=row['reason'],
            marked_by=row['marked_by'],
            marked_at=datetime.fromisoformat(row['marked_at']),
            expires_at=datetime.fromisoformat(row['expires_at']) if row['expires_at'] else None,
            related_case=row.get('related_case')
        )

    def release_preservation(self, task_ids: list, reason: str,
                             released_by: str) -> int:
        """
        è§£é™¤ä¿å…¨ (ä»…é™ STANDARD çº§åˆ«)

        LEGAL_HOLD éœ€è¦ç‰¹æ®Šæƒé™
        """
        count = 0
        for task_id in task_ids:
            is_protected, level = self.is_protected(task_id)

            if not is_protected:
                continue

            if level == EvidenceLevel.LEGAL_HOLD:
                logger.warning(f"ä»»åŠ¡ {task_id} ä¸ºæ³•å¾‹ä¿å…¨ï¼Œæ— æ³•è§£é™¤")
                continue

            db.execute(
                "DELETE FROM evidence_markers WHERE task_id = ?",
                [task_id]
            )

            logger.info(f"ä»»åŠ¡ {task_id} ä¿å…¨å·²è§£é™¤: {reason} (by {released_by})")
            count += 1

        return count
```

#### 15.4.4 æ¸…ç†æ—¶çš„è¯æ®æ£€æŸ¥

```python
# RetentionCleaner æ‰©å±•ç‰ˆï¼šé›†æˆè¯æ®ä¿æŠ¤é€»è¾‘
# æ³¨æ„ï¼šæ­¤ç‰ˆæœ¬ç»§æ‰¿ 15.2.3 çš„åŸºç¡€æ¸…ç†é€»è¾‘ï¼Œå¢åŠ äº†è¯æ®ä¿æŠ¤æ£€æŸ¥

class RetentionCleaner:
    def __init__(self, config: dict, evidence_manager: EvidenceManager):
        self.config = config
        self.evidence_mgr = evidence_manager

    def cleanup_old_data(self):
        """æ¸…ç†è¿‡æœŸæ•°æ® (è·³è¿‡å—ä¿æŠ¤çš„æ•°æ®)"""
        protected_ids = self.evidence_mgr.get_protected_task_ids()

        # æ¸…ç†æ—¥å¿— (æ£€æŸ¥å…³è”ä»»åŠ¡)
        self.cleanup_old_logs(exclude_task_ids=protected_ids)

        # æ¸…ç†æˆªå›¾ (æ£€æŸ¥å…³è”ä»»åŠ¡)
        self.cleanup_old_screenshots(exclude_task_ids=protected_ids)

        # æ¸…ç†å›æ‰§ (æ£€æŸ¥å…³è”ä»»åŠ¡)
        self.cleanup_old_receipts(exclude_task_ids=protected_ids)

        # å½’æ¡£ä»»åŠ¡ (è·³è¿‡å—ä¿æŠ¤çš„)
        self.archive_old_tasks(exclude_ids=protected_ids)

    def archive_old_tasks(self, exclude_ids: set):
        """å½’æ¡£æ—§ä»»åŠ¡ (æ’é™¤å—ä¿æŠ¤çš„)"""
        # ... åœ¨æŸ¥è¯¢æ¡ä»¶ä¸­æ’é™¤ exclude_ids
        placeholders = ','.join(['?' for _ in exclude_ids])
        old_tasks = db.query(
            f"""SELECT * FROM tasks
                WHERE created_at < ?
                AND id NOT IN ({placeholders})""",
            [cutoff_date] + list(exclude_ids)
        )
        # ...
```

**é…ç½®:**

```yaml
retention:
  # åŸºç¡€ç•™å­˜
  tasks:
    days: 90
    archive_to: "archive.db"

  # è¯æ®ä¿å…¨æ‰©å±•
  evidence:
    standard_extension_days: 365      # STANDARD çº§åˆ«å»¶é•¿å¤©æ•°
    legal_hold_requires_password: true  # è§£é™¤ LEGAL_HOLD éœ€è¦å¯†ç 
    auto_expire_standard_days: 365    # STANDARD è‡ªåŠ¨åˆ°æœŸå¤©æ•°

  # å½’æ¡£è§¦å‘æ¡ä»¶
  archive:
    trigger: "daily"                  # å½’æ¡£è§¦å‘: daily/weekly/manual
    trigger_time: "03:00"             # æ¯æ—¥è§¦å‘æ—¶é—´
    min_age_days: 90                  # æœ€å°å½’æ¡£å¹´é¾„
    batch_size: 1000                  # æ¯æ‰¹å½’æ¡£æ•°é‡
```

**LEGAL_HOLD æ°¸ä¸å½’æ¡£é€»è¾‘:**

| ä¿å…¨çº§åˆ« | å½’æ¡£è¡Œä¸º | åˆ é™¤è¡Œä¸º | è§£é™¤æ¡ä»¶ |
|----------|----------|----------|----------|
| `NONE` | æ­£å¸¸å½’æ¡£ | æ­£å¸¸åˆ é™¤ | æ— éœ€è§£é™¤ |
| `STANDARD` | å»¶è¿Ÿå½’æ¡£ (åˆ°æœŸå) | å»¶è¿Ÿåˆ é™¤ | æ‰‹åŠ¨è§£é™¤ / è‡ªåŠ¨åˆ°æœŸ |
| `LEGAL_HOLD` | **æ°¸ä¸å½’æ¡£** | **ç¦æ­¢åˆ é™¤** | éœ€å¯†ç  + å®¡è®¡ |

```python
# services/archive_policy.py

class ArchivePolicy:
    """å½’æ¡£ç­–ç•¥ç®¡ç†å™¨"""

    def should_archive(self, task_id: int, evidence_mgr: EvidencePreservation) -> tuple[bool, str]:
        """
        åˆ¤æ–­ä»»åŠ¡æ˜¯å¦åº”è¯¥å½’æ¡£

        Returns:
            (æ˜¯å¦å½’æ¡£, åŸå› )
        """
        is_protected, level = evidence_mgr.is_protected(task_id)

        if not is_protected:
            return True, "no_protection"

        if level == EvidenceLevel.LEGAL_HOLD:
            # LEGAL_HOLD æ°¸ä¸å½’æ¡£
            logger.info(f"ä»»åŠ¡ {task_id} ä¸º LEGAL_HOLD çŠ¶æ€ï¼Œè·³è¿‡å½’æ¡£")
            return False, "legal_hold_never_archive"

        if level == EvidenceLevel.STANDARD:
            # STANDARD æ£€æŸ¥åˆ°æœŸæ—¶é—´
            marker = evidence_mgr.get_marker(task_id)
            if marker and marker.expires_at:
                if datetime.now() < datetime.fromisoformat(marker.expires_at):
                    return False, "standard_not_expired"
            # å·²åˆ°æœŸï¼Œå¯ä»¥å½’æ¡£
            return True, "standard_expired"

        return True, "unknown_level"

    def should_delete(self, task_id: int, evidence_mgr: EvidencePreservation) -> tuple[bool, str]:
        """
        åˆ¤æ–­ä»»åŠ¡æ˜¯å¦å¯ä»¥åˆ é™¤

        LEGAL_HOLD çŠ¶æ€çš„ä»»åŠ¡æ°¸è¿œä¸å¯åˆ é™¤
        """
        is_protected, level = evidence_mgr.is_protected(task_id)

        if level == EvidenceLevel.LEGAL_HOLD:
            return False, "legal_hold_never_delete"

        if is_protected and level == EvidenceLevel.STANDARD:
            marker = evidence_mgr.get_marker(task_id)
            if marker and marker.expires_at:
                if datetime.now() < datetime.fromisoformat(marker.expires_at):
                    return False, "standard_not_expired"

        return True, "ok"


class TaskArchiver:
    """ä»»åŠ¡å½’æ¡£å™¨ (å¸¦ LEGAL_HOLD ä¿æŠ¤)"""

    def archive_expired_tasks(self) -> dict:
        """å½’æ¡£è¿‡æœŸä»»åŠ¡ (è‡ªåŠ¨è·³è¿‡ LEGAL_HOLD)"""

        # æŸ¥è¯¢æ‰€æœ‰ LEGAL_HOLD ä»»åŠ¡ID
        legal_hold_ids = self._get_legal_hold_task_ids()

        # æ„å»ºæ’é™¤æ¡ä»¶
        exclude_clause = ""
        params = [cutoff_date]

        if legal_hold_ids:
            placeholders = ','.join(['?' for _ in legal_hold_ids])
            exclude_clause = f"AND id NOT IN ({placeholders})"
            params.extend(legal_hold_ids)

        # æŸ¥è¯¢å¾…å½’æ¡£ä»»åŠ¡ (æ’é™¤ LEGAL_HOLD)
        tasks = db.query(
            f"""SELECT * FROM tasks
                WHERE created_at < ?
                AND status IN ('success', 'failed', 'cancelled')
                {exclude_clause}""",
            params
        )

        if legal_hold_ids:
            logger.info(f"å½’æ¡£æ—¶è·³è¿‡ {len(legal_hold_ids)} ä¸ª LEGAL_HOLD ä»»åŠ¡")

        # ... æ‰§è¡Œå½’æ¡£

    def _get_legal_hold_task_ids(self) -> set:
        """è·å–æ‰€æœ‰ LEGAL_HOLD çŠ¶æ€çš„ä»»åŠ¡ID"""
        rows = db.query(
            """SELECT task_id FROM evidence_markers
               WHERE level = ?""",
            [EvidenceLevel.LEGAL_HOLD.value]
        )
        return {r['task_id'] for r in rows}
```

**å…³é”®çº¦æŸ:**

1. **LEGAL_HOLD æ°¸ä¸å½’æ¡£**: æ— è®ºä»»åŠ¡å¹´é¾„å¤šå¤§ï¼Œåªè¦æ ‡è®°ä¸º `LEGAL_HOLD`ï¼Œæ°¸è¿œä¸ä¼šè¢«å½’æ¡£
2. **LEGAL_HOLD ç¦æ­¢åˆ é™¤**: å³ä½¿æ‰‹åŠ¨è§¦å‘åˆ é™¤ï¼Œä¹Ÿä¼šè¢«æ‹¦æˆª
3. **è§£é™¤éœ€è¦å®¡è®¡**: è§£é™¤ `LEGAL_HOLD` éœ€è¦å¯†ç éªŒè¯å¹¶è®°å½•å®¡è®¡æ—¥å¿—
4. **æ— åˆ°æœŸæ—¶é—´**: `LEGAL_HOLD` çš„ `expires_at` å§‹ç»ˆä¸º `NULL`

### 15.5 é‚®ä»¶é€šçŸ¥å®‰å…¨

```yaml
# config.yaml
email:
  # é‚®ä»¶å†…å®¹å®‰å…¨
  include_content: false       # æ˜¯å¦åŒ…å«æ–‡æ¡ˆå†…å®¹ (å»ºè®®å…³é—­)
  include_group_names: false   # æ˜¯å¦åŒ…å«ç¾¤ååˆ—è¡¨ (å»ºè®®å…³é—­)
  mask_in_subject: true        # é‚®ä»¶ä¸»é¢˜æ˜¯å¦è„±æ•

  # æ•æ„Ÿä¿¡æ¯è­¦å‘Š
  sensitive_warning: |
    æ³¨æ„: æœ¬é‚®ä»¶å¯èƒ½åŒ…å«ä¸šåŠ¡æ•æ„Ÿä¿¡æ¯, è¯·å‹¿è½¬å‘ç»™æ— å…³äººå‘˜ã€‚
```

### 15.6 è¯­éŸ³é€šçŸ¥æœåŠ¡

> **åŠŸèƒ½**: ä»»åŠ¡æ‰§è¡Œå®Œæˆåé€šè¿‡è¯­éŸ³æ’­æŠ¥é€šçŸ¥ç”¨æˆ·ï¼Œé€‚ç”¨äºç”¨æˆ·ç¦»å¼€ç”µè„‘ä½†ä»åœ¨é™„è¿‘çš„åœºæ™¯ã€‚

#### 15.6.1 è¯­éŸ³é€šçŸ¥é…ç½®

```yaml
# config.yaml
notification:
  voice:
    enabled: true              # è¯­éŸ³é€šçŸ¥æ€»å¼€å…³
    on_success: true           # å•æ¡ä»»åŠ¡æˆåŠŸæ—¶æ’­æŠ¥
    on_failure: true           # å•æ¡ä»»åŠ¡å¤±è´¥æ—¶æ’­æŠ¥
    on_complete: true          # å…¨éƒ¨ä»»åŠ¡å®Œæˆæ—¶æ’­æŠ¥
    volume: 80                 # éŸ³é‡ (0-100)
    rate: 150                  # è¯­é€Ÿ (words per minute, é»˜è®¤150)

    # è‡ªå®šä¹‰æ’­æŠ¥æ–‡æœ¬ (æ”¯æŒå˜é‡æ›¿æ¢)
    messages:
      success: "ä»»åŠ¡ {product_name} å‘å¸ƒæˆåŠŸ"
      failure: "ä»»åŠ¡ {product_name} å‘å¸ƒå¤±è´¥ï¼ŒåŸå› ï¼š{error_short}"
      complete: "å…¨éƒ¨ä»»åŠ¡å·²å®Œæˆï¼ŒæˆåŠŸ {success_count} æ¡ï¼Œå¤±è´¥ {fail_count} æ¡"
      queue_empty: "ä»»åŠ¡é˜Ÿåˆ—å·²æ¸…ç©º"
```

#### 15.6.2 è¯­éŸ³é€šçŸ¥å®ç°

```python
# services/voice_notifier.py

import pyttsx3
import threading
from typing import Optional
from dataclasses import dataclass


@dataclass
class VoiceConfig:
    """è¯­éŸ³é…ç½®"""
    enabled: bool = True
    on_success: bool = True
    on_failure: bool = True
    on_complete: bool = True
    volume: int = 80          # 0-100
    rate: int = 150           # è¯­é€Ÿ


class VoiceNotifier:
    """
    è¯­éŸ³é€šçŸ¥æœåŠ¡

    ä½¿ç”¨ pyttsx3 å®ç°è·¨å¹³å° TTS (Text-to-Speech)
    Windows ä½¿ç”¨ SAPI5ï¼Œæ”¯æŒä¸­æ–‡
    """

    def __init__(self, config: VoiceConfig):
        self.config = config
        self._engine: Optional[pyttsx3.Engine] = None
        self._lock = threading.Lock()

        if self.config.enabled:
            self._init_engine()

    def _init_engine(self):
        """åˆå§‹åŒ–è¯­éŸ³å¼•æ“"""
        try:
            self._engine = pyttsx3.init()
            # è®¾ç½®éŸ³é‡ (0.0 - 1.0)
            self._engine.setProperty('volume', self.config.volume / 100.0)
            # è®¾ç½®è¯­é€Ÿ
            self._engine.setProperty('rate', self.config.rate)
            # å°è¯•è®¾ç½®ä¸­æ–‡è¯­éŸ³
            self._set_chinese_voice()
        except Exception as e:
            logger.warning(f"è¯­éŸ³å¼•æ“åˆå§‹åŒ–å¤±è´¥: {e}")
            self._engine = None

    def _set_chinese_voice(self):
        """è®¾ç½®ä¸­æ–‡è¯­éŸ³ (Windows SAPI5)"""
        if not self._engine:
            return
        voices = self._engine.getProperty('voices')
        for voice in voices:
            # æŸ¥æ‰¾ä¸­æ–‡è¯­éŸ³
            if 'chinese' in voice.name.lower() or 'zh' in voice.id.lower():
                self._engine.setProperty('voice', voice.id)
                logger.info(f"ä½¿ç”¨ä¸­æ–‡è¯­éŸ³: {voice.name}")
                return
        logger.warning("æœªæ‰¾åˆ°ä¸­æ–‡è¯­éŸ³ï¼Œä½¿ç”¨é»˜è®¤è¯­éŸ³")

    def speak(self, text: str, block: bool = False):
        """
        æ’­æŠ¥æ–‡æœ¬

        Args:
            text: è¦æ’­æŠ¥çš„æ–‡æœ¬
            block: æ˜¯å¦é˜»å¡ç­‰å¾…æ’­æŠ¥å®Œæˆ
        """
        if not self.config.enabled or not self._engine:
            return

        def _speak():
            with self._lock:
                try:
                    self._engine.say(text)
                    self._engine.runAndWait()
                except Exception as e:
                    logger.error(f"è¯­éŸ³æ’­æŠ¥å¤±è´¥: {e}")

        if block:
            _speak()
        else:
            # éé˜»å¡æ¨¡å¼ï¼Œåœ¨åå°çº¿ç¨‹æ’­æŠ¥
            thread = threading.Thread(target=_speak, daemon=True)
            thread.start()

    def notify_success(self, task: 'Task'):
        """ä»»åŠ¡æˆåŠŸé€šçŸ¥"""
        if not self.config.on_success:
            return
        message = f"ä»»åŠ¡ {task.product_name} å‘å¸ƒæˆåŠŸ"
        self.speak(message)

    def notify_failure(self, task: 'Task', error: str):
        """ä»»åŠ¡å¤±è´¥é€šçŸ¥"""
        if not self.config.on_failure:
            return
        # æˆªå–é”™è¯¯ä¿¡æ¯å‰20å­—ç¬¦
        error_short = error[:20] + "..." if len(error) > 20 else error
        message = f"ä»»åŠ¡ {task.product_name} å‘å¸ƒå¤±è´¥"
        self.speak(message)

    def notify_complete(self, success_count: int, fail_count: int):
        """å…¨éƒ¨å®Œæˆé€šçŸ¥"""
        if not self.config.on_complete:
            return
        total = success_count + fail_count
        message = f"å…¨éƒ¨ä»»åŠ¡å·²å®Œæˆï¼Œå…± {total} æ¡ï¼ŒæˆåŠŸ {success_count} æ¡"
        if fail_count > 0:
            message += f"ï¼Œå¤±è´¥ {fail_count} æ¡"
        self.speak(message)

    def set_enabled(self, enabled: bool):
        """åŠ¨æ€å¼€å…³è¯­éŸ³é€šçŸ¥"""
        self.config.enabled = enabled
        if enabled and not self._engine:
            self._init_engine()

    def set_volume(self, volume: int):
        """åŠ¨æ€è°ƒæ•´éŸ³é‡"""
        self.config.volume = max(0, min(100, volume))
        if self._engine:
            self._engine.setProperty('volume', self.config.volume / 100.0)
```

#### 15.6.3 ä¾èµ–è¯´æ˜

```txt
# requirements.txt æ·»åŠ 
pyttsx3>=2.90           # è·¨å¹³å° TTS å¼•æ“
```

> **Windows ç”¨æˆ·**: pyttsx3 ä½¿ç”¨ Windows å†…ç½®çš„ SAPI5 è¯­éŸ³å¼•æ“ï¼Œæ— éœ€é¢å¤–å®‰è£…ã€‚
> ç³»ç»Ÿè‡ªå¸¦ä¸­æ–‡è¯­éŸ³ "Microsoft Huihui" æˆ– "Microsoft Kangkang"ã€‚

### 15.7 é€šçŸ¥ç®¡ç†å™¨ (ç»Ÿä¸€è°ƒåº¦)

> **èŒè´£**: ç»Ÿä¸€ç®¡ç†æ‰€æœ‰é€šçŸ¥æ¸ é“ï¼Œæ ¹æ®é…ç½®å†³å®šå‘é€å“ªäº›é€šçŸ¥ã€‚

```python
# services/notification_manager.py

from dataclasses import dataclass
from typing import Optional
from .email_notifier import EmailNotifier
from .voice_notifier import VoiceNotifier


@dataclass
class NotificationConfig:
    """é€šçŸ¥é…ç½®"""
    email_enabled: bool = True
    voice_enabled: bool = True


class NotificationManager:
    """
    é€šçŸ¥ç®¡ç†å™¨

    ç»Ÿä¸€ç®¡ç†é‚®ä»¶é€šçŸ¥å’Œè¯­éŸ³é€šçŸ¥ï¼Œæä¾›ç»Ÿä¸€çš„è°ƒç”¨æ¥å£
    """

    def __init__(
        self,
        config: NotificationConfig,
        email_notifier: Optional[EmailNotifier] = None,
        voice_notifier: Optional[VoiceNotifier] = None
    ):
        self.config = config
        self.email = email_notifier
        self.voice = voice_notifier

    def on_task_success(self, task: 'Task'):
        """ä»»åŠ¡æˆåŠŸå›è°ƒ"""
        # è¯­éŸ³é€šçŸ¥ (å³æ—¶)
        if self.config.voice_enabled and self.voice:
            self.voice.notify_success(task)

        # é‚®ä»¶é€šçŸ¥ (å¯é€‰)
        if self.config.email_enabled and self.email:
            self.email.notify_success(task)

    def on_task_failure(self, task: 'Task', error: str):
        """ä»»åŠ¡å¤±è´¥å›è°ƒ"""
        # è¯­éŸ³é€šçŸ¥ (å³æ—¶)
        if self.config.voice_enabled and self.voice:
            self.voice.notify_failure(task, error)

        # é‚®ä»¶é€šçŸ¥ (å¤±è´¥æ—¶é€šå¸¸å¼€å¯)
        if self.config.email_enabled and self.email:
            self.email.notify_failure(task, error)

    def on_queue_complete(self, stats: dict):
        """é˜Ÿåˆ—å®Œæˆå›è°ƒ"""
        success_count = stats.get('success', 0)
        fail_count = stats.get('failed', 0)

        # è¯­éŸ³é€šçŸ¥
        if self.config.voice_enabled and self.voice:
            self.voice.notify_complete(success_count, fail_count)

        # é‚®ä»¶æ±‡æ€»
        if self.config.email_enabled and self.email:
            self.email.send_summary(stats)

    def set_email_enabled(self, enabled: bool):
        """åŠ¨æ€å¼€å…³é‚®ä»¶é€šçŸ¥"""
        self.config.email_enabled = enabled

    def set_voice_enabled(self, enabled: bool):
        """åŠ¨æ€å¼€å…³è¯­éŸ³é€šçŸ¥"""
        self.config.voice_enabled = enabled
        if self.voice:
            self.voice.set_enabled(enabled)
```

### 15.8 é€šçŸ¥è®¾ç½®ç•Œé¢

> **UI ä½ç½®**: ç³»ç»Ÿè®¾ç½® â†’ é€šçŸ¥è®¾ç½®

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é€šçŸ¥è®¾ç½®                                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  ã€é‚®ä»¶é€šçŸ¥ã€‘                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ â˜‘ å¯ç”¨é‚®ä»¶é€šçŸ¥                          [é…ç½®SMTP]   â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚ é€šçŸ¥æ—¶æœº:                                           â”‚   â”‚
â”‚  â”‚   â˜ å•æ¡ä»»åŠ¡æˆåŠŸæ—¶                                  â”‚   â”‚
â”‚  â”‚   â˜‘ å•æ¡ä»»åŠ¡å¤±è´¥æ—¶                                  â”‚   â”‚
â”‚  â”‚   â˜‘ æ¯æ—¥å‘é€æ±‡æ€»æŠ¥å‘Š                                â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â”‚  ã€è¯­éŸ³é€šçŸ¥ã€‘                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ â˜‘ å¯ç”¨è¯­éŸ³é€šçŸ¥                                       â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚ é€šçŸ¥æ—¶æœº:                                           â”‚   â”‚
â”‚  â”‚   â˜‘ å•æ¡ä»»åŠ¡æˆåŠŸæ—¶                                  â”‚   â”‚
â”‚  â”‚   â˜‘ å•æ¡ä»»åŠ¡å¤±è´¥æ—¶                                  â”‚   â”‚
â”‚  â”‚   â˜‘ å…¨éƒ¨ä»»åŠ¡å®Œæˆæ—¶                                  â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚ éŸ³é‡: [=========>----] 80%                          â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚   â”‚
â”‚  â”‚ æ‰‹åŠ¨æ’­æ”¾:                                           â”‚   â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚ â”‚ è¾“å…¥è¦æ’­æ”¾çš„æ–‡å­—...                          â”‚    â”‚   â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â”‚                                        [æ’­æ”¾]      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â”‚                              [æ¢å¤é»˜è®¤]  [ä¿å­˜]             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 15.9 æ‰‹åŠ¨è¯­éŸ³æ’­æ”¾åŠŸèƒ½

> **åŠŸèƒ½**: ç”¨æˆ·è¾“å…¥ä»»æ„æ–‡å­—ï¼Œç‚¹å‡»æ’­æ”¾æŒ‰é’®å³å¯å¬åˆ°è¯­éŸ³æ’­æŠ¥ã€‚å¯ç”¨äºæµ‹è¯•è¯­éŸ³æ•ˆæœæˆ–ä¸´æ—¶æ’­æŠ¥æé†’ã€‚

#### 15.9.1 UI å®ç°

```python
# gui/voice_settings_widget.py

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel,
    QLineEdit, QPushButton, QSlider, QCheckBox, QGroupBox
)
from PySide6.QtCore import Qt


class VoiceSettingsWidget(QWidget):
    """è¯­éŸ³é€šçŸ¥è®¾ç½®ç•Œé¢"""

    def __init__(self, voice_notifier):
        super().__init__()
        self.voice_notifier = voice_notifier
        self._init_ui()

    def _init_ui(self):
        layout = QVBoxLayout(self)

        # è¯­éŸ³é€šçŸ¥å¼€å…³å’Œè®¾ç½®
        voice_group = QGroupBox("è¯­éŸ³é€šçŸ¥")
        voice_layout = QVBoxLayout(voice_group)

        # å¯ç”¨å¼€å…³
        self.enable_checkbox = QCheckBox("å¯ç”¨è¯­éŸ³é€šçŸ¥")
        self.enable_checkbox.setChecked(True)
        self.enable_checkbox.toggled.connect(self._on_enable_changed)
        voice_layout.addWidget(self.enable_checkbox)

        # é€šçŸ¥æ—¶æœºé€‰é¡¹
        self.on_success_cb = QCheckBox("å•æ¡ä»»åŠ¡æˆåŠŸæ—¶")
        self.on_failure_cb = QCheckBox("å•æ¡ä»»åŠ¡å¤±è´¥æ—¶")
        self.on_complete_cb = QCheckBox("å…¨éƒ¨ä»»åŠ¡å®Œæˆæ—¶")
        self.on_success_cb.setChecked(True)
        self.on_failure_cb.setChecked(True)
        self.on_complete_cb.setChecked(True)
        voice_layout.addWidget(self.on_success_cb)
        voice_layout.addWidget(self.on_failure_cb)
        voice_layout.addWidget(self.on_complete_cb)

        # éŸ³é‡æ»‘å—
        volume_layout = QHBoxLayout()
        volume_layout.addWidget(QLabel("éŸ³é‡:"))
        self.volume_slider = QSlider(Qt.Horizontal)
        self.volume_slider.setRange(0, 100)
        self.volume_slider.setValue(80)
        self.volume_slider.valueChanged.connect(self._on_volume_changed)
        volume_layout.addWidget(self.volume_slider)
        self.volume_label = QLabel("80%")
        volume_layout.addWidget(self.volume_label)
        voice_layout.addLayout(volume_layout)

        # ========== æ‰‹åŠ¨æ’­æ”¾åŒºåŸŸ ==========
        voice_layout.addWidget(QLabel(""))  # ç©ºè¡Œåˆ†éš”
        voice_layout.addWidget(QLabel("æ‰‹åŠ¨æ’­æ”¾:"))

        # æ–‡å­—è¾“å…¥æ¡†
        self.text_input = QLineEdit()
        self.text_input.setPlaceholderText("è¾“å…¥è¦æ’­æ”¾çš„æ–‡å­—...")
        self.text_input.returnPressed.connect(self._play_custom_text)  # å›è½¦æ’­æ”¾
        voice_layout.addWidget(self.text_input)

        # æ’­æ”¾æŒ‰é’®
        play_layout = QHBoxLayout()
        play_layout.addStretch()
        self.play_btn = QPushButton("æ’­æ”¾")
        self.play_btn.setFixedWidth(80)
        self.play_btn.clicked.connect(self._play_custom_text)
        play_layout.addWidget(self.play_btn)
        voice_layout.addLayout(play_layout)

        layout.addWidget(voice_group)
        layout.addStretch()

    def _on_enable_changed(self, enabled: bool):
        """å¯ç”¨/ç¦ç”¨è¯­éŸ³é€šçŸ¥"""
        self.voice_notifier.set_enabled(enabled)

    def _on_volume_changed(self, value: int):
        """éŸ³é‡è°ƒæ•´"""
        self.volume_label.setText(f"{value}%")
        self.voice_notifier.set_volume(value)

    def _play_custom_text(self):
        """æ’­æ”¾ç”¨æˆ·è¾“å…¥çš„æ–‡å­—"""
        text = self.text_input.text().strip()
        if text:
            self.voice_notifier.speak(text)
        else:
            # è¾“å…¥ä¸ºç©ºæ—¶æ’­æ”¾æç¤º
            self.voice_notifier.speak("è¯·è¾“å…¥è¦æ’­æ”¾çš„æ–‡å­—")
```

#### 15.9.2 VoiceNotifier æ‰©å±•

åœ¨ `VoiceNotifier` ç±»ä¸­å·²æœ‰ `speak(text)` æ–¹æ³•ï¼Œå¯ç›´æ¥ç”¨äºæ‰‹åŠ¨æ’­æ”¾ï¼š

```python
# æ‰‹åŠ¨æ’­æ”¾ç¤ºä¾‹
voice_notifier = VoiceNotifier(config)

# æ’­æ”¾ä»»æ„æ–‡å­—
voice_notifier.speak("ä½ å¥½ï¼Œè¿™æ˜¯ä¸€æ¡æµ‹è¯•æ¶ˆæ¯")
voice_notifier.speak("ä»»åŠ¡å·²å®Œæˆï¼Œè¯·æŸ¥çœ‹ç»“æœ")
```

#### 15.9.3 ä½¿ç”¨åœºæ™¯

| åœºæ™¯ | è¯´æ˜ |
|------|------|
| **æµ‹è¯•è¯­éŸ³** | è°ƒæ•´éŸ³é‡åæµ‹è¯•æ•ˆæœ |
| **ä¸´æ—¶æé†’** | è¾“å…¥è‡ªå®šä¹‰æé†’å†…å®¹æ’­æ”¾ |
| **è°ƒè¯•éªŒè¯** | éªŒè¯è¯­éŸ³å¼•æ“æ˜¯å¦æ­£å¸¸å·¥ä½œ |

### 15.10 æ•°æ®æ¸…ç†ä¸ä¿å…¨å†³ç­–çŸ©é˜µ

> **å•ä¸€æ¥æº**: æ‰€æœ‰æ•°æ®ç±»å‹çš„ç•™å­˜ã€æ¸…ç†ã€ä¿å…¨ç­–ç•¥æ±‡æ€»äºæ­¤ã€‚

#### 15.10.1 æ•°æ®æ¸…ç†å†³ç­–çŸ©é˜µ

| æ•°æ®ç±»å‹ | å­˜å‚¨ä½ç½® | é»˜è®¤ç•™å­˜ | æ¸…ç†è§¦å‘ | ä¿å…¨ä¾‹å¤– | æ¸…ç†æ–¹å¼ |
|----------|----------|----------|----------|----------|----------|
| **æ—¥å¿—æ–‡ä»¶** | `logs/` | 90å¤© | æ¯æ—¥å®šæ—¶ä»»åŠ¡ | LEGAL_HOLD | åˆ é™¤è¿‡æœŸæ–‡ä»¶ |
| **æˆªå›¾æ–‡ä»¶** | `screenshots/` | 30å¤© | æ¯æ—¥å®šæ—¶ä»»åŠ¡ | LEGAL_HOLD | åˆ é™¤è¿‡æœŸæ–‡ä»¶ |
| **åŸå§‹å›¾ç‰‡** | `data/original_images/` | 7å¤© | æ¯æ—¥å®šæ—¶ä»»åŠ¡ | LEGAL_HOLD | åˆ é™¤æ•´ä¸ªæ—¥æœŸç›®å½• |
| **å‹ç¼©å›¾ç‰‡** | `data/compressed_images/` | 3å¤© | ä»»åŠ¡å®Œæˆå | æ—  | åˆ é™¤æ•´ä¸ªæ—¥æœŸç›®å½• |
| **å›æ‰§æ–‡ä»¶ (å®Œæ•´ç‰ˆ)** | `receipts/full/` | 365å¤© | æ¯æ—¥å®šæ—¶ä»»åŠ¡ | LEGAL_HOLD | ç§»åŠ¨åˆ°å½’æ¡£ |
| **å›æ‰§æ–‡ä»¶ (è„±æ•ç‰ˆ)** | `receipts/masked/` | 365å¤© | æ¯æ—¥å®šæ—¶ä»»åŠ¡ | æ—  | åˆ é™¤è¿‡æœŸæ–‡ä»¶ |
| **ä»»åŠ¡æ•°æ®åº“ (ä¸»åº“)** | `data/tasks.db` | 90å¤© | æ¯æ—¥å®šæ—¶ä»»åŠ¡ | LEGAL_HOLD | å½’æ¡£åˆ° archive.db |
| **ä»»åŠ¡å½’æ¡£ (å½’æ¡£åº“)** | `data/archive.db` | æ°¸ä¹… | æ—  | å…¨éƒ¨ | ä¸æ¸…ç† |
| **å®¡è®¡æ—¥å¿—** | `data/audit/` | æ°¸ä¹… | æ—  | å…¨éƒ¨ | ä¸æ¸…ç† |
| **ä¼šè¯æ–‡ä»¶** | `data/session/` | 8å°æ—¶ | ä¼šè¯è¿‡æœŸæ—¶ | æ—  | åˆ é™¤ä¼šè¯æ–‡ä»¶ |
| **æ¨¡æ¿ç¼“å­˜** | `templates/cache/` | 7å¤© | æ¯æ—¥å®šæ—¶ä»»åŠ¡ | æ—  | åˆ é™¤è¿‡æœŸç¼“å­˜ |
| **åœæœºæ ‡è®°** | `data/.shutdown` | æ‰‹åŠ¨æ¸…é™¤ | äººå·¥å¤„ç†å | æ—  | æ‰‹åŠ¨åˆ é™¤ |
| **æ›´æ–°å¤±è´¥æ ‡è®°** | `templates/.update_failed` | æ‰‹åŠ¨æ¸…é™¤ | ä¿®å¤å | æ—  | æ‰‹åŠ¨åˆ é™¤ |

#### 15.10.2 è¯æ®ä¿å…¨çº§åˆ«

| çº§åˆ« | æšä¸¾å€¼ | æ¸…ç†è¡Œä¸º | é€‚ç”¨åœºæ™¯ |
|------|--------|----------|----------|
| **æ— ä¿å…¨** | `NONE` | æŒ‰æ­£å¸¸ç­–ç•¥æ¸…ç† | æ™®é€šä»»åŠ¡ |
| **æ ‡å‡†ä¿å…¨** | `STANDARD` | æ¸…ç†å‰åˆ›å»ºå½’æ¡£ | é‡è¦ä»»åŠ¡ |
| **æ³•å¾‹ä¿å…¨** | `LEGAL_HOLD` | æ°¸ä¸æ¸…ç†ï¼Œæ°¸ä¸å½’æ¡£ | æ¶‰åŠäº‰è®®/å®¡è®¡çš„ä»»åŠ¡ |

#### 15.10.3 æ¸…ç†ä»»åŠ¡è°ƒåº¦

```yaml
# config.yaml
cleanup:
  # æ¸…ç†ä»»åŠ¡æ‰§è¡Œæ—¶é—´ (æ¯æ—¥å‡Œæ™¨2ç‚¹)
  schedule: "0 2 * * *"

  # æ¸…ç†å‰æ£€æŸ¥
  pre_check:
    - evidence_level != LEGAL_HOLD
    - age > retention_days
    - not in_active_use

  # æ¸…ç†åæ“ä½œ
  post_actions:
    - log_cleanup_stats
    - send_summary_if_large_cleanup
```

### 15.11 å¯¹å¤–è¾“å‡ºå­—æ®µä¸è„±æ•ç­–ç•¥ (å•ä¸€æ¥æº)

> **é˜²æ¼è„±æ•**: æ˜ç¡®æ¯ä¸ªå¯¹å¤–è¾“å‡ºæ¸ é“åŒ…å«å“ªäº›å­—æ®µï¼Œä»¥åŠå„å­—æ®µçš„è„±æ•ç­–ç•¥ã€‚

#### 15.11.1 è¾“å‡ºæ¸ é“å­—æ®µçŸ©é˜µ

| å­—æ®µ | å®Œæ•´ç‰ˆå›æ‰§ | è„±æ•ç‰ˆå›æ‰§ | é‚®ä»¶é€šçŸ¥ | Webhook | æ—¥å¿— |
|------|-----------|-----------|----------|---------|------|
| **task_id** | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ |
| **content_code** | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ |
| **product_name** | âœ… åŸå€¼ | ğŸ”’ è„±æ• | ğŸ”’ è„±æ• | ğŸ”’ è„±æ• | ğŸ”’ è„±æ• |
| **channel** | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ |
| **group_name** | âœ… åŸå€¼ | ğŸ”’ è„±æ• | âŒ ä¸å« | ğŸ”’ è„±æ• | ğŸ”’ è„±æ• |
| **phone** | âœ… åŸå€¼ | ğŸ”’ å¼ºåˆ¶è„±æ• | âŒ ä¸å« | âŒ ä¸å« | ğŸ”’ å¼ºåˆ¶è„±æ• |
| **wechat_id** | âœ… åŸå€¼ | ğŸ”’ å¼ºåˆ¶è„±æ• | âŒ ä¸å« | âŒ ä¸å« | ğŸ”’ å¼ºåˆ¶è„±æ• |
| **text_content** | âœ… åŸå€¼ | ğŸ”’ æˆªæ–­ | âŒ ä¸å« | ğŸ”’ æˆªæ–­ | ğŸ”’ æˆªæ–­ |
| **image_paths** | âœ… åŸå€¼ | âœ… åŸå€¼ | âŒ ä¸å« | âŒ ä¸å« | âœ… åŸå€¼ |
| **status** | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ |
| **error_message** | âœ… åŸå€¼ | ğŸ”’ è„±æ• | ğŸ”’ è„±æ• | ğŸ”’ è„±æ• | âœ… åŸå€¼ |
| **scheduled_time** | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ |
| **executed_time** | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ |
| **screenshot_path** | âœ… åŸå€¼ | âŒ ä¸å« | âŒ ä¸å« | âŒ ä¸å« | âœ… åŸå€¼ |
| **operator_id** | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ | âœ… åŸå€¼ |

> **å›¾ä¾‹**: âœ… åŸå€¼ | ğŸ”’ è„±æ• | âŒ ä¸å«

#### 15.11.2 è„±æ•è§„åˆ™è¯¦è§£

| å­—æ®µç±»å‹ | è„±æ•æ–¹æ³• | è¾“å…¥ç¤ºä¾‹ | è¾“å‡ºç¤ºä¾‹ |
|----------|----------|----------|----------|
| **æ‰‹æœºå·** | ä¸­é—´4ä½æ›¿æ¢ä¸º**** | `13812345678` | `138****5678` |
| **å¾®ä¿¡ID** | ä¿ç•™å‰4ä½å’Œå3ä½ | `wxid_abcdef123` | `wxid****123` |
| **ç¾¤å** | ä¿ç•™é¦–å°¾å„1å­— | `å®¶åº­è´­ç‰©ç¾¤` | `å®¶***ç¾¤` |
| **äº§å“å** | ä¿ç•™å‰2å­—+** | `äº‘å—çº¢ç³–ç²¾é€‰` | `äº‘å—**` |
| **æ–‡æ¡ˆå†…å®¹** | æˆªæ–­å‰20å­—+... | `ä»Šæ—¥ç‰¹ä»·æ´»åŠ¨...` | `ä»Šæ—¥ç‰¹ä»·æ´»åŠ¨...` |
| **é”™è¯¯ä¿¡æ¯** | ç§»é™¤è·¯å¾„å’Œæ•æ„Ÿè¯ | `C:\Users\xxx\file.txt not found` | `[è·¯å¾„éšè—] not found` |

#### 15.11.3 å¼ºåˆ¶è„±æ•å­—æ®µ (ä¸å¯é…ç½®)

ä»¥ä¸‹å­—æ®µåœ¨ **ä»»ä½•ç¯å¢ƒã€ä»»ä½•è¾“å‡ºæ¸ é“** (å®Œæ•´ç‰ˆå›æ‰§é™¤å¤–) å‡å¼ºåˆ¶è„±æ•:

- `phone`: æ‰‹æœºå·
- `wechat_id`: å¾®ä¿¡ID

> **åŸå› **: è¿™äº›å­—æ®µå±äºä¸ªäººéšç§ä¿¡æ¯ï¼Œæ³„éœ²é£é™©æé«˜ã€‚å³ä½¿åœ¨å¼€å‘ç¯å¢ƒä¹Ÿåº”ä¿æŠ¤ã€‚

#### 15.11.4 è„±æ•æ ¡éªŒæ£€æŸ¥ç‚¹

| æ£€æŸ¥ç‚¹ | è§¦å‘æ—¶æœº | æ£€æŸ¥å†…å®¹ | å¤±è´¥è¡Œä¸º |
|--------|----------|----------|----------|
| **é‚®ä»¶å‘é€å‰** | `send_email()` | æ£€æŸ¥æ˜¯å¦æœ‰æœªè„±æ•æ‰‹æœºå·/å¾®ä¿¡ID | é˜»æ­¢å‘é€ï¼Œè®°å½•å‘Šè­¦ |
| **Webhook å‘é€å‰** | `send_webhook()` | æ£€æŸ¥ payload ä¸­çš„æ•æ„Ÿå­—æ®µ | é˜»æ­¢å‘é€ï¼Œè®°å½•å‘Šè­¦ |
| **å›æ‰§åˆ†å‘å‰** | `distribute_receipt()` | æ ¡éªŒæ˜¯å¦ä½¿ç”¨è„±æ•ç‰ˆ | é˜»æ­¢åˆ†å‘ï¼Œè®°å½•å‘Šè­¦ |
| **æ—¥å¿—å†™å…¥æ—¶** | `logger.info/warn/error()` | è‡ªåŠ¨è¿‡æ»¤æ•æ„Ÿæ¨¡å¼ | è‡ªåŠ¨æ›¿æ¢ä¸ºè„±æ•å€¼ |

---

## åå…­ã€å¤šæ˜¾ç¤ºå™¨ä¸ç¼©æ”¾ç­–ç•¥

### 16.1 æ˜¾ç¤ºç¯å¢ƒæŒ‘æˆ˜

æ¨¡æ‹Ÿç‚¹å‡»ä¾èµ–å±å¹•åæ ‡, ä»¥ä¸‹ç¯å¢ƒä¼šå½±å“å®šä½å‡†ç¡®æ€§:
- å¤šæ˜¾ç¤ºå™¨é…ç½® (ä¸»/å‰¯å±)
- é 100% DPI ç¼©æ”¾
- ä¸åŒåˆ†è¾¨ç‡
- çª—å£ä½ç½®ä¸å›ºå®š

### 16.2 æ‰§è¡Œç­–ç•¥

```python
# core/display_manager.py

import ctypes
from ctypes import wintypes

class DisplayManager:
    """æ˜¾ç¤ºç¯å¢ƒç®¡ç†"""

    def __init__(self):
        self.user32 = ctypes.windll.user32

    def get_primary_monitor_info(self) -> dict:
        """è·å–ä¸»æ˜¾ç¤ºå™¨ä¿¡æ¯"""
        width = self.user32.GetSystemMetrics(0)   # SM_CXSCREEN
        height = self.user32.GetSystemMetrics(1)  # SM_CYSCREEN
        return {'width': width, 'height': height, 'x': 0, 'y': 0}

    def get_primary_monitor(self) -> dict:
        """
        è·å–ä¸»æ˜¾ç¤ºå™¨ä¿¡æ¯ (åˆ«åæ–¹æ³•)

        ä¸ get_primary_monitor_info åŠŸèƒ½ç›¸åŒï¼Œä¸ºå…¼å®¹æ€§ä¿ç•™
        """
        return self.get_primary_monitor_info()

    def get_dpi_scale(self) -> float:
        """è·å– DPI ç¼©æ”¾æ¯”ä¾‹"""
        try:
            self.user32.SetProcessDPIAware()
            dc = self.user32.GetDC(0)
            dpi = ctypes.windll.gdi32.GetDeviceCaps(dc, 88)
            self.user32.ReleaseDC(0, dc)
            return dpi / 96.0
        except (OSError, AttributeError):
            return 1.0

    def move_wechat_to_primary(self, wechat_hwnd: int, retry: int = 3) -> bool:
        """
        å°†å¾®ä¿¡çª—å£ç§»åŠ¨åˆ°ä¸»å±å¹•å·¦ä¸Šè§’

        æ‰§è¡Œä»»åŠ¡å‰è°ƒç”¨, ç¡®ä¿çª—å£ä½ç½®å›ºå®š

        Args:
            wechat_hwnd: å¾®ä¿¡çª—å£å¥æŸ„
            retry: é‡è¯•æ¬¡æ•°

        Returns:
            æ˜¯å¦æˆåŠŸç§»åŠ¨
        """
        for attempt in range(retry):
            try:
                # æ£€æŸ¥ä¸»å±åˆ†è¾¨ç‡æ˜¯å¦è¶³å¤Ÿ
                primary_info = self.get_primary_monitor()
                if primary_info['width'] < 900 or primary_info['height'] < 700:
                    logger.warning(
                        f"ä¸»å±åˆ†è¾¨ç‡ä¸è¶³ ({primary_info['width']}x{primary_info['height']}), "
                        f"éœ€è¦è‡³å°‘ 900x700"
                    )
                    # é™çº§: ä½¿ç”¨è¾ƒå°çš„çª—å£å°ºå¯¸
                    width = min(800, primary_info['width'] - 100)
                    height = min(600, primary_info['height'] - 100)
                else:
                    width = 900
                    height = 700

                # ç›®æ ‡ä½ç½®: ä¸»å±å·¦ä¸Šè§’ (ç•™å‡ºä»»åŠ¡æ ç©ºé—´)
                target_x = 50
                target_y = 50

                # å…ˆè¿˜åŸçª—å£ (å¦‚æœæœ€å¤§åŒ–)
                self.user32.ShowWindow(wechat_hwnd, 9)  # SW_RESTORE
                time.sleep(0.2)

                # ç§»åŠ¨å¹¶è°ƒæ•´å¤§å°
                result = self.user32.SetWindowPos(
                    wechat_hwnd,
                    0,  # HWND_TOP
                    target_x, target_y, width, height,
                    0x0040  # SWP_SHOWWINDOW
                )

                if result:
                    # éªŒè¯çª—å£æ˜¯å¦çœŸçš„ç§»åŠ¨äº†
                    if self._verify_window_position(wechat_hwnd, target_x, target_y, width, height):
                        logger.info(f"å¾®ä¿¡çª—å£å·²ç§»åŠ¨åˆ°ä¸»å± ({target_x}, {target_y}), å°ºå¯¸ {width}x{height}")
                        return True
                    else:
                        logger.warning(f"çª—å£ä½ç½®éªŒè¯å¤±è´¥, å°è¯• {attempt + 1}/{retry}")
                else:
                    logger.warning(f"SetWindowPos è¿”å›å¤±è´¥, å°è¯• {attempt + 1}/{retry}")

                time.sleep(0.5)

            except Exception as e:
                logger.error(f"ç§»åŠ¨å¾®ä¿¡çª—å£å¤±è´¥ (å°è¯• {attempt + 1}/{retry}): {e}")
                time.sleep(0.5)

        return False

    def _verify_window_position(self, hwnd: int, target_x: int, target_y: int,
                                 target_width: int, target_height: int,
                                 tolerance: int = 20) -> bool:
        """éªŒè¯çª—å£ä½ç½®æ˜¯å¦æ­£ç¡®"""
        try:
            rect = ctypes.wintypes.RECT()
            self.user32.GetWindowRect(hwnd, ctypes.byref(rect))

            actual_x = rect.left
            actual_y = rect.top
            actual_width = rect.right - rect.left
            actual_height = rect.bottom - rect.top

            return (
                abs(actual_x - target_x) <= tolerance and
                abs(actual_y - target_y) <= tolerance and
                abs(actual_width - target_width) <= tolerance and
                abs(actual_height - target_height) <= tolerance
            )
        except (OSError, ValueError):
            return False

    def ensure_wechat_foreground(self, wechat_hwnd: int, retry: int = 3) -> bool:
        """
        ç¡®ä¿å¾®ä¿¡åœ¨å‰å°

        Args:
            wechat_hwnd: å¾®ä¿¡çª—å£å¥æŸ„
            retry: é‡è¯•æ¬¡æ•°

        Returns:
            æ˜¯å¦æˆåŠŸ
        """
        for attempt in range(retry):
            try:
                # æ–¹æ³•1: SetForegroundWindow
                result = self.user32.SetForegroundWindow(wechat_hwnd)
                if result:
                    time.sleep(0.1)
                    # éªŒè¯æ˜¯å¦çœŸçš„åœ¨å‰å°
                    if self._is_foreground(wechat_hwnd):
                        return True

                # æ–¹æ³•2: æ¨¡æ‹Ÿ Alt é”® + SetForegroundWindow (ç»•è¿‡ Windows é™åˆ¶)
                self.user32.keybd_event(0x12, 0, 0, 0)  # Alt down
                self.user32.keybd_event(0x12, 0, 2, 0)  # Alt up
                time.sleep(0.1)
                self.user32.SetForegroundWindow(wechat_hwnd)

                if self._is_foreground(wechat_hwnd):
                    return True

                # æ–¹æ³•3: BringWindowToTop
                self.user32.BringWindowToTop(wechat_hwnd)
                if self._is_foreground(wechat_hwnd):
                    return True

                logger.warning(f"SetForegroundWindow å¤±è´¥, å°è¯• {attempt + 1}/{retry}")
                time.sleep(0.5)

            except Exception as e:
                logger.error(f"ç¡®ä¿å‰å°å¤±è´¥ (å°è¯• {attempt + 1}/{retry}): {e}")
                time.sleep(0.5)

        return False

    def _is_foreground(self, hwnd: int) -> bool:
        """æ£€æŸ¥çª—å£æ˜¯å¦åœ¨å‰å°"""
        return self.user32.GetForegroundWindow() == hwnd
```

### 16.2.1 å¤šæ˜¾ç¤ºå™¨å…œåº•ç­–ç•¥

å½“ä¸»å±åˆ†è¾¨ç‡ä¸è¶³æˆ–çª—å£æ“ä½œå¤±è´¥æ—¶çš„å…œåº•å¤„ç†ï¼š

```python
# core/display_fallback.py

from enum import Enum
from dataclasses import dataclass

class DisplayFallbackAction(Enum):
    """æ˜¾ç¤ºå™¨å…œåº•æ“ä½œ"""
    CONTINUE_ANYWAY = "continue"      # ç»§ç»­æ‰§è¡Œ (å¯èƒ½æœ‰é£é™©)
    PAUSE_FOR_MANUAL = "pause"        # æš‚åœç­‰å¾…äººå·¥å¹²é¢„
    SKIP_TASK = "skip"                # è·³è¿‡å½“å‰ä»»åŠ¡
    ABORT_SESSION = "abort"           # ä¸­æ­¢æœ¬æ¬¡ä¼šè¯

@dataclass
class DisplayCheckResult:
    """æ˜¾ç¤ºå™¨æ£€æŸ¥ç»“æœ"""
    passed: bool
    primary_resolution: tuple
    dpi_scale: float
    wechat_positioned: bool
    wechat_foreground: bool
    issues: list
    recommended_action: DisplayFallbackAction

class DisplayFallbackHandler:
    """æ˜¾ç¤ºå™¨å…œåº•å¤„ç†å™¨"""

    def __init__(self, config: dict, display_mgr: DisplayManager):
        self.config = config
        self.display_mgr = display_mgr
        self.min_resolution = config.get('min_resolution', (900, 700))

    def check_display_environment(self, wechat_hwnd: int) -> DisplayCheckResult:
        """
        æ£€æŸ¥æ˜¾ç¤ºå™¨ç¯å¢ƒ

        Returns:
            æ£€æŸ¥ç»“æœ, åŒ…å«é—®é¢˜åˆ—è¡¨å’Œå»ºè®®æ“ä½œ
        """
        issues = []

        # 1. æ£€æŸ¥ä¸»å±åˆ†è¾¨ç‡
        primary = self.display_mgr.get_primary_monitor()
        if primary['width'] < self.min_resolution[0] or primary['height'] < self.min_resolution[1]:
            issues.append(
                f"ä¸»å±åˆ†è¾¨ç‡ä¸è¶³: {primary['width']}x{primary['height']} "
                f"(éœ€è¦è‡³å°‘ {self.min_resolution[0]}x{self.min_resolution[1]})"
            )

        # 2. æ£€æŸ¥ DPI ç¼©æ”¾
        dpi_scale = self.display_mgr.get_dpi_scale()
        if dpi_scale > 1.5:
            issues.append(f"DPI ç¼©æ”¾è¿‡é«˜: {dpi_scale * 100:.0f}% (å»ºè®®ä¸è¶…è¿‡ 150%)")

        # 3. å°è¯•ç§»åŠ¨çª—å£
        positioned = self.display_mgr.move_wechat_to_primary(wechat_hwnd)
        if not positioned:
            issues.append("æ— æ³•å°†å¾®ä¿¡çª—å£ç§»åŠ¨åˆ°ä¸»å±")

        # 4. å°è¯•å‰å°
        foreground = self.display_mgr.ensure_wechat_foreground(wechat_hwnd)
        if not foreground:
            issues.append("æ— æ³•å°†å¾®ä¿¡çª—å£ç½®äºå‰å°")

        # ç¡®å®šå»ºè®®æ“ä½œ
        if not issues:
            action = DisplayFallbackAction.CONTINUE_ANYWAY
        elif not positioned or not foreground:
            action = DisplayFallbackAction.PAUSE_FOR_MANUAL
        elif len(issues) == 1 and 'DPI' in issues[0]:
            action = DisplayFallbackAction.CONTINUE_ANYWAY  # DPI é—®é¢˜å¯ä»¥ç»§ç»­
        else:
            action = DisplayFallbackAction.PAUSE_FOR_MANUAL

        return DisplayCheckResult(
            passed=len(issues) == 0,
            primary_resolution=(primary['width'], primary['height']),
            dpi_scale=dpi_scale,
            wechat_positioned=positioned,
            wechat_foreground=foreground,
            issues=issues,
            recommended_action=action
        )

    def handle_check_result(self, result: DisplayCheckResult) -> bool:
        """
        å¤„ç†æ£€æŸ¥ç»“æœ

        Returns:
            æ˜¯å¦å¯ä»¥ç»§ç»­æ‰§è¡Œ
        """
        if result.passed:
            return True

        logger.warning(f"æ˜¾ç¤ºå™¨ç¯å¢ƒæ£€æŸ¥å‘ç°é—®é¢˜: {result.issues}")

        if result.recommended_action == DisplayFallbackAction.CONTINUE_ANYWAY:
            logger.info("é—®é¢˜è¾ƒè½», ç»§ç»­æ‰§è¡Œ")
            return True

        elif result.recommended_action == DisplayFallbackAction.PAUSE_FOR_MANUAL:
            # å¼¹å‡ºäººå·¥å¹²é¢„å¯¹è¯æ¡†
            return self._request_manual_intervention(result)

        elif result.recommended_action == DisplayFallbackAction.SKIP_TASK:
            logger.warning("è·³è¿‡å½“å‰ä»»åŠ¡")
            return False

        elif result.recommended_action == DisplayFallbackAction.ABORT_SESSION:
            logger.error("ä¸­æ­¢æœ¬æ¬¡ä¼šè¯")
            raise DisplayEnvironmentError("æ˜¾ç¤ºå™¨ç¯å¢ƒä¸æ»¡è¶³è¿è¡Œæ¡ä»¶")

        return False

    def _request_manual_intervention(self, result: DisplayCheckResult) -> bool:
        """è¯·æ±‚äººå·¥å¹²é¢„"""
        from PySide6.QtWidgets import QMessageBox

        msg = "æ£€æµ‹åˆ°æ˜¾ç¤ºå™¨ç¯å¢ƒé—®é¢˜:\n\n"
        for issue in result.issues:
            msg += f"â€¢ {issue}\n"

        msg += "\nè¯·æ‰‹åŠ¨è°ƒæ•´ä»¥ä¸‹å†…å®¹:\n"
        if not result.wechat_positioned:
            msg += "â€¢ å°†å¾®ä¿¡çª—å£ç§»åŠ¨åˆ°ä¸»å±å¹•å·¦ä¸Šè§’\n"
        if not result.wechat_foreground:
            msg += "â€¢ ç¡®ä¿å¾®ä¿¡çª—å£åœ¨æœ€å‰é¢\n"

        msg += "\nè°ƒæ•´å®Œæˆåç‚¹å‡»ã€Œé‡è¯•ã€,æˆ–ç‚¹å‡»ã€Œè·³è¿‡ã€è·³è¿‡æœ¬æ¬¡ä»»åŠ¡ã€‚"

        reply = QMessageBox.warning(
            None, "æ˜¾ç¤ºå™¨ç¯å¢ƒé—®é¢˜",
            msg,
            QMessageBox.Retry | QMessageBox.Ignore | QMessageBox.Abort,
            QMessageBox.Retry
        )

        if reply == QMessageBox.Retry:
            logger.info("ç”¨æˆ·é€‰æ‹©é‡è¯•")
            return True  # è¿”å›åé‡æ–°æ£€æŸ¥
        elif reply == QMessageBox.Ignore:
            logger.info("ç”¨æˆ·é€‰æ‹©è·³è¿‡")
            return False
        else:
            raise DisplayEnvironmentError("ç”¨æˆ·ä¸­æ­¢æ“ä½œ")
```

**é…ç½®:**

```yaml
display:
  # æœ€å°åˆ†è¾¨ç‡è¦æ±‚
  min_resolution:
    width: 900
    height: 700

  # è‡ªåŠ¨çª—å£å®šä½
  auto_position_wechat: true
  window_position:
    x: 50
    y: 50

  # å…œåº•ç­–ç•¥
  fallback:
    on_position_fail: "pause"      # continue/pause/skip/abort
    on_foreground_fail: "pause"
    on_resolution_low: "continue"
    max_retry: 3
    retry_interval: 1.0            # ç§’
```

### 16.2.2 é‡è¯•ç”¨å°½åçš„é˜Ÿåˆ—å¤„ç†ç­–ç•¥

> **æ ¸å¿ƒåŸåˆ™**: é‡è¯•æ¬¡æ•°ç”¨å°½åï¼Œä»»åŠ¡ä¸èƒ½ç®€å•ä¸¢å¼ƒï¼Œéœ€æ˜ç¡®å¤„ç†å¹¶é€šçŸ¥ç›¸å…³æ–¹ã€‚

```python
# core/display_retry_exhausted.py

from enum import Enum
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

class RetryExhaustedAction(Enum):
    """é‡è¯•ç”¨å°½åçš„å¤„ç†åŠ¨ä½œ"""
    MOVE_TO_FAILED = "failed"           # æ ‡è®°å¤±è´¥ï¼Œç§»å…¥å¤±è´¥é˜Ÿåˆ—
    MOVE_TO_MANUAL = "manual"           # ç§»å…¥äººå·¥å¤„ç†é˜Ÿåˆ—
    RESCHEDULE_LATER = "reschedule"     # å»¶è¿Ÿé‡æ–°è°ƒåº¦
    PAUSE_ALL = "pause_all"             # æš‚åœæ•´ä¸ªé˜Ÿåˆ—

@dataclass
class RetryExhaustedEvent:
    """é‡è¯•ç”¨å°½äº‹ä»¶"""
    task_id: str
    task_type: str
    retry_count: int
    last_error: str
    display_issues: list
    timestamp: datetime

class DisplayRetryExhaustedHandler:
    """æ˜¾ç¤ºå™¨é‡è¯•ç”¨å°½å¤„ç†å™¨"""

    def __init__(self, config: dict, queue_manager: 'TaskQueueManager',
                 alert_manager: 'AlertManager'):
        self.config = config
        self.queue_manager = queue_manager
        self.alert_manager = alert_manager

        # é»˜è®¤ç­–ç•¥: ç§»å…¥äººå·¥å¤„ç†é˜Ÿåˆ—
        self.default_action = RetryExhaustedAction(
            config.get('retry_exhausted_action', 'manual')
        )

        # è¿ç»­å¤±è´¥è®¡æ•°å™¨
        self._consecutive_failures = 0
        self._consecutive_threshold = config.get('consecutive_failure_threshold', 3)

    def handle_retry_exhausted(
        self,
        task,
        retry_count: int,
        last_error: str,
        display_check_result: 'DisplayCheckResult'
    ) -> dict:
        """
        å¤„ç†é‡è¯•ç”¨å°½

        Returns:
            {'action': str, 'next_task': Optional[Task], 'queue_paused': bool}
        """
        event = RetryExhaustedEvent(
            task_id=task.id,
            task_type=task.channel,
            retry_count=retry_count,
            last_error=last_error,
            display_issues=display_check_result.issues if display_check_result else [],
            timestamp=datetime.now()
        )

        # è®°å½•äº‹ä»¶
        self._log_event(event)

        # æ›´æ–°è¿ç»­å¤±è´¥è®¡æ•°
        self._consecutive_failures += 1

        # è¿ç»­å¤±è´¥è¾¾åˆ°é˜ˆå€¼ï¼Œå‡çº§å¤„ç†
        if self._consecutive_failures >= self._consecutive_threshold:
            logger.warning(
                f"è¿ç»­ {self._consecutive_failures} ä¸ªä»»åŠ¡æ˜¾ç¤ºå™¨é‡è¯•ç”¨å°½ï¼Œ"
                "è§¦å‘é˜Ÿåˆ—æš‚åœ"
            )
            return self._handle_pause_all(event)

        # æ ¹æ®é…ç½®æ‰§è¡Œé»˜è®¤ç­–ç•¥
        if self.default_action == RetryExhaustedAction.MOVE_TO_FAILED:
            return self._move_to_failed(task, event)

        elif self.default_action == RetryExhaustedAction.MOVE_TO_MANUAL:
            return self._move_to_manual(task, event)

        elif self.default_action == RetryExhaustedAction.RESCHEDULE_LATER:
            return self._reschedule_later(task, event)

        elif self.default_action == RetryExhaustedAction.PAUSE_ALL:
            return self._handle_pause_all(event)

    def _move_to_failed(self, task, event: RetryExhaustedEvent) -> dict:
        """ç§»å…¥å¤±è´¥é˜Ÿåˆ—"""
        task.status = 'failed'
        task.error_message = (
            f"æ˜¾ç¤ºå™¨é‡è¯•ç”¨å°½ (å…± {event.retry_count} æ¬¡): {event.last_error}"
        )
        task.failed_at = datetime.now()

        # ä¿å­˜åˆ°æ•°æ®åº“
        self.queue_manager.update_task(task)

        # å‘é€å‘Šè­¦
        self._send_alert(event, urgent=False)

        logger.warning(f"ä»»åŠ¡ {task.id} å·²ç§»å…¥å¤±è´¥é˜Ÿåˆ—")

        return {
            'action': 'move_to_failed',
            'next_task': self.queue_manager.get_next_pending(),
            'queue_paused': False
        }

    def _move_to_manual(self, task, event: RetryExhaustedEvent) -> dict:
        """ç§»å…¥äººå·¥å¤„ç†é˜Ÿåˆ— (ä½¿ç”¨ paused çŠ¶æ€ä¿æŒæšä¸¾ä¸€è‡´)"""
        task.status = 'paused'  # è§„èŒƒçŠ¶æ€å€¼
        task.pause_reason = 'manual_review'  # äººå·¥å®¡æ ¸æ ‡è®°
        task.pause_detail = (
            f"æ˜¾ç¤ºå™¨ç¯å¢ƒé—®é¢˜é‡è¯• {event.retry_count} æ¬¡åä»å¤±è´¥:\n"
            + "\n".join(event.display_issues)
        )
        task.paused_at = datetime.now()

        # ä¿å­˜åˆ°æ•°æ®åº“
        self.queue_manager.update_task(task)

        # å‘é€å‘Šè­¦
        self._send_alert(event, urgent=True)

        logger.warning(f"ä»»åŠ¡ {task.id} å·²ç§»å…¥äººå·¥å®¡æ ¸é˜Ÿåˆ—")

        return {
            'action': 'move_to_manual',
            'next_task': self.queue_manager.get_next_pending(),
            'queue_paused': False
        }

    def _reschedule_later(self, task, event: RetryExhaustedEvent) -> dict:
        """å»¶è¿Ÿé‡æ–°è°ƒåº¦"""
        delay_minutes = self.config.get('reschedule_delay_minutes', 30)

        task.status = 'scheduled'
        task.scheduled_time = datetime.now() + timedelta(minutes=delay_minutes)
        task.reschedule_count = (task.reschedule_count or 0) + 1

        # æ£€æŸ¥é‡è°ƒåº¦æ¬¡æ•°ä¸Šé™
        max_reschedules = self.config.get('max_reschedule_count', 3)
        if task.reschedule_count >= max_reschedules:
            logger.warning(f"ä»»åŠ¡ {task.id} é‡è°ƒåº¦æ¬¡æ•°å·²è¾¾ä¸Šé™ï¼Œè½¬ä¸ºå¤±è´¥")
            return self._move_to_failed(task, event)

        # ä¿å­˜åˆ°æ•°æ®åº“
        self.queue_manager.update_task(task)

        logger.info(
            f"ä»»åŠ¡ {task.id} å·²é‡æ–°è°ƒåº¦åˆ° "
            f"{task.scheduled_time.strftime('%H:%M')} (ç¬¬ {task.reschedule_count} æ¬¡)"
        )

        return {
            'action': 'reschedule_later',
            'next_task': self.queue_manager.get_next_pending(),
            'queue_paused': False
        }

    def _handle_pause_all(self, event: RetryExhaustedEvent) -> dict:
        """æš‚åœæ•´ä¸ªé˜Ÿåˆ—"""
        # æš‚åœé˜Ÿåˆ—
        self.queue_manager.pause()

        # å‘é€ç´§æ€¥å‘Šè­¦
        self.alert_manager.send_urgent_alert_custom(
            subject="[ç´§æ€¥] ä»»åŠ¡é˜Ÿåˆ—å·²æš‚åœ - è¿ç»­æ˜¾ç¤ºå™¨ç¯å¢ƒå¤±è´¥",
            body=f"""
            ç”±äºè¿ç»­ {self._consecutive_failures} ä¸ªä»»åŠ¡å› æ˜¾ç¤ºå™¨ç¯å¢ƒé—®é¢˜å¤±è´¥ï¼Œ
            ä»»åŠ¡é˜Ÿåˆ—å·²è‡ªåŠ¨æš‚åœã€‚

            æœ€åä¸€ä¸ªå¤±è´¥ä»»åŠ¡: {event.task_id}
            é”™è¯¯ä¿¡æ¯: {event.last_error}
            æ˜¾ç¤ºå™¨é—®é¢˜: {', '.join(event.display_issues)}

            è¯·æ£€æŸ¥:
            1. æ˜¾ç¤ºå™¨æ˜¯å¦æ­£å¸¸è¿æ¥
            2. å¾®ä¿¡çª—å£æ˜¯å¦å¯ç”¨
            3. è¿œç¨‹æ¡Œé¢ä¼šè¯æ˜¯å¦æ­£å¸¸

            ç¡®è®¤é—®é¢˜è§£å†³åï¼Œè¯·æ‰‹åŠ¨æ¢å¤é˜Ÿåˆ—è¿è¡Œã€‚
            """
        )

        logger.error("é˜Ÿåˆ—å·²æš‚åœï¼Œç­‰å¾…äººå·¥å¹²é¢„")

        return {
            'action': 'pause_all',
            'next_task': None,
            'queue_paused': True
        }

    def reset_consecutive_failures(self):
        """é‡ç½®è¿ç»­å¤±è´¥è®¡æ•° (ä»»åŠ¡æˆåŠŸæ—¶è°ƒç”¨)"""
        if self._consecutive_failures > 0:
            logger.debug(f"é‡ç½®è¿ç»­å¤±è´¥è®¡æ•° (ä¹‹å‰: {self._consecutive_failures})")
            self._consecutive_failures = 0

    def _log_event(self, event: RetryExhaustedEvent):
        """è®°å½•äº‹ä»¶åˆ°æ—¥å¿—"""
        logger.warning(
            f"[é‡è¯•ç”¨å°½] task_id={event.task_id}, "
            f"retry_count={event.retry_count}, "
            f"error={event.last_error}, "
            f"issues={event.display_issues}"
        )

    def _send_alert(self, event: RetryExhaustedEvent, urgent: bool):
        """å‘é€å‘Šè­¦"""
        subject = (
            f"[{'ç´§æ€¥' if urgent else 'è­¦å‘Š'}] ä»»åŠ¡æ˜¾ç¤ºå™¨é‡è¯•ç”¨å°½ - {event.task_id}"
        )

        body = f"""
        ä»»åŠ¡æ˜¾ç¤ºå™¨é‡è¯•ç”¨å°½

        ä»»åŠ¡ID: {event.task_id}
        ä»»åŠ¡ç±»å‹: {event.task_type}
        é‡è¯•æ¬¡æ•°: {event.retry_count}
        æœ€åé”™è¯¯: {event.last_error}

        æ˜¾ç¤ºå™¨é—®é¢˜:
        {chr(10).join('- ' + issue for issue in event.display_issues) or 'æ— '}

        å¤„ç†å»ºè®®:
        1. æ£€æŸ¥ç”µè„‘Bçš„æ˜¾ç¤ºå™¨æ˜¯å¦æ­£å¸¸
        2. æ£€æŸ¥è¿œç¨‹æ¡Œé¢ä¼šè¯æ˜¯å¦æ´»è·ƒ
        3. ç¡®è®¤å¾®ä¿¡çª—å£çŠ¶æ€æ­£å¸¸
        """

        if urgent:
            self.alert_manager.send_urgent_alert_custom(subject=subject, body=body)
        else:
            self.alert_manager.send_normal_alert_custom(subject=subject, body=body)
```

**é…ç½®:**

```yaml
display:
  fallback:
    # ... åŸºç¡€é…ç½® ...

    # é‡è¯•ç”¨å°½ç­–ç•¥
    retry_exhausted:
      # failed: ç§»å…¥å¤±è´¥é˜Ÿåˆ—
      # manual: ç§»å…¥äººå·¥å¤„ç†é˜Ÿåˆ— (æ¨è)
      # reschedule: å»¶è¿Ÿé‡æ–°è°ƒåº¦
      # pause_all: æš‚åœæ•´ä¸ªé˜Ÿåˆ—
      action: "manual"

      # å»¶è¿Ÿé‡è°ƒåº¦é…ç½® (ä»… reschedule ç”Ÿæ•ˆ)
      reschedule_delay_minutes: 30
      max_reschedule_count: 3

      # è¿ç»­å¤±è´¥é˜ˆå€¼ (è¶…è¿‡åè‡ªåŠ¨æš‚åœé˜Ÿåˆ—)
      consecutive_failure_threshold: 3
```

**ä¸æ‰§è¡Œæµç¨‹é›†æˆ:**

```python
# åœ¨ä»»åŠ¡æ‰§è¡Œå™¨ä¸­

class TaskExecutor:
    def __init__(self, ...):
        self.display_fallback = DisplayFallbackHandler(config, display_mgr)
        self.retry_exhausted_handler = DisplayRetryExhaustedHandler(
            config, queue_manager, alert_manager
        )

    def execute_task(self, task) -> dict:
        max_retries = self.config.get('display_max_retry', 3)

        for attempt in range(max_retries):
            # æ£€æŸ¥æ˜¾ç¤ºå™¨ç¯å¢ƒ
            check_result = self.display_fallback.check_display_environment(wechat_hwnd)

            if check_result.passed:
                # ç¯å¢ƒæ­£å¸¸ï¼Œæ‰§è¡Œä»»åŠ¡
                result = self._do_execute(task)
                if result.get('status') == 'success':
                    # æˆåŠŸï¼Œé‡ç½®è¿ç»­å¤±è´¥è®¡æ•°
                    self.retry_exhausted_handler.reset_consecutive_failures()
                return result

            # å¤„ç†æ£€æŸ¥ç»“æœ
            can_continue = self.display_fallback.handle_check_result(check_result)

            if can_continue:
                continue  # é‡è¯•

            if attempt == max_retries - 1:
                # é‡è¯•ç”¨å°½
                return self.retry_exhausted_handler.handle_retry_exhausted(
                    task,
                    retry_count=max_retries,
                    last_error=str(check_result.issues),
                    display_check_result=check_result
                )

            # ç­‰å¾…åé‡è¯•
            time.sleep(self.config.get('display_retry_interval', 1.0))

        return {'status': 'failed', 'reason': 'æ˜¾ç¤ºå™¨ç¯å¢ƒæ£€æŸ¥å¤±è´¥'}
```

### 16.3 åæ ‡è½¬æ¢ç­–ç•¥

```python
class CoordinateStrategy:
    """åæ ‡è½¬æ¢ç­–ç•¥"""

    def __init__(self, dpi_scale: float = 1.0):
        self.dpi_scale = dpi_scale

    def to_physical(self, logical_x: int, logical_y: int) -> tuple:
        """é€»è¾‘åæ ‡è½¬ç‰©ç†åæ ‡ (ç”¨äº pyautogui)"""
        return (
            int(logical_x * self.dpi_scale),
            int(logical_y * self.dpi_scale)
        )

    def from_physical(self, physical_x: int, physical_y: int) -> tuple:
        """ç‰©ç†åæ ‡è½¬é€»è¾‘åæ ‡ (ç”¨äº uiautomation)"""
        return (
            int(physical_x / self.dpi_scale),
            int(physical_y / self.dpi_scale)
        )
```

### 16.4 æ‰§è¡Œå‰ç½®å‡†å¤‡

```python
def prepare_execution_environment():
    """æ‰§è¡Œä»»åŠ¡å‰çš„ç¯å¢ƒå‡†å¤‡"""

    display_mgr = DisplayManager()
    dpi_scale = display_mgr.get_dpi_scale()

    # 1. æ£€æŸ¥ DPI ç¼©æ”¾
    if dpi_scale != 1.0:
        logger.warning(f"æ£€æµ‹åˆ°é 100% ç¼©æ”¾ ({dpi_scale * 100:.0f}%), å°†å¯ç”¨åæ ‡è½¬æ¢")
        config['coordinate_strategy'] = 'scaled'
    else:
        config['coordinate_strategy'] = 'direct'

    # 2. è·å–å¾®ä¿¡çª—å£å¥æŸ„
    import uiautomation as auto
    wechat = auto.WindowControl(ClassName='WeChatMainWndForPC')
    if not wechat.Exists(3):
        raise WeChatNotFoundError("æœªæ‰¾åˆ°å¾®ä¿¡çª—å£")

    hwnd = wechat.NativeWindowHandle

    # 3. ç§»åŠ¨å¾®ä¿¡åˆ°ä¸»å±å›ºå®šä½ç½®
    if config.get('auto_position_wechat', True):
        display_mgr.move_wechat_to_primary(hwnd)
        time.sleep(0.5)  # ç­‰å¾…çª—å£ç§»åŠ¨å®Œæˆ

    # 4. ç¡®ä¿å¾®ä¿¡åœ¨å‰å°
    display_mgr.ensure_wechat_foreground(hwnd)

    # 5. ç­‰å¾…çª—å£ç¨³å®š
    time.sleep(0.3)

    logger.info("æ‰§è¡Œç¯å¢ƒå‡†å¤‡å®Œæˆ")
```

### 16.5 é…ç½®é€‰é¡¹

```yaml
# config.yaml
display:
  # çª—å£ä½ç½®ç®¡ç†
  auto_position_wechat: true    # è‡ªåŠ¨ç§»åŠ¨å¾®ä¿¡åˆ°ä¸»å±
  wechat_position:
    x: 50
    y: 50
    width: 900
    height: 700

  # DPI å¤„ç†
  dpi_aware: true               # å¯ç”¨ DPI æ„ŸçŸ¥
  coordinate_strategy: auto     # auto / direct / scaled

  # å¤šæ˜¾ç¤ºå™¨
  force_primary_monitor: true   # å¼ºåˆ¶ä½¿ç”¨ä¸»æ˜¾ç¤ºå™¨
  monitor_index: 0              # æŒ‡å®šæ˜¾ç¤ºå™¨ç´¢å¼• (0=ä¸»å±)
```

### 16.6 å¸¸è§é—®é¢˜å¤„ç†

| é—®é¢˜ | åŸå›  | è§£å†³æ–¹æ¡ˆ |
|------|------|----------|
| ç‚¹å‡»åç§» | DPI ç¼©æ”¾ä¸ä¸º 100% | å¯ç”¨åæ ‡è½¬æ¢ç­–ç•¥ |
| å…ƒç´ æ‰¾ä¸åˆ° | çª—å£åœ¨å‰¯å± | ç§»åŠ¨åˆ°ä¸»å±åé‡è¯• |
| çª—å£è¢«é®æŒ¡ | å…¶ä»–çª—å£è¦†ç›– | å¼ºåˆ¶ç½®é¡¶ + BlockInput |
| æˆªå›¾åŒºåŸŸé”™è¯¯ | å¤šå±åæ ‡è®¡ç®— | ä½¿ç”¨çª—å£ç›¸å¯¹åæ ‡ |

### 16.7 å¤šæ˜¾ç¤ºå™¨éªŒè¯çŸ©é˜µ

> **æµ‹è¯•åŸºå‡†**: å‘å¸ƒå‰å¿…é¡»åœ¨ä»¥ä¸‹å…¸å‹é…ç½®ä¸­éªŒè¯é€šè¿‡ã€‚

#### 16.7.1 å¿…æµ‹é…ç½®çŸ©é˜µ

| é…ç½®ID | åˆ†è¾¨ç‡ | DPI | æ˜¾ç¤ºå™¨æ•° | å¾®ä¿¡ä½ç½® | éªŒæ”¶æ ‡å‡† |
|--------|--------|-----|----------|----------|----------|
| **CFG-1** | 1920x1080 | 100% | å•å± | ä»»æ„ | åŸºå‡†é…ç½®ï¼Œå¿…é¡»é€šè¿‡ |
| **CFG-2** | 2560x1440 | 100% | å•å± | ä»»æ„ | é«˜åˆ†è¾¨ç‡éªŒè¯ |
| **CFG-3** | 1920x1080 | 125% | å•å± | ä»»æ„ | å¸¸è§ DPI ç¼©æ”¾ |
| **CFG-4** | 1920x1080 | 150% | å•å± | ä»»æ„ | é«˜ DPI ç¼©æ”¾ |
| **CFG-5** | åŒå± (ä¸»1920+å‰¯1080) | 100% | åŒå± | ä¸»å± | å¤šå±åŸºå‡† |
| **CFG-6** | åŒå± (ä¸»1920+å‰¯1080) | 100% | åŒå± | å‰¯å± | å‰¯å±çª—å£ç§»åŠ¨ |
| **CFG-7** | åŒå± (ä¸»125%+å‰¯100%) | æ··åˆDPI | åŒå± | ä¸»å± | æ··åˆ DPI |

#### 16.7.2 éªŒè¯æµ‹è¯•ç”¨ä¾‹

| ç”¨ä¾‹ | æ“ä½œ | é¢„æœŸç»“æœ |
|------|------|----------|
| TC-01 | å¯åŠ¨ç¨‹åºï¼Œæ‰§è¡Œæœ‹å‹åœˆå‘å¸ƒ | æˆåŠŸå‘å¸ƒï¼Œæˆªå›¾æ­£ç¡® |
| TC-02 | çª—å£åœ¨å‰¯å±æ—¶æ‰§è¡Œä»»åŠ¡ | è‡ªåŠ¨ç§»åŠ¨åˆ°ä¸»å±åæˆåŠŸ |
| TC-03 | 125% DPI ä¸‹æ‰§è¡Œä»»åŠ¡ | åæ ‡è½¬æ¢æ­£ç¡®ï¼Œç‚¹å‡»å‡†ç¡® |
| TC-04 | å¾®ä¿¡çª—å£è¢«é®æŒ¡æ—¶æ‰§è¡Œ | è‡ªåŠ¨ç½®é¡¶åæˆåŠŸ |
| TC-05 | å¾®ä¿¡çª—å£æœ€å°åŒ–æ—¶æ‰§è¡Œ | è‡ªåŠ¨æ¢å¤çª—å£åæˆåŠŸ |
| TC-06 | è¿ç»­æ‰§è¡Œ10ä¸ªä»»åŠ¡ | æ— åæ ‡æ¼‚ç§»ï¼Œå…¨éƒ¨æˆåŠŸ |

#### 16.7.3 ä¸æ”¯æŒé…ç½® (æ˜ç¡®æ’é™¤)

ä»¥ä¸‹é…ç½® **ä¸ä¿è¯æ”¯æŒ**ï¼Œç”¨æˆ·éœ€è‡ªè¡Œè°ƒæ•´:

| é…ç½® | åŸå›  | å»ºè®® |
|------|------|------|
| åˆ†è¾¨ç‡ < 1280x720 | å…ƒç´ å¯èƒ½é‡å  | å‡çº§åˆ†è¾¨ç‡ |
| DPI > 200% | åæ ‡è½¬æ¢è¯¯å·®å¤§ | é™ä½ DPI æˆ–ä½¿ç”¨ç‹¬ç«‹æ˜¾ç¤ºå™¨ |
| 3+ æ˜¾ç¤ºå™¨ | æœªå……åˆ†æµ‹è¯• | å°†å¾®ä¿¡å›ºå®šåœ¨ä¸»å± |
| ç«–å±æ˜¾ç¤ºå™¨ | æœªæ”¯æŒ | ä½¿ç”¨æ¨ªå±æ˜¾ç¤ºå™¨ |
| è¿œç¨‹æ¡Œé¢ | åæ ‡ç³»ç»Ÿä¸ä¸€è‡´ | æœ¬åœ°è¿è¡Œ |

### 16.8 ç”¨æˆ·åŠ¨ä½œæŒ‡å¼• (æ˜¾ç¤ºå™¨ç›¸å…³)

> **å½“æ˜¾ç¤ºå™¨ç›¸å…³é”™è¯¯å‘ç”Ÿæ—¶ï¼Œç”¨æˆ·åº”é‡‡å–çš„æ“ä½œã€‚**

#### 16.8.1 é”™è¯¯ä¸æ¢å¤æ“ä½œå¯¹ç…§è¡¨

| é”™è¯¯æ¶ˆæ¯ | ç”¨æˆ·æ“ä½œ | æ­¥éª¤è¯¦æƒ… |
|----------|----------|----------|
| "çª—å£ç§»åŠ¨å¤±è´¥" | æ‰‹åŠ¨ç§»åŠ¨å¾®ä¿¡çª—å£ | 1. å°†å¾®ä¿¡æ‹–åˆ°ä¸»æ˜¾ç¤ºå™¨ 2. ç¡®ä¿å®Œå…¨å¯è§ 3. ç‚¹å‡»é‡è¯• |
| "çª—å£ç½®é¡¶å¤±è´¥" | å…³é—­é®æŒ¡çª—å£ | 1. æœ€å°åŒ–å…¶ä»–çª—å£ 2. ç¡®ä¿å¾®ä¿¡åœ¨æœ€ä¸Šå±‚ 3. ç‚¹å‡»é‡è¯• |
| "DPI ä¸æ”¯æŒ" | è°ƒæ•´ç³»ç»Ÿè®¾ç½® | 1. å³é”®æ¡Œé¢â†’æ˜¾ç¤ºè®¾ç½® 2. ç¼©æ”¾è°ƒä¸º100% 3. é‡å¯ç¨‹åº |
| "åˆ†è¾¨ç‡è¿‡ä½" | è°ƒæ•´åˆ†è¾¨ç‡ | 1. å³é”®æ¡Œé¢â†’æ˜¾ç¤ºè®¾ç½® 2. åˆ†è¾¨ç‡è‡³å°‘1280x720 3. é‡å¯ç¨‹åº |
| "æ£€æµ‹åˆ°å¤šæ˜¾ç¤ºå™¨" | ç¡®è®¤å¾®ä¿¡ä½ç½® | 1. ç¡®ä¿å¾®ä¿¡åœ¨ä¸»æ˜¾ç¤ºå™¨ 2. æˆ–å‹¾é€‰"å¼ºåˆ¶ä¸»æ˜¾ç¤ºå™¨" |
| "åæ ‡è¶…å‡ºå±å¹•" | æ£€æŸ¥çª—å£ä½ç½® | 1. å¾®ä¿¡çª—å£å¯èƒ½éƒ¨åˆ†åœ¨å±å¹•å¤– 2. å®Œæ•´æ‹–å…¥å±å¹•å†… |

#### 16.8.2 BlockInput ä¸ç®¡ç†å‘˜æƒé™

| åœºæ™¯ | æ˜¯å¦éœ€è¦ç®¡ç†å‘˜ | é™çº§è¡Œä¸º |
|------|---------------|----------|
| æ™®é€šæ‰§è¡Œ | å¦ | æ­£å¸¸å·¥ä½œ |
| å¯ç”¨ BlockInput | æ˜¯ | æ— ç®¡ç†å‘˜æƒé™æ—¶è‡ªåŠ¨è·³è¿‡ |
| UAC å¼¹çª—å‡ºç° | - | ç­‰å¾…ç”¨æˆ·ç¡®è®¤æˆ–è‡ªåŠ¨å–æ¶ˆ |

**ç®¡ç†å‘˜æƒé™è·å–æ–¹å¼:**

```
æ–¹å¼ 1: å³é”®ç¨‹åº â†’ ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œ
æ–¹å¼ 2: å¿«æ·æ–¹å¼å±æ€§ â†’ å…¼å®¹æ€§ â†’ ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œæ­¤ç¨‹åº
æ–¹å¼ 3: é…ç½®æ–‡ä»¶è®¾ç½® block_input: false ç¦ç”¨è¯¥åŠŸèƒ½
```

#### 16.8.3 æ˜¾ç¤ºå™¨å¤±è´¥åçš„æœ€ç»ˆç”¨æˆ·åŠ¨ä½œ

å½“æ‰€æœ‰è‡ªåŠ¨é‡è¯•ç”¨å°½åï¼Œç³»ç»Ÿæ˜¾ç¤ºä»¥ä¸‹å¯¹è¯æ¡†:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [è­¦å‘Š] æ˜¾ç¤ºå™¨æ“ä½œå¤±è´¥                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  æ— æ³•å°†å¾®ä¿¡çª—å£ç§»åŠ¨åˆ°å¯æ“ä½œä½ç½®ã€‚                    â”‚
â”‚                                                     â”‚
â”‚  è¯·æ‰‹åŠ¨æ‰§è¡Œä»¥ä¸‹æ“ä½œ:                                â”‚
â”‚                                                     â”‚
â”‚  1. å°†å¾®ä¿¡çª—å£æ‹–åˆ°ä¸»æ˜¾ç¤ºå™¨                          â”‚
â”‚  2. ç¡®ä¿çª—å£å®Œå…¨å¯è§ï¼Œæ²¡æœ‰è¢«é®æŒ¡                    â”‚
â”‚  3. å¦‚æœä½¿ç”¨å¤šæ˜¾ç¤ºå™¨ï¼Œè€ƒè™‘æ–­å¼€å‰¯å±                  â”‚
â”‚  4. æ£€æŸ¥ DPI ç¼©æ”¾æ˜¯å¦ä¸º 100%                        â”‚
â”‚                                                     â”‚
â”‚  å®Œæˆåç‚¹å‡»"é‡è¯•"ç»§ç»­æ‰§è¡Œä»»åŠ¡ã€‚                     â”‚
â”‚                                                     â”‚
â”‚  [é‡è¯•]    [è·³è¿‡æ­¤ä»»åŠ¡]    [æš‚åœé˜Ÿåˆ—]               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## åä¸ƒã€å®‰å…¨æ¨¡å¼ä¸æµ‹è¯•æ¨¡å¼

### 17.1 æ¨¡å¼å®šä¹‰

| æ¨¡å¼ | ç”¨é€” | æœ‹å‹åœˆ | ç¾¤å‘ | é€Ÿç‡ |
|------|------|--------|------|------|
| **æ­£å¸¸æ¨¡å¼** | æ—¥å¸¸ä½¿ç”¨ | å¯ç”¨ | å¯ç”¨ | æ ‡å‡† |
| **æµ‹è¯•æ¨¡å¼** | åŠŸèƒ½éªŒè¯ | ç¦ç”¨ | ä»…æµ‹è¯•ç¾¤ | å¿«é€Ÿ |
| **å®‰å…¨æ¨¡å¼** | é£é™©è§„é¿ | å¯ç”¨ | å¯ç”¨ | é™é€Ÿ+å¤§æŠ–åŠ¨ |
| **æ¼”ç»ƒæ¨¡å¼** | å¹²è·‘éªŒè¯ | æ¨¡æ‹Ÿ | æ¨¡æ‹Ÿ | å³æ—¶ |

### 17.2 é…ç½®

```yaml
# config.yaml
run_mode: safe  # safe (ç”Ÿäº§é»˜è®¤) / normal / test / dry_run
# æ³¨: ç”Ÿäº§ç¯å¢ƒé¦–æ¬¡éƒ¨ç½²å»ºè®®ä½¿ç”¨ safe æ¨¡å¼ï¼Œç¡®è®¤æ— è¯¯åå†åˆ‡æ¢åˆ° normal

modes:
  test:
    description: "æµ‹è¯•æ¨¡å¼ - ä»…å‘é€åˆ°æµ‹è¯•ç¾¤"
    moment_enabled: false
    allowed_groups:
      - "æµ‹è¯•ç¾¤1"
      - "å†…éƒ¨æµ‹è¯•ç¾¤"
    rate_limit:
      base_interval: 30      # å¿«é€Ÿæµ‹è¯•
      jitter_range: [0, 10]

  safe:
    description: "å®‰å…¨æ¨¡å¼ - é™é€Ÿè¿è¡Œ"
    moment_enabled: true
    group_enabled: true
    rate_limit:
      base_interval: 300     # 5åˆ†é’Ÿé—´éš”
      jitter_range: [60, 180]  # 1-3åˆ†é’ŸéšæœºæŠ–åŠ¨
    max_daily_moment: 3      # æ¯æ—¥æœ€å¤š3æ¡æœ‹å‹åœˆ
    max_daily_group: 10      # æ¯æ—¥æœ€å¤š10æ¡ç¾¤å‘

  dry_run:
    description: "æ¼”ç»ƒæ¨¡å¼ - ä¸å®é™…å‘é€"
    moment_enabled: true     # é€»è¾‘æ‰§è¡Œ, ä½†ä¸çœŸæ­£å‘é€
    group_enabled: true
    actually_send: false     # å…³é”®å¼€å…³
    log_as_success: true     # æ¨¡æ‹ŸæˆåŠŸ
```

### 17.3 æ¨¡å¼åˆ‡æ¢ UI

```python
class ModeSelector(QComboBox):
    """è¿è¡Œæ¨¡å¼é€‰æ‹©å™¨"""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.addItems([
            "æ­£å¸¸æ¨¡å¼",
            "æµ‹è¯•æ¨¡å¼",
            "å®‰å…¨æ¨¡å¼",
            "æ¼”ç»ƒæ¨¡å¼"
        ])

        # æ˜¾ç¤ºæ¨¡å¼è¯´æ˜
        self.setToolTip(self._get_mode_description())
        self.currentIndexChanged.connect(self._on_mode_changed)

    def _on_mode_changed(self, index):
        mode_map = ['normal', 'test', 'safe', 'dry_run']
        new_mode = mode_map[index]

        # å®‰å…¨æ¨¡å¼/æ­£å¸¸æ¨¡å¼åˆ‡æ¢éœ€ç¡®è®¤
        if new_mode == 'normal' and config.get('run_mode') == 'safe':
            reply = QMessageBox.warning(
                self, "ç¡®è®¤åˆ‡æ¢",
                "ä»å®‰å…¨æ¨¡å¼åˆ‡æ¢åˆ°æ­£å¸¸æ¨¡å¼å°†æé«˜å‘é€é¢‘ç‡ã€‚\nç¡®å®šè¦åˆ‡æ¢å—?",
                QMessageBox.Yes | QMessageBox.No
            )
            if reply == QMessageBox.No:
                self.setCurrentIndex(2)  # å›åˆ°å®‰å…¨æ¨¡å¼
                return

        config['run_mode'] = new_mode
        logger.info(f"è¿è¡Œæ¨¡å¼åˆ‡æ¢ä¸º: {new_mode}")

        # æ›´æ–°çŠ¶æ€æ æ˜¾ç¤º
        self.parent().status_bar.set_mode(new_mode)
```

### 17.4 æ¨¡å¼æ„ŸçŸ¥æ‰§è¡Œå™¨

```python
class ModeAwareExecutor:
    """æ¨¡å¼æ„ŸçŸ¥æ‰§è¡Œå™¨"""

    def __init__(self, config: dict, moment_sender=None, group_sender=None):
        """
        åˆå§‹åŒ–æ¨¡å¼æ„ŸçŸ¥æ‰§è¡Œå™¨

        Args:
            config: é…ç½®å­—å…¸
            moment_sender: æœ‹å‹åœˆå‘å¸ƒå™¨å®ä¾‹ (MomentSender)
            group_sender: ç¾¤æ¶ˆæ¯å‘é€å™¨å®ä¾‹ (GroupSender)
        """
        self.config = config
        self.mode = config.get('run_mode', 'normal')
        self.mode_config = config.get('modes', {}).get(self.mode, {})

        # æ³¨å…¥åº•å±‚å‘é€å™¨
        self._moment_sender = moment_sender
        self._group_sender = group_sender

    def can_send_moment(self) -> tuple[bool, str]:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥å‘é€æœ‹å‹åœˆ"""
        if self.mode == 'test':
            return False, "æµ‹è¯•æ¨¡å¼ä¸‹ç¦æ­¢å‘é€æœ‹å‹åœˆ"

        if self.mode == 'safe':
            daily_count = self._get_daily_moment_count()
            max_count = self.mode_config.get('max_daily_moment', 3)
            if daily_count >= max_count:
                return False, f"å®‰å…¨æ¨¡å¼é™åˆ¶: ä»Šæ—¥å·²å‘é€ {daily_count} æ¡æœ‹å‹åœˆ"

        return True, ""

    def can_send_to_group(self, group_name: str) -> tuple[bool, str]:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥å‘é€åˆ°æŒ‡å®šç¾¤"""
        if self.mode == 'test':
            allowed = self.mode_config.get('allowed_groups', [])
            if group_name not in allowed:
                return False, f"æµ‹è¯•æ¨¡å¼ä¸‹åªèƒ½å‘é€åˆ°: {allowed}"

        return True, ""

    def get_rate_limit(self) -> dict:
        """è·å–å½“å‰æ¨¡å¼çš„é€Ÿç‡é™åˆ¶"""
        default = {'base_interval': 180, 'jitter_range': [0, 60]}
        return self.mode_config.get('rate_limit', default)

    def get_sender(self):
        """
        è·å–åº•å±‚å‘é€å™¨å®ä¾‹

        æ ¹æ®åˆå§‹åŒ–æ—¶æ³¨å…¥çš„å‘é€å™¨è¿”å›:
        - self._moment_sender: æœ‹å‹åœˆå‘å¸ƒå™¨ (MomentSender)
        - self._group_sender: ç¾¤æ¶ˆæ¯å‘é€å™¨ (GroupSender)

        æ³¨æ„: å‘é€å™¨åœ¨æ„é€ æ—¶æ³¨å…¥, å…·ä½“ä½¿ç”¨å“ªä¸ªç”± execute æ–¹æ³•æ ¹æ® task.channel å†³å®š
        """
        return {
            'moment': self._moment_sender,
            'group': self._group_sender
        }

    def execute(self, task, executor):
        """æ‰§è¡Œä»»åŠ¡ (æ¨¡å¼æ„ŸçŸ¥)"""
        # æ¼”ç»ƒæ¨¡å¼: ä¸å®é™…å‘é€
        if self.mode == 'dry_run':
            return self._dry_run_execute(task)

        # æ­£å¸¸æ‰§è¡Œ
        return executor.execute(task)

    def _dry_run_execute(self, task) -> dict:
        """æ¼”ç»ƒæ‰§è¡Œ"""
        logger.info(f"[DRY-RUN] æ¨¡æ‹Ÿæ‰§è¡Œä»»åŠ¡: {task.id}")
        logger.info(f"  æ¸ é“: {task.channel}")
        logger.info(f"  äº§å“: {task.product_name}")

        if self.mode_config.get('log_as_success', True):
            return {'status': 'success', 'dry_run': True}
        else:
            return {'status': 'dry_run', 'dry_run': True}
```

### 17.5 æ¨¡å¼æ„ŸçŸ¥è°ƒåº¦æµç¨‹

æ¨¡å¼æ„ŸçŸ¥éœ€è¦è´¯ç©¿æ•´ä¸ªè°ƒåº¦é“¾è·¯ï¼Œç¡®ä¿ daily_limitã€rate_limiter ç­‰çº¦æŸåœ¨ä¸åŒæ¨¡å¼ä¸‹æ­£ç¡®ç”Ÿæ•ˆã€‚

```python
# core/mode_aware_scheduler.py

import threading
from datetime import datetime, timedelta
from typing import Optional

class ModeAwareScheduler:
    """
    æ¨¡å¼æ„ŸçŸ¥è°ƒåº¦å™¨

    èŒè´£:
    1. æ ¹æ®å½“å‰æ¨¡å¼è°ƒæ•´è°ƒåº¦ç­–ç•¥
    2. å¼ºåˆ¶æ‰§è¡Œæ¨¡å¼çº¦æŸ (daily_limit, rate_limit)
    3. ä¸ queue_manager é›†æˆ
    """

    def __init__(self, config: dict, queue_manager, executor: ModeAwareExecutor):
        self.config = config
        self.queue_manager = queue_manager
        self.executor = executor

        # é€Ÿç‡é™åˆ¶å™¨
        self._rate_limiter = RateLimiter(executor.get_rate_limit())

        # æ¯æ—¥è®¡æ•°å™¨
        self._daily_counts = {'moment': 0, 'group': 0}
        self._count_reset_date = datetime.now().date()

    def schedule_task(self, task) -> tuple[bool, str]:
        """
        è°ƒåº¦ä»»åŠ¡ (æ¨¡å¼æ„ŸçŸ¥)

        æµç¨‹:
        1. æ£€æŸ¥æ¨¡å¼çº¦æŸ
        2. æ£€æŸ¥é€Ÿç‡é™åˆ¶
        3. æ£€æŸ¥æ¯æ—¥é™é¢
        4. åŠ å…¥é˜Ÿåˆ—
        """
        # 0. é‡ç½®æ¯æ—¥è®¡æ•°å™¨ (è·¨æ—¥)
        self._check_daily_reset()

        # 1. æ¨¡å¼çº¦æŸæ£€æŸ¥
        if task.channel == 'moment':
            can_send, reason = self.executor.can_send_moment()
            if not can_send:
                logger.warning(f"ä»»åŠ¡ {task.id} è¢«æ¨¡å¼çº¦æŸé˜»æ­¢: {reason}")
                return False, reason

        elif task.channel == 'group':
            can_send, reason = self.executor.can_send_to_group(task.group_name)
            if not can_send:
                logger.warning(f"ä»»åŠ¡ {task.id} è¢«æ¨¡å¼çº¦æŸé˜»æ­¢: {reason}")
                return False, reason

        # 2. é€Ÿç‡é™åˆ¶æ£€æŸ¥
        wait_time = self._rate_limiter.get_wait_time()
        if wait_time > 0:
            logger.debug(f"é€Ÿç‡é™åˆ¶: ç­‰å¾… {wait_time:.1f} ç§’")
            # å»¶è¿Ÿè°ƒåº¦è€Œéæ‹’ç»
            task.scheduled_time = datetime.now() + timedelta(seconds=wait_time)

        # 3. æ¯æ—¥é™é¢æ£€æŸ¥ (ä»…å®‰å…¨æ¨¡å¼ç”Ÿæ•ˆ)
        if self.executor.mode == 'safe':
            daily_limit = self._get_daily_limit(task.channel)
            current_count = self._daily_counts.get(task.channel, 0)
            if current_count >= daily_limit:
                return False, f"å®‰å…¨æ¨¡å¼æ¯æ—¥é™é¢å·²ç”¨å®Œ: {task.channel} ({current_count}/{daily_limit})"

        # 4. åŠ å…¥é˜Ÿåˆ—
        self.queue_manager.add_task(task)
        logger.info(f"ä»»åŠ¡å·²è°ƒåº¦: {task.id}, æ¨¡å¼: {self.executor.mode}")

        return True, ""

    def execute_next(self) -> Optional[dict]:
        """
        æ‰§è¡Œä¸‹ä¸€ä¸ªä»»åŠ¡ (æ¨¡å¼æ„ŸçŸ¥)

        å…³é”®: æ‰§è¡Œå‰å†æ¬¡æ£€æŸ¥æ¨¡å¼çº¦æŸ
        """
        task = self.queue_manager.peek_next()
        if not task:
            return None

        # å†æ¬¡æ£€æŸ¥æ¨¡å¼çº¦æŸ (é˜²æ­¢æ¨¡å¼åˆ‡æ¢åé—ç•™ä»»åŠ¡)
        if task.channel == 'moment':
            can_send, reason = self.executor.can_send_moment()
            if not can_send:
                task.status = 'skipped'
                task.skip_reason = reason
                self.queue_manager.remove_task(task.id)
                return {'status': 'skipped', 'reason': reason}

        elif task.channel == 'group':
            can_send, reason = self.executor.can_send_to_group(task.group_name)
            if not can_send:
                task.status = 'skipped'
                task.skip_reason = reason
                self.queue_manager.remove_task(task.id)
                return {'status': 'skipped', 'reason': reason}

        # ç­‰å¾…é€Ÿç‡é™åˆ¶
        self._rate_limiter.wait()

        # æ‰§è¡Œä»»åŠ¡
        result = self.executor.execute(task, self._get_underlying_executor())

        # æ›´æ–°è®¡æ•°å™¨
        if result.get('status') == 'success':
            self._daily_counts[task.channel] = self._daily_counts.get(task.channel, 0) + 1

        # è®°å½•é€Ÿç‡
        self._rate_limiter.record()

        return result

    def _check_daily_reset(self):
        """æ£€æŸ¥å¹¶é‡ç½®æ¯æ—¥è®¡æ•°å™¨"""
        today = datetime.now().date()
        if today != self._count_reset_date:
            self._daily_counts = {'moment': 0, 'group': 0}
            self._count_reset_date = today
            logger.info("æ¯æ—¥è®¡æ•°å™¨å·²é‡ç½®")

    def _get_daily_limit(self, channel: str) -> int:
        """è·å–æ¯æ—¥é™é¢"""
        mode_config = self.config.get('modes', {}).get(self.executor.mode, {})
        limits = mode_config.get('daily_limits', {})
        return limits.get(channel, 999999)

    def _get_underlying_executor(self):
        """
        è·å–åº•å±‚æ‰§è¡Œå™¨å®ä¾‹

        æ ¹æ®ä»»åŠ¡æ¸ é“è¿”å›å¯¹åº”çš„å‘é€å™¨:
        - moment: MomentSender (æœ‹å‹åœˆå‘å¸ƒå™¨)
        - group: GroupSender (ç¾¤æ¶ˆæ¯å‘é€å™¨)

        Returns:
            å‘é€å™¨å®ä¾‹, ç”± executor æŒæœ‰å¹¶æ ¹æ®å½“å‰æ¨¡å¼é…ç½®
        """
        return self.executor.get_sender()


class RateLimiter:
    """é€Ÿç‡é™åˆ¶å™¨"""

    def __init__(self, config: dict):
        self.base_interval = config.get('base_interval', 180)  # åŸºç¡€é—´éš” (ç§’)
        self.jitter_range = config.get('jitter_range', [0, 60])  # æŠ–åŠ¨èŒƒå›´
        self._last_execution: Optional[datetime] = None
        self._lock = threading.Lock()

    def get_wait_time(self) -> float:
        """è·å–éœ€è¦ç­‰å¾…çš„æ—¶é—´ (ç§’)"""
        with self._lock:
            if self._last_execution is None:
                return 0

            elapsed = (datetime.now() - self._last_execution).total_seconds()
            required_interval = self._get_current_interval()

            return max(0, required_interval - elapsed)

    def wait(self):
        """ç­‰å¾…ç›´åˆ°å¯ä»¥æ‰§è¡Œ"""
        wait_time = self.get_wait_time()
        if wait_time > 0:
            import time
            time.sleep(wait_time)

    def record(self):
        """è®°å½•æ‰§è¡Œæ—¶é—´"""
        with self._lock:
            self._last_execution = datetime.now()

    def _get_current_interval(self) -> float:
        """è·å–å½“å‰é—´éš” (å«æŠ–åŠ¨)"""
        import random
        jitter = random.uniform(*self.jitter_range)
        return self.base_interval + jitter
```

**æ¨¡å¼æ„ŸçŸ¥è°ƒåº¦é›†æˆå›¾:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ModeAwareScheduler                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  schedule_task()                    execute_next()          â”‚
â”‚       â”‚                                   â”‚                 â”‚
â”‚       v                                   v                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ æ¨¡å¼çº¦æŸæ£€æŸ¥ â”‚                   â”‚ æ¨¡å¼çº¦æŸæ£€æŸ¥ â”‚         â”‚
â”‚  â”‚ (can_send)  â”‚                   â”‚ (å†æ¬¡æ£€æŸ¥)  â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚        â”‚                                  â”‚                 â”‚
â”‚        v                                  v                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ é€Ÿç‡é™åˆ¶æ£€æŸ¥ â”‚                   â”‚ é€Ÿç‡ç­‰å¾…    â”‚         â”‚
â”‚  â”‚ (delay)     â”‚                   â”‚ (wait)      â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚        â”‚                                  â”‚                 â”‚
â”‚        v                                  v                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ æ¯æ—¥é™é¢æ£€æŸ¥ â”‚                   â”‚ æ‰§è¡Œä»»åŠ¡    â”‚         â”‚
â”‚  â”‚ (safe mode) â”‚                   â”‚ (execute)   â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚        â”‚                                  â”‚                 â”‚
â”‚        v                                  v                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ åŠ å…¥é˜Ÿåˆ—    â”‚                   â”‚ æ›´æ–°è®¡æ•°å™¨  â”‚         â”‚
â”‚  â”‚ (queue)     â”‚                   â”‚ (counters)  â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å„æ¨¡å¼çº¦æŸé…ç½®:**

```yaml
modes:
  normal:
    daily_limits:
      moment: 10        # æœ‹å‹åœˆæ¯æ—¥ä¸Šé™
      group: 50         # ç¾¤å‘æ¯æ—¥ä¸Šé™
    rate_limit:
      base_interval: 180
      jitter_range: [0, 60]

  test:
    daily_limits:
      moment: 0         # ç¦æ­¢æœ‹å‹åœˆ
      group: 10         # ç¾¤å‘é™åˆ¶
    rate_limit:
      base_interval: 30
      jitter_range: [0, 10]
    allowed_groups:     # ç™½åå•
      - "æµ‹è¯•ç¾¤A"
      - "æµ‹è¯•ç¾¤B"

  safe:
    daily_limits:
      moment: 3         # æœ‹å‹åœˆä¸¥æ ¼é™åˆ¶
      group: 20         # ç¾¤å‘é™åˆ¶
    rate_limit:
      base_interval: 300  # 5åˆ†é’Ÿé—´éš”
      jitter_range: [0, 120]  # å¤§æŠ–åŠ¨

  dry_run:
    daily_limits:
      moment: 999
      group: 999
    rate_limit:
      base_interval: 1   # å¿«é€Ÿæ¨¡æ‹Ÿ
      jitter_range: [0, 0]
```

### 17.6 æ¨¡å¼åˆ‡æ¢æƒé™ä¸å®¡è®¡

> **å®‰å…¨è¦æ±‚**: æ¨¡å¼åˆ‡æ¢æ˜¯æ•æ„Ÿæ“ä½œï¼Œéœ€è¦æƒé™æ§åˆ¶å’Œå®Œæ•´å®¡è®¡æ—¥å¿—ã€‚

#### 17.6.1 æƒé™æ§åˆ¶

```python
# core/mode_permission.py

from enum import Enum
from dataclasses import dataclass
from datetime import datetime
from typing import Optional
import hashlib

class PermissionLevel(Enum):
    """æƒé™ç­‰çº§"""
    OPERATOR = "operator"     # æ“ä½œå‘˜: åªèƒ½ä½¿ç”¨å®‰å…¨/æ¼”ç»ƒæ¨¡å¼
    ADMIN = "admin"           # ç®¡ç†å‘˜: å¯åˆ‡æ¢æ­£å¸¸/æµ‹è¯•æ¨¡å¼
    SUPER_ADMIN = "super"     # è¶…çº§ç®¡ç†å‘˜: æ— é™åˆ¶

# æ¨¡å¼åˆ‡æ¢æƒé™çŸ©é˜µ
MODE_PERMISSION_MATRIX = {
    # from_mode -> to_mode -> required_level
    'safe': {
        'normal': PermissionLevel.ADMIN,      # å®‰å…¨â†’æ­£å¸¸ éœ€ç®¡ç†å‘˜
        'test': PermissionLevel.ADMIN,        # å®‰å…¨â†’æµ‹è¯• éœ€ç®¡ç†å‘˜
        'dry_run': PermissionLevel.OPERATOR,  # å®‰å…¨â†’æ¼”ç»ƒ æ“ä½œå‘˜å³å¯
    },
    'normal': {
        'safe': PermissionLevel.OPERATOR,     # æ­£å¸¸â†’å®‰å…¨ æ“ä½œå‘˜å³å¯
        'test': PermissionLevel.ADMIN,        # æ­£å¸¸â†’æµ‹è¯• éœ€ç®¡ç†å‘˜
        'dry_run': PermissionLevel.OPERATOR,  # æ­£å¸¸â†’æ¼”ç»ƒ æ“ä½œå‘˜å³å¯
    },
    'test': {
        'normal': PermissionLevel.ADMIN,      # æµ‹è¯•â†’æ­£å¸¸ éœ€ç®¡ç†å‘˜
        'safe': PermissionLevel.OPERATOR,     # æµ‹è¯•â†’å®‰å…¨ æ“ä½œå‘˜å³å¯
        'dry_run': PermissionLevel.OPERATOR,  # æµ‹è¯•â†’æ¼”ç»ƒ æ“ä½œå‘˜å³å¯
    },
    'dry_run': {
        'normal': PermissionLevel.ADMIN,      # æ¼”ç»ƒâ†’æ­£å¸¸ éœ€ç®¡ç†å‘˜
        'safe': PermissionLevel.OPERATOR,     # æ¼”ç»ƒâ†’å®‰å…¨ æ“ä½œå‘˜å³å¯
        'test': PermissionLevel.ADMIN,        # æ¼”ç»ƒâ†’æµ‹è¯• éœ€ç®¡ç†å‘˜
    },
}

@dataclass
class ModeChangeRequest:
    """æ¨¡å¼åˆ‡æ¢è¯·æ±‚"""
    from_mode: str
    to_mode: str
    operator_id: str
    reason: str
    timestamp: datetime = None

    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()

class ModePermissionManager:
    """æ¨¡å¼åˆ‡æ¢æƒé™ç®¡ç†å™¨"""

    def __init__(self, config: dict):
        self.config = config
        # æ“ä½œå‘˜æƒé™æ˜ å°„ (å®é™…ä½¿ç”¨æ—¶ä»é…ç½®/æ•°æ®åº“åŠ è½½)
        self._operator_permissions = config.get('operator_permissions', {})

    def check_permission(self, request: ModeChangeRequest) -> tuple[bool, str]:
        """
        æ£€æŸ¥æ¨¡å¼åˆ‡æ¢æƒé™

        Returns:
            (allowed, reason): æ˜¯å¦å…è®¸åŠåŸå› 
        """
        required_level = MODE_PERMISSION_MATRIX.get(
            request.from_mode, {}
        ).get(request.to_mode)

        if required_level is None:
            return False, f"ä¸æ”¯æŒä» {request.from_mode} åˆ‡æ¢åˆ° {request.to_mode}"

        operator_level = self._get_operator_level(request.operator_id)

        # æƒé™ç­‰çº§æ¯”è¾ƒ
        level_order = [PermissionLevel.OPERATOR, PermissionLevel.ADMIN, PermissionLevel.SUPER_ADMIN]
        if level_order.index(operator_level) < level_order.index(required_level):
            return False, (
                f"æƒé™ä¸è¶³: éœ€è¦ {required_level.value} æƒé™, "
                f"å½“å‰æ“ä½œå‘˜ {request.operator_id} æƒé™ä¸º {operator_level.value}"
            )

        return True, ""

    def _get_operator_level(self, operator_id: str) -> PermissionLevel:
        """è·å–æ“ä½œå‘˜æƒé™ç­‰çº§"""
        level_str = self._operator_permissions.get(operator_id, 'operator')
        return PermissionLevel(level_str)
```

#### 17.6.2 å®¡è®¡æ—¥å¿—

```python
# core/mode_audit_log.py

import json
from pathlib import Path
from datetime import datetime
from typing import List, Optional

@dataclass
class ModeChangeAuditEntry:
    """æ¨¡å¼åˆ‡æ¢å®¡è®¡æ¡ç›®"""
    timestamp: datetime
    from_mode: str
    to_mode: str
    operator_id: str
    reason: str
    success: bool
    failure_reason: Optional[str] = None
    ip_address: Optional[str] = None
    machine_name: Optional[str] = None

class ModeAuditLogger:
    """æ¨¡å¼åˆ‡æ¢å®¡è®¡æ—¥å¿—å™¨"""

    AUDIT_FILE = Path("data/audit/mode_changes.jsonl")

    def __init__(self):
        self.AUDIT_FILE.parent.mkdir(parents=True, exist_ok=True)

    def log_change(self, entry: ModeChangeAuditEntry):
        """è®°å½•æ¨¡å¼åˆ‡æ¢"""
        log_data = {
            "timestamp": entry.timestamp.isoformat(),
            "from_mode": entry.from_mode,
            "to_mode": entry.to_mode,
            "operator_id": entry.operator_id,
            "reason": entry.reason,
            "success": entry.success,
            "failure_reason": entry.failure_reason,
            "ip_address": entry.ip_address,
            "machine_name": entry.machine_name,
        }

        # è¿½åŠ åˆ° JSONL æ–‡ä»¶
        with open(self.AUDIT_FILE, 'a', encoding='utf-8') as f:
            f.write(json.dumps(log_data, ensure_ascii=False) + '\n')

        # åŒæ—¶å†™å…¥æ ‡å‡†æ—¥å¿—
        if entry.success:
            logger.info(
                f"[å®¡è®¡] æ¨¡å¼åˆ‡æ¢: {entry.from_mode} â†’ {entry.to_mode}, "
                f"æ“ä½œå‘˜: {entry.operator_id}, åŸå› : {entry.reason}"
            )
        else:
            logger.warning(
                f"[å®¡è®¡] æ¨¡å¼åˆ‡æ¢è¢«æ‹’ç»: {entry.from_mode} â†’ {entry.to_mode}, "
                f"æ“ä½œå‘˜: {entry.operator_id}, æ‹’ç»åŸå› : {entry.failure_reason}"
            )

    def get_recent_changes(self, limit: int = 50) -> List[ModeChangeAuditEntry]:
        """è·å–æœ€è¿‘çš„æ¨¡å¼åˆ‡æ¢è®°å½•"""
        if not self.AUDIT_FILE.exists():
            return []

        entries = []
        with open(self.AUDIT_FILE, 'r', encoding='utf-8') as f:
            lines = f.readlines()[-limit:]
            for line in lines:
                data = json.loads(line)
                entries.append(ModeChangeAuditEntry(
                    timestamp=datetime.fromisoformat(data['timestamp']),
                    from_mode=data['from_mode'],
                    to_mode=data['to_mode'],
                    operator_id=data['operator_id'],
                    reason=data['reason'],
                    success=data['success'],
                    failure_reason=data.get('failure_reason'),
                    ip_address=data.get('ip_address'),
                    machine_name=data.get('machine_name'),
                ))

        return entries
```

#### 17.6.3 å¸¦æƒé™æ£€æŸ¥çš„æ¨¡å¼åˆ‡æ¢ UI

```python
# ui/mode_selector_with_auth.py

import socket

class AuthenticatedModeSelector(QComboBox):
    """å¸¦æƒé™éªŒè¯çš„è¿è¡Œæ¨¡å¼é€‰æ‹©å™¨"""

    def __init__(self, permission_manager: ModePermissionManager,
                 audit_logger: ModeAuditLogger, operator_id: str, parent=None):
        super().__init__(parent)
        self.permission_manager = permission_manager
        self.audit_logger = audit_logger
        self.operator_id = operator_id

        self.addItems(["æ­£å¸¸æ¨¡å¼", "æµ‹è¯•æ¨¡å¼", "å®‰å…¨æ¨¡å¼", "æ¼”ç»ƒæ¨¡å¼"])
        self.currentIndexChanged.connect(self._on_mode_changed)

    def _on_mode_changed(self, index):
        mode_map = ['normal', 'test', 'safe', 'dry_run']
        new_mode = mode_map[index]
        current_mode = config.get('run_mode', 'normal')

        if new_mode == current_mode:
            return

        # å¼¹çª—è¦æ±‚è¾“å…¥åˆ‡æ¢åŸå› 
        reason, ok = QInputDialog.getText(
            self, "æ¨¡å¼åˆ‡æ¢ç¡®è®¤",
            f"åˆ‡æ¢åˆ° {self._get_mode_display(new_mode)}\nè¯·è¾“å…¥åˆ‡æ¢åŸå› :"
        )

        if not ok or not reason.strip():
            self._revert_selection(current_mode)
            return

        # æ„å»ºåˆ‡æ¢è¯·æ±‚
        request = ModeChangeRequest(
            from_mode=current_mode,
            to_mode=new_mode,
            operator_id=self.operator_id,
            reason=reason.strip()
        )

        # æ£€æŸ¥æƒé™
        allowed, deny_reason = self.permission_manager.check_permission(request)

        # è®°å½•å®¡è®¡æ—¥å¿—
        audit_entry = ModeChangeAuditEntry(
            timestamp=datetime.now(),
            from_mode=current_mode,
            to_mode=new_mode,
            operator_id=self.operator_id,
            reason=reason.strip(),
            success=allowed,
            failure_reason=deny_reason if not allowed else None,
            machine_name=socket.gethostname()
        )
        self.audit_logger.log_change(audit_entry)

        if not allowed:
            QMessageBox.warning(
                self, "æƒé™ä¸è¶³",
                f"æ¨¡å¼åˆ‡æ¢è¢«æ‹’ç»:\n{deny_reason}"
            )
            self._revert_selection(current_mode)
            return

        # æ‰§è¡Œåˆ‡æ¢
        config['run_mode'] = new_mode
        logger.info(f"è¿è¡Œæ¨¡å¼åˆ‡æ¢ä¸º: {new_mode} (æ“ä½œå‘˜: {self.operator_id})")
        self.parent().status_bar.set_mode(new_mode)

    def _revert_selection(self, mode: str):
        """æ¢å¤é€‰æ‹©åˆ°æŒ‡å®šæ¨¡å¼"""
        mode_index = {'normal': 0, 'test': 1, 'safe': 2, 'dry_run': 3}
        self.blockSignals(True)
        self.setCurrentIndex(mode_index.get(mode, 0))
        self.blockSignals(False)

    def _get_mode_display(self, mode: str) -> str:
        return {'normal': 'æ­£å¸¸æ¨¡å¼', 'test': 'æµ‹è¯•æ¨¡å¼',
                'safe': 'å®‰å…¨æ¨¡å¼', 'dry_run': 'æ¼”ç»ƒæ¨¡å¼'}.get(mode, mode)
```

#### 17.6.4 æƒé™é…ç½®

```yaml
# config/permissions.yaml

operator_permissions:
  # æ“ä½œå‘˜ID -> æƒé™ç­‰çº§
  "operator_001": "operator"
  "admin_001": "admin"
  "super_admin": "super"

mode_switch_policy:
  # é«˜é£é™©æ¨¡å¼åˆ‡æ¢éœ€è¦äºŒæ¬¡ç¡®è®¤
  require_confirmation:
    - from: "safe"
      to: "normal"
    - from: "dry_run"
      to: "normal"

  # å¼ºåˆ¶é™çº§åœºæ™¯ (é£æ§äº‹ä»¶è§¦å‘åè‡ªåŠ¨åˆ‡æ¢åˆ°å®‰å…¨æ¨¡å¼)
  auto_downgrade_on_risk: true
  downgrade_target: "safe"
```

#### 17.6.5 æ“ä½œå‘˜èº«ä»½è·å–ä¸æ ¡éªŒ

> **å…³é”®é—­ç¯**: æ˜ç¡® `operator_id` çš„æ¥æºã€æ ¡éªŒæ–¹å¼ã€äºŒæ¬¡ç¡®è®¤æµç¨‹ä¸æ‹’ç»æ—¶çš„å›é€€å¤„ç†ã€‚

```python
# core/operator_identity.py

import os
import getpass
import hashlib
import secrets
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Optional, Tuple
from pathlib import Path
import json

@dataclass
class OperatorSession:
    """æ“ä½œå‘˜ä¼šè¯"""
    operator_id: str
    permission_level: str
    login_time: datetime
    session_token: str
    expires_at: datetime
    machine_name: str

class OperatorIdentityManager:
    """
    æ“ä½œå‘˜èº«ä»½ç®¡ç†å™¨

    operator_id è·å–ä¼˜å…ˆçº§:
    1. æ˜¾å¼ç™»å½• (ç”¨æˆ·å+å¯†ç è®¤è¯)
    2. ç¯å¢ƒå˜é‡ WECHAT_OPERATOR_ID (ç”¨äºè‡ªåŠ¨åŒ–åœºæ™¯)
    3. ç³»ç»Ÿç”¨æˆ·å (getpass.getuser()) ä½œä¸º fallback

    æ ¡éªŒæ–¹å¼:
    - é¦–é€‰: å¯†ç å“ˆå¸Œæ ¡éªŒ (bcrypt/sha256)
    - å¯é€‰: äºŒæ¬¡ç¡®è®¤å¼¹çª— (æ•æ„Ÿæ“ä½œ)
    """

    CREDENTIALS_FILE = Path("config/operator_credentials.json")
    SESSION_FILE = Path("data/session/current_session.json")
    SESSION_DURATION_HOURS = 8  # ä¼šè¯æœ‰æ•ˆæœŸ

    def __init__(self, config: dict):
        self.config = config
        self._current_session: Optional[OperatorSession] = None
        self._load_session()

    # ==================== èº«ä»½è·å– ====================

    def get_operator_id(self) -> str:
        """
        è·å–å½“å‰æ“ä½œå‘˜ID

        ä¼˜å…ˆçº§:
        1. æ´»è·ƒä¼šè¯ä¸­çš„ operator_id
        2. ç¯å¢ƒå˜é‡ WECHAT_OPERATOR_ID
        3. ç³»ç»Ÿç”¨æˆ·å (æœ€ä½ä¿¡ä»»çº§åˆ«)
        """
        # 1. å°è¯•ä»æ´»è·ƒä¼šè¯è·å–
        if self._current_session and self._is_session_valid():
            return self._current_session.operator_id

        # 2. å°è¯•ä»ç¯å¢ƒå˜é‡è·å– (è‡ªåŠ¨åŒ–åœºæ™¯)
        env_operator = os.environ.get('WECHAT_OPERATOR_ID')
        if env_operator:
            logger.info(f"ä½¿ç”¨ç¯å¢ƒå˜é‡ operator_id: {env_operator}")
            return env_operator

        # 3. Fallback: ç³»ç»Ÿç”¨æˆ·å (æƒé™å—é™)
        system_user = getpass.getuser()
        logger.warning(
            f"æœªæ‰¾åˆ°è®¤è¯ä¼šè¯ï¼Œä½¿ç”¨ç³»ç»Ÿç”¨æˆ·å: {system_user} (æƒé™å—é™ä¸º operator)"
        )
        return f"sys:{system_user}"  # æ·»åŠ  sys: å‰ç¼€æ ‡è¯†æœªè®¤è¯

    def get_permission_level(self) -> str:
        """è·å–å½“å‰æ“ä½œå‘˜æƒé™ç­‰çº§"""
        if self._current_session and self._is_session_valid():
            return self._current_session.permission_level

        # æœªè®¤è¯ç”¨æˆ·é»˜è®¤ operator çº§åˆ«
        return "operator"

    # ==================== ç™»å½•è®¤è¯ ====================

    def login(self, username: str, password: str) -> Tuple[bool, str]:
        """
        æ“ä½œå‘˜ç™»å½•è®¤è¯

        Returns:
            (success, message): ç™»å½•ç»“æœ
        """
        # åŠ è½½å‡­æ®
        if not self.CREDENTIALS_FILE.exists():
            return False, "å‡­æ®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜é…ç½®"

        with open(self.CREDENTIALS_FILE, 'r', encoding='utf-8') as f:
            credentials = json.load(f)

        if username not in credentials:
            # å®‰å…¨: ä¸é€éœ²ç”¨æˆ·åæ˜¯å¦å­˜åœ¨
            logger.warning(f"ç™»å½•å¤±è´¥: ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯ (å°è¯•ç”¨æˆ·: {username})")
            return False, "ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯"

        user_info = credentials[username]
        stored_hash = user_info.get('password_hash', '')

        # éªŒè¯å¯†ç 
        if not self._verify_password(password, stored_hash):
            logger.warning(f"ç™»å½•å¤±è´¥: å¯†ç é”™è¯¯ (ç”¨æˆ·: {username})")
            return False, "ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯"

        # åˆ›å»ºä¼šè¯
        session = OperatorSession(
            operator_id=username,
            permission_level=user_info.get('level', 'operator'),
            login_time=datetime.now(),
            session_token=secrets.token_hex(32),
            expires_at=datetime.now() + timedelta(hours=self.SESSION_DURATION_HOURS),
            machine_name=os.environ.get('COMPUTERNAME', 'unknown')
        )

        self._current_session = session
        self._save_session()

        logger.info(f"æ“ä½œå‘˜ç™»å½•æˆåŠŸ: {username} (æƒé™: {session.permission_level})")
        return True, f"ç™»å½•æˆåŠŸï¼Œæƒé™ç­‰çº§: {session.permission_level}"

    def logout(self):
        """ç™»å‡ºå½“å‰ä¼šè¯"""
        if self._current_session:
            logger.info(f"æ“ä½œå‘˜ç™»å‡º: {self._current_session.operator_id}")
            self._current_session = None
            if self.SESSION_FILE.exists():
                self.SESSION_FILE.unlink()

    # ==================== å¯†ç æ ¡éªŒ ====================

    def _verify_password(self, password: str, stored_hash: str) -> bool:
        """éªŒè¯å¯†ç """
        # æ”¯æŒä¸¤ç§æ ¼å¼: sha256:xxx æˆ– bcrypt:xxx
        if stored_hash.startswith('sha256:'):
            expected = stored_hash[7:]
            actual = hashlib.sha256(password.encode()).hexdigest()
            return secrets.compare_digest(actual, expected)
        elif stored_hash.startswith('bcrypt:'):
            # éœ€è¦ bcrypt åº“
            try:
                import bcrypt
                return bcrypt.checkpw(
                    password.encode(),
                    stored_hash[7:].encode()
                )
            except ImportError:
                logger.error("bcrypt åº“æœªå®‰è£…ï¼Œæ— æ³•éªŒè¯å¯†ç ")
                return False
        else:
            # ä¸æ”¯æŒçš„æ ¼å¼
            return False

    # ==================== ä¼šè¯ç®¡ç† ====================

    def _is_session_valid(self) -> bool:
        """æ£€æŸ¥ä¼šè¯æ˜¯å¦æœ‰æ•ˆ"""
        if not self._current_session:
            return False
        return datetime.now() < self._current_session.expires_at

    def _load_session(self):
        """åŠ è½½ä¿å­˜çš„ä¼šè¯"""
        if not self.SESSION_FILE.exists():
            return

        try:
            with open(self.SESSION_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)

            session = OperatorSession(
                operator_id=data['operator_id'],
                permission_level=data['permission_level'],
                login_time=datetime.fromisoformat(data['login_time']),
                session_token=data['session_token'],
                expires_at=datetime.fromisoformat(data['expires_at']),
                machine_name=data['machine_name']
            )

            if datetime.now() < session.expires_at:
                self._current_session = session
                logger.info(f"æ¢å¤ä¼šè¯: {session.operator_id}")
            else:
                logger.info("ä¼šè¯å·²è¿‡æœŸï¼Œéœ€é‡æ–°ç™»å½•")
                self.SESSION_FILE.unlink()
        except Exception as e:
            logger.warning(f"åŠ è½½ä¼šè¯å¤±è´¥: {e}")

    def _save_session(self):
        """ä¿å­˜å½“å‰ä¼šè¯"""
        if not self._current_session:
            return

        self.SESSION_FILE.parent.mkdir(parents=True, exist_ok=True)

        data = {
            'operator_id': self._current_session.operator_id,
            'permission_level': self._current_session.permission_level,
            'login_time': self._current_session.login_time.isoformat(),
            'session_token': self._current_session.session_token,
            'expires_at': self._current_session.expires_at.isoformat(),
            'machine_name': self._current_session.machine_name,
        }

        with open(self.SESSION_FILE, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
```

#### 17.6.6 äºŒæ¬¡ç¡®è®¤ä¸æ‹’ç»å›é€€

> **å®‰å…¨ç­–ç•¥**: æ•æ„Ÿæ“ä½œéœ€äºŒæ¬¡ç¡®è®¤ï¼Œæ‹’ç»æˆ–å¤±è´¥æ—¶å¿…é¡»å›é€€åˆ°å®‰å…¨çŠ¶æ€ã€‚

```python
# ui/mode_confirm_dialog.py

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel,
    QLineEdit, QPushButton, QMessageBox
)

class ModeChangeConfirmDialog(QDialog):
    """
    æ¨¡å¼åˆ‡æ¢äºŒæ¬¡ç¡®è®¤å¯¹è¯æ¡†

    ç”¨äºé«˜é£é™©åˆ‡æ¢åœºæ™¯ (å¦‚ safeâ†’normal, dry_runâ†’normal)
    """

    def __init__(self, from_mode: str, to_mode: str,
                 operator_id: str, identity_manager: 'OperatorIdentityManager',
                 parent=None):
        super().__init__(parent)
        self.from_mode = from_mode
        self.to_mode = to_mode
        self.operator_id = operator_id
        self.identity_manager = identity_manager
        self.confirmed = False

        self._setup_ui()

    def _setup_ui(self):
        self.setWindowTitle("é«˜é£é™©æ“ä½œ - äºŒæ¬¡ç¡®è®¤")
        self.setMinimumWidth(400)
        layout = QVBoxLayout(self)

        # è­¦å‘Šä¿¡æ¯
        warning = QLabel(
            f"âš ï¸ æ‚¨æ­£åœ¨è¿›è¡Œé«˜é£é™©æ¨¡å¼åˆ‡æ¢:\n\n"
            f"  ä»: {self._mode_display(self.from_mode)}\n"
            f"  åˆ°: {self._mode_display(self.to_mode)}\n\n"
            f"æ“ä½œå‘˜: {self.operator_id}\n\n"
            f"è¯·è¾“å…¥æ‚¨çš„å¯†ç ä»¥ç¡®è®¤æ­¤æ“ä½œ:"
        )
        warning.setStyleSheet("color: #d9534f; font-weight: bold;")
        layout.addWidget(warning)

        # å¯†ç è¾“å…¥
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.password_input.setPlaceholderText("è¯·è¾“å…¥å¯†ç ")
        layout.addWidget(self.password_input)

        # åˆ‡æ¢åŸå› 
        layout.addWidget(QLabel("åˆ‡æ¢åŸå›  (å¿…å¡«):"))
        self.reason_input = QLineEdit()
        self.reason_input.setPlaceholderText("è¯·è¾“å…¥åˆ‡æ¢åŸå› ")
        layout.addWidget(self.reason_input)

        # æŒ‰é’®
        btn_layout = QHBoxLayout()

        self.cancel_btn = QPushButton("å–æ¶ˆ")
        self.cancel_btn.clicked.connect(self._on_cancel)
        btn_layout.addWidget(self.cancel_btn)

        self.confirm_btn = QPushButton("ç¡®è®¤åˆ‡æ¢")
        self.confirm_btn.setStyleSheet("background-color: #d9534f; color: white;")
        self.confirm_btn.clicked.connect(self._on_confirm)
        btn_layout.addWidget(self.confirm_btn)

        layout.addLayout(btn_layout)

    def _on_confirm(self):
        """ç¡®è®¤æŒ‰é’®ç‚¹å‡»"""
        password = self.password_input.text()
        reason = self.reason_input.text().strip()

        if not reason:
            QMessageBox.warning(self, "é”™è¯¯", "è¯·è¾“å…¥åˆ‡æ¢åŸå› ")
            return

        # éªŒè¯å¯†ç 
        # æ³¨æ„: è¿™é‡Œé‡æ–°éªŒè¯è€Œéä¿¡ä»»å·²æœ‰ä¼šè¯ï¼Œå¢å¼ºå®‰å…¨æ€§
        success, _ = self.identity_manager.login(self.operator_id, password)

        if not success:
            QMessageBox.warning(self, "éªŒè¯å¤±è´¥", "å¯†ç é”™è¯¯ï¼Œè¯·é‡è¯•")
            self.password_input.clear()
            self.password_input.setFocus()
            return

        self.confirmed = True
        self.reason = reason
        self.accept()

    def _on_cancel(self):
        """å–æ¶ˆæŒ‰é’®ç‚¹å‡»"""
        self.confirmed = False
        self.reject()

    def _mode_display(self, mode: str) -> str:
        return {
            'normal': 'ğŸŸ¢ æ­£å¸¸æ¨¡å¼ (å®é™…å‘å¸ƒ)',
            'test': 'ğŸŸ¡ æµ‹è¯•æ¨¡å¼ (å‘åˆ°æµ‹è¯•ç¾¤)',
            'safe': 'ğŸ”´ å®‰å…¨æ¨¡å¼ (æ‰€æœ‰æ“ä½œé˜»æ–­)',
            'dry_run': 'âšª æ¼”ç»ƒæ¨¡å¼ (ä»…æ¨¡æ‹Ÿ)'
        }.get(mode, mode)


class SecureModeChanger:
    """
    å®‰å…¨çš„æ¨¡å¼åˆ‡æ¢å™¨

    æ•´åˆèº«ä»½éªŒè¯ã€æƒé™æ£€æŸ¥ã€äºŒæ¬¡ç¡®è®¤ã€å®¡è®¡æ—¥å¿—
    """

    # éœ€è¦äºŒæ¬¡ç¡®è®¤çš„é«˜é£é™©åˆ‡æ¢
    HIGH_RISK_TRANSITIONS = [
        ('safe', 'normal'),
        ('dry_run', 'normal'),
        ('safe', 'test'),
    ]

    def __init__(self,
                 identity_manager: OperatorIdentityManager,
                 permission_manager: 'ModePermissionManager',
                 audit_logger: 'ModeAuditLogger',
                 config: dict):
        self.identity_manager = identity_manager
        self.permission_manager = permission_manager
        self.audit_logger = audit_logger
        self.config = config

    def request_mode_change(self, to_mode: str, parent_widget=None) -> Tuple[bool, str]:
        """
        è¯·æ±‚æ¨¡å¼åˆ‡æ¢

        å®Œæ•´æµç¨‹:
        1. è·å–å½“å‰æ“ä½œå‘˜èº«ä»½
        2. æ£€æŸ¥æƒé™
        3. é«˜é£é™©åˆ‡æ¢éœ€äºŒæ¬¡ç¡®è®¤
        4. æ‰§è¡Œåˆ‡æ¢
        5. è®°å½•å®¡è®¡æ—¥å¿—
        6. å¤±è´¥åˆ™å›é€€

        Returns:
            (success, message)
        """
        from_mode = self.config.get('run_mode', 'safe')
        operator_id = self.identity_manager.get_operator_id()

        # 1. æ£€æŸ¥æ˜¯å¦æœªè®¤è¯ç”¨æˆ·
        if operator_id.startswith('sys:'):
            # æœªè®¤è¯ç”¨æˆ·å°è¯•æ•æ„Ÿæ“ä½œï¼Œè¦æ±‚ç™»å½•
            return False, "è¯·å…ˆç™»å½•åå†è¿›è¡Œæ¨¡å¼åˆ‡æ¢"

        # 2. æ„å»ºè¯·æ±‚å¹¶æ£€æŸ¥æƒé™
        request = ModeChangeRequest(
            from_mode=from_mode,
            to_mode=to_mode,
            operator_id=operator_id,
            reason=""  # ç¨åå¡«å……
        )

        allowed, deny_reason = self.permission_manager.check_permission(request)
        if not allowed:
            self._log_failed_attempt(request, deny_reason)
            return False, f"æƒé™ä¸è¶³: {deny_reason}"

        # 3. é«˜é£é™©åˆ‡æ¢éœ€äºŒæ¬¡ç¡®è®¤
        is_high_risk = (from_mode, to_mode) in self.HIGH_RISK_TRANSITIONS

        if is_high_risk and parent_widget:
            dialog = ModeChangeConfirmDialog(
                from_mode, to_mode, operator_id,
                self.identity_manager, parent_widget
            )

            if dialog.exec_() != QDialog.Accepted or not dialog.confirmed:
                self._log_failed_attempt(
                    request, "ç”¨æˆ·å–æ¶ˆäºŒæ¬¡ç¡®è®¤"
                )
                return False, "æ“ä½œå·²å–æ¶ˆ"

            request.reason = dialog.reason
        else:
            # éé«˜é£é™©æ“ä½œï¼Œç®€å•ç¡®è®¤
            if parent_widget:
                reason, ok = QInputDialog.getText(
                    parent_widget, "æ¨¡å¼åˆ‡æ¢",
                    f"åˆ‡æ¢åˆ° {to_mode}ï¼Œè¯·è¾“å…¥åŸå› :"
                )
                if not ok or not reason.strip():
                    return False, "æ“ä½œå·²å–æ¶ˆ"
                request.reason = reason.strip()
            else:
                request.reason = "è‡ªåŠ¨åˆ‡æ¢"

        # 4. æ‰§è¡Œåˆ‡æ¢
        try:
            old_mode = self.config['run_mode']
            self.config['run_mode'] = to_mode

            # 5. è®°å½•æˆåŠŸå®¡è®¡
            self._log_success(request)

            logger.info(
                f"æ¨¡å¼åˆ‡æ¢æˆåŠŸ: {from_mode} â†’ {to_mode} "
                f"(æ“ä½œå‘˜: {operator_id})"
            )
            return True, f"å·²åˆ‡æ¢åˆ° {to_mode}"

        except Exception as e:
            # 6. å¤±è´¥å›é€€
            logger.error(f"æ¨¡å¼åˆ‡æ¢å¤±è´¥: {e}")
            self.config['run_mode'] = from_mode  # å›é€€
            self._log_failed_attempt(request, str(e))
            return False, f"åˆ‡æ¢å¤±è´¥: {e}"

    def _log_success(self, request: ModeChangeRequest):
        """è®°å½•æˆåŠŸçš„åˆ‡æ¢"""
        entry = ModeChangeAuditEntry(
            timestamp=datetime.now(),
            from_mode=request.from_mode,
            to_mode=request.to_mode,
            operator_id=request.operator_id,
            reason=request.reason,
            success=True,
            machine_name=os.environ.get('COMPUTERNAME', 'unknown')
        )
        self.audit_logger.log_change(entry)

    def _log_failed_attempt(self, request: ModeChangeRequest, reason: str):
        """è®°å½•å¤±è´¥çš„åˆ‡æ¢å°è¯•"""
        entry = ModeChangeAuditEntry(
            timestamp=datetime.now(),
            from_mode=request.from_mode,
            to_mode=request.to_mode,
            operator_id=request.operator_id,
            reason=request.reason or "(æœªæä¾›)",
            success=False,
            failure_reason=reason,
            machine_name=os.environ.get('COMPUTERNAME', 'unknown')
        )
        self.audit_logger.log_change(entry)
```

#### 17.6.7 æ“ä½œå‘˜å‡­æ®é…ç½®ç¤ºä¾‹

```json
// config/operator_credentials.json
// æ³¨æ„: æ­¤æ–‡ä»¶åº”ä¸¥æ ¼ä¿æŠ¤ï¼Œå»ºè®®è®¾ç½®æ–‡ä»¶æƒé™ä¸º 600
{
  "operator_001": {
    "level": "operator",
    "password_hash": "sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
    "display_name": "æ“ä½œå‘˜1",
    "created_at": "2024-01-01T00:00:00"
  },
  "admin_001": {
    "level": "admin",
    "password_hash": "sha256:5e884898da28047d9165141ff1a04f2f0b4d9ae2f7d3cd9c29d47a0e5d8a7c1b",
    "display_name": "ç®¡ç†å‘˜1",
    "created_at": "2024-01-01T00:00:00"
  },
  "super_admin": {
    "level": "super",
    "password_hash": "bcrypt:$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/X4.SQXKGz7tGQ0GyW",
    "display_name": "è¶…çº§ç®¡ç†å‘˜",
    "created_at": "2024-01-01T00:00:00"
  }
}
```

#### 17.6.8 å‡­æ®å®‰å…¨æœ€å°è¦æ±‚

> **å¼ºåˆ¶è§„èŒƒ**: ä»¥ä¸‹è¦æ±‚åœ¨ç”Ÿäº§ç¯å¢ƒä¸­å¿…é¡»æ»¡è¶³ï¼Œå¦åˆ™è§†ä¸ºå®‰å…¨æ¼æ´ã€‚

##### å¯†ç å¤æ‚åº¦è¦æ±‚

| çº§åˆ« | æœ€å°é•¿åº¦ | å¿…é¡»åŒ…å« | æœ‰æ•ˆæœŸ |
|------|----------|----------|--------|
| operator | 8 ä½ | å­—æ¯ + æ•°å­— | 90 å¤© |
| admin | 12 ä½ | å¤§å°å†™ + æ•°å­— + ç‰¹æ®Šå­—ç¬¦ | 60 å¤© |
| super | 16 ä½ | å¤§å°å†™ + æ•°å­— + ç‰¹æ®Šå­—ç¬¦ | 30 å¤© |

```python
# å¯†ç å¤æ‚åº¦æ ¡éªŒ
import re

PASSWORD_RULES = {
    'operator': {'min_length': 8, 'pattern': r'^(?=.*[A-Za-z])(?=.*\d).{8,}$'},
    'admin': {'min_length': 12, 'pattern': r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&]).{12,}$'},
    'super': {'min_length': 16, 'pattern': r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&]).{16,}$'},
}

def validate_password(password: str, level: str) -> tuple[bool, str]:
    """æ ¡éªŒå¯†ç å¤æ‚åº¦"""
    rule = PASSWORD_RULES.get(level, PASSWORD_RULES['operator'])
    if len(password) < rule['min_length']:
        return False, f"å¯†ç é•¿åº¦ä¸è¶³ {rule['min_length']} ä½"
    if not re.match(rule['pattern'], password):
        return False, f"å¯†ç ä¸ç¬¦åˆ {level} çº§åˆ«å¤æ‚åº¦è¦æ±‚"
    return True, "é€šè¿‡"
```

##### å¯†ç è½®æ¢æµç¨‹

| é˜¶æ®µ | è§¦å‘æ¡ä»¶ | æ“ä½œ | é€šçŸ¥ |
|------|----------|------|------|
| æé†’ | è·è¿‡æœŸ 14 å¤© | ç™»å½•æ—¶å¼¹çª—æé†’ | æ—  |
| è­¦å‘Š | è·è¿‡æœŸ 7 å¤© | æ¯æ¬¡æ“ä½œå¼¹çª— | é‚®ä»¶é€šçŸ¥ |
| å¼ºåˆ¶ | å·²è¿‡æœŸ | é˜»æ­¢æ•æ„Ÿæ“ä½œï¼Œä»…å…è®¸æ”¹å¯† | é‚®ä»¶ + ç®¡ç†å‘˜é€šçŸ¥ |

##### Windows ç¯å¢ƒæƒé™æ–¹æ¡ˆ

```powershell
# Windows å‡­æ®æ–‡ä»¶æƒé™è®¾ç½®è„šæœ¬
# run_as_admin.ps1

$credFile = "config\operator_credentials.json"

# 1. ç§»é™¤ç»§æ‰¿æƒé™
icacls $credFile /inheritance:r

# 2. ä»…å…è®¸ SYSTEM å’Œå½“å‰ç”¨æˆ·è®¿é—®
icacls $credFile /grant:r "SYSTEM:(R)"
icacls $credFile /grant:r "$env:USERNAME:(R)"

# 3. ç¦æ­¢å…¶ä»–ç”¨æˆ·è®¿é—®
icacls $credFile /deny "Users:(R)"

Write-Host "å‡­æ®æ–‡ä»¶æƒé™å·²è®¾ç½®ä¸ºä»…å½“å‰ç”¨æˆ·å¯è¯»"
```

##### å‡­æ®å­˜å‚¨å®‰å…¨æ£€æŸ¥æ¸…å•

| æ£€æŸ¥é¡¹ | Windows | Linux/Mac | éªŒè¯å‘½ä»¤ |
|--------|---------|-----------|----------|
| æ–‡ä»¶æƒé™ | ä»…å½“å‰ç”¨æˆ· | 600 | `icacls` / `ls -la` |
| å“ˆå¸Œç®—æ³• | bcrypt (ç”Ÿäº§) | bcrypt | æ£€æŸ¥å‰ç¼€ `bcrypt:` |
| ç¦æ­¢æ˜æ–‡ | âœ“ | âœ“ | grep æ—  `password:` |
| ç‰ˆæœ¬æ§åˆ¶æ’é™¤ | .gitignore | .gitignore | ç¡®è®¤å·²å¿½ç•¥ |

> **å®‰å…¨æ³¨æ„äº‹é¡¹**:
> - ç”Ÿäº§ç¯å¢ƒ**å¿…é¡»**ä½¿ç”¨ bcrypt è€Œé sha256
> - å¯†ç å“ˆå¸Œç”Ÿæˆ: `python -c "import bcrypt; print('bcrypt:' + bcrypt.hashpw(b'password', bcrypt.gensalt()).decode())"`
> - å‡­æ®æ–‡ä»¶æƒé™: Windows ä½¿ç”¨ä¸Šè¿°è„šæœ¬ï¼ŒLinux/Mac ä½¿ç”¨ `chmod 600`
> - å‡­æ®æ–‡ä»¶**å¿…é¡»**åŠ å…¥ `.gitignore`ï¼Œç¦æ­¢æäº¤åˆ°ç‰ˆæœ¬æ§åˆ¶

---

## åå…«ã€éƒ¨ç½²ä¸è¿è¡Œ

### 18.1 ç”Ÿäº§é»˜è®¤é…ç½®æ€»è¡¨

> **å•ä¸€æ¥æº**: æ‰€æœ‰æ•£è½åœ¨æ–‡æ¡£å„å¤„çš„é»˜è®¤å€¼æ±‡æ€»äºæ­¤ï¼Œç”Ÿäº§éƒ¨ç½²æ—¶ä»¥æœ¬è¡¨ä¸ºå‡†ã€‚

#### 18.1.0 å®ä¾‹æ ‡è¯†é…ç½®

> **å¤šæœºéƒ¨ç½²å¿…éœ€**: å½“æœ‰å¤šå°ç”µè„‘åŒæ—¶è¿è¡Œæ—¶ï¼Œéœ€è¦åŒºåˆ†æ—¥å¿—å’Œå‘Šè­¦æ¥æºã€‚

| é…ç½®é¡¹ | ç”Ÿäº§é»˜è®¤å€¼ | è¯´æ˜ |
|--------|-----------|------|
| `instance.machine_id` | `auto` | æœºå™¨æ ‡è¯† (auto=è‡ªåŠ¨ç”Ÿæˆ, æˆ–æŒ‡å®šå¦‚ "worker-01") |
| `instance.worker_name` | `""` | å¯è¯»åç§° (å¦‚ "åŠå…¬å®¤ç”µè„‘") |
| `instance.location` | `""` | ç‰©ç†ä½ç½® (å¯é€‰, å¦‚ "åŒ—äº¬åŠå…¬å®¤") |

```yaml
# config.yaml
instance:
  # æœºå™¨æ ‡è¯† - å¤šæœºéƒ¨ç½²æ—¶å¿…é¡»å”¯ä¸€
  # auto: è‡ªåŠ¨ç”Ÿæˆ (åŸºäº MAC åœ°å€)
  # æ‰‹åŠ¨æŒ‡å®š: "worker-01", "office-pc", etc.
  machine_id: auto

  # å¯è¯»åç§° - ç”¨äºæ—¥å¿—ã€å‘Šè­¦ã€UI æ˜¾ç¤º
  worker_name: "å‘å¸ƒæœº-1"

  # ç‰©ç†ä½ç½® - å¯é€‰
  location: "åŒ—äº¬åŠå…¬å®¤"
```

**æ—¥å¿—å’Œå‘Šè­¦ä¸­çš„ä½¿ç”¨:**

```python
# æ—¥å¿—æ ¼å¼ç¤ºä¾‹
logger.info(f"[{config.instance.machine_id}] ä»»åŠ¡æ‰§è¡ŒæˆåŠŸ: {task_id}")

# å‘Šè­¦é‚®ä»¶ä¸»é¢˜
subject = f"[é£æ§å‘Šè­¦] {config.instance.worker_name} è§¦å‘ç†”æ–­å™¨"

# å›æ‰§æ–‡ä»¶ä¸­å¢åŠ æ¥æºæ ‡è¯†
receipt['executed_by'] = {
    'machine_id': config.instance.machine_id,
    'worker_name': config.instance.worker_name
}
```

#### 18.1.1 å®‰å…¨ä¸éšç§é…ç½®

| é…ç½®é¡¹ | ç”Ÿäº§é»˜è®¤å€¼ | å¼€å‘é»˜è®¤å€¼ | é…ç½®è·¯å¾„ | è¯´æ˜ |
|--------|-----------|-----------|----------|------|
| `privacy.enabled` | `true` | `false` | config.yaml | éšç§è„±æ•æ€»å¼€å…³ |
| `privacy.phone_mask` | `true` | `false` | config.yaml | æ‰‹æœºå·è„±æ• |
| `privacy.wechat_id_mask` | `true` | `false` | config.yaml | å¾®ä¿¡IDè„±æ• |
| `privacy.group_name_mask` | `true` | `false` | config.yaml | ç¾¤åè„±æ• |
| `api.https.enabled` | `true` | `false` | config.yaml | å¼ºåˆ¶ HTTPS |
| `api.https.allow_insecure` | `false` | `true` | config.yaml | å…è®¸ä¸å®‰å…¨è¿æ¥ |
| `template.strict_domain_whitelist` | `true` | `false` | config.yaml | æ¨¡æ¿åŸŸåç™½åå• |
| `template.signature_required` | `true` | `false` | config.yaml | æ¨¡æ¿ç­¾åéªŒè¯ |

#### 18.1.2 è¿è¡Œæ¨¡å¼é…ç½®

| é…ç½®é¡¹ | ç”Ÿäº§é»˜è®¤å€¼ | è¯´æ˜ |
|--------|-----------|------|
| `run_mode` | `safe` | é¦–æ¬¡å¯åŠ¨é»˜è®¤å®‰å…¨æ¨¡å¼ |
| `mode_switch.require_reason` | `true` | åˆ‡æ¢å¿…é¡»å¡«å†™åŸå›  |
| `mode_switch.audit_enabled` | `true` | å®¡è®¡æ—¥å¿—å¼€å¯ |
| `mode_switch.high_risk_confirm` | `true` | é«˜é£é™©åˆ‡æ¢äºŒæ¬¡ç¡®è®¤ |

#### 18.1.3 é£æ§ä¸ç†”æ–­é…ç½®

| é…ç½®é¡¹ | ç”Ÿäº§é»˜è®¤å€¼ | è¯´æ˜ |
|--------|-----------|------|
| `risk.auto_shutdown_on_detection` | `true` | é£æ§æ£€æµ‹åè‡ªåŠ¨åœæœº |
| `risk.screenshot_on_failure` | `true` | å¤±è´¥æ—¶è‡ªåŠ¨æˆªå›¾ |
| `circuit_breaker.enabled` | `true` | ç†”æ–­å™¨å¯ç”¨ |
| `circuit_breaker.threshold` | `3` | è¿ç»­å¤±è´¥è§¦å‘é˜ˆå€¼ |
| `circuit_breaker.cooldown_minutes` | `30` | å†·å´æ—¶é—´ |

#### 18.1.4 GIF ä¸æ— äººå€¼å®ˆé…ç½®

| é…ç½®é¡¹ | ç”Ÿäº§é»˜è®¤å€¼ | è¯´æ˜ |
|--------|-----------|------|
| `gif_unattended_policy` | `cancel` | æ— äººå€¼å®ˆæ—¶å–æ¶ˆGIFä»»åŠ¡ |
| `unattended_detection.method` | `idle_time` | æ£€æµ‹æ–¹æ³• |
| `unattended_detection.idle_threshold_minutes` | `10` | ç©ºé—²åˆ¤å®šé˜ˆå€¼ |
| `unattended_detection.detection_failure_is_unattended` | `true` | æ£€æµ‹å¤±è´¥è§†ä¸ºæ— äººå€¼å®ˆ |

#### 18.1.5 æ•°æ®ç•™å­˜é…ç½®

| é…ç½®é¡¹ | ç”Ÿäº§é»˜è®¤å€¼ | è¯´æ˜ |
|--------|-----------|------|
| `retention.logs_days` | `90` | æ—¥å¿—ä¿ç•™å¤©æ•° |
| `retention.screenshots_days` | `30` | æˆªå›¾ä¿ç•™å¤©æ•° |
| `retention.receipts_days` | `365` | å›æ‰§ä¿ç•™å¤©æ•° |
| `retention.original_images_days` | `7` | åŸå›¾ä¿ç•™å¤©æ•° |
| `evidence.default_level` | `STANDARD` | é»˜è®¤è¯æ®ç­‰çº§ |

#### 18.1.6 é€šçŸ¥é…ç½®

**é‚®ä»¶é€šçŸ¥é…ç½®ï¼š**

| é…ç½®é¡¹ | ç”Ÿäº§é»˜è®¤å€¼ | è¯´æ˜ |
|--------|-----------|------|
| `notification.email.enabled` | `true` | **é‚®ä»¶é€šçŸ¥æ€»å¼€å…³** |
| `notification.email.on_success` | `false` | æˆåŠŸæ—¶å‘é‚®ä»¶ |
| `notification.email.on_failure` | `true` | å¤±è´¥æ—¶å‘é‚®ä»¶ |
| `notification.email.daily_summary` | `true` | æ¯æ—¥æ±‡æ€»é‚®ä»¶ |

**è¯­éŸ³é€šçŸ¥é…ç½®ï¼š**

| é…ç½®é¡¹ | ç”Ÿäº§é»˜è®¤å€¼ | è¯´æ˜ |
|--------|-----------|------|
| `notification.voice.enabled` | `true` | **è¯­éŸ³é€šçŸ¥æ€»å¼€å…³** |
| `notification.voice.on_success` | `true` | æˆåŠŸæ—¶è¯­éŸ³æ’­æŠ¥ |
| `notification.voice.on_failure` | `true` | å¤±è´¥æ—¶è¯­éŸ³æ’­æŠ¥ |
| `notification.voice.on_complete` | `true` | å…¨éƒ¨å®Œæˆæ—¶è¯­éŸ³æ’­æŠ¥ |
| `notification.voice.volume` | `80` | éŸ³é‡ (0-100) |

**å…¶ä»–é€šçŸ¥é…ç½®ï¼š**

| é…ç½®é¡¹ | ç”Ÿäº§é»˜è®¤å€¼ | è¯´æ˜ |
|--------|-----------|------|
| `notification.sms.on_risk` | `true` | é£æ§æ—¶å‘çŸ­ä¿¡ |
| `notification.webhook.enabled` | `false` | Webhooké»˜è®¤å…³é—­ |

#### 18.1.7 ç”Ÿäº§é…ç½®æ ¡éªŒ

> **å¯åŠ¨æ—¶å¼ºåˆ¶æ ¡éªŒ**: ä»¥ä¸‹é…ç½®åœ¨ç”Ÿäº§ç¯å¢ƒå¿…é¡»æ»¡è¶³ï¼Œå¦åˆ™é˜»æ­¢å¯åŠ¨ã€‚

```yaml
# ç”Ÿäº§ç¯å¢ƒå¼ºåˆ¶é…ç½® (config.yaml)
production_requirements:
  # ä»¥ä¸‹é…ç½®åœ¨ APP_ENV=production æ—¶å¼ºåˆ¶æ ¡éªŒ
  enforced:
    - path: "api.https.enabled"
      required_value: true
      error: "ç”Ÿäº§ç¯å¢ƒå¿…é¡»å¯ç”¨ HTTPS"

    - path: "api.https.allow_insecure"
      required_value: false
      error: "ç”Ÿäº§ç¯å¢ƒç¦æ­¢ä¸å®‰å…¨è¿æ¥"

    - path: "privacy.enabled"
      required_value: true
      error: "ç”Ÿäº§ç¯å¢ƒå¿…é¡»å¯ç”¨éšç§è„±æ•"

    - path: "template.signature_required"
      required_value: true
      error: "ç”Ÿäº§ç¯å¢ƒå¿…é¡»å¯ç”¨æ¨¡æ¿ç­¾åéªŒè¯"

  # ä»¥ä¸‹é…ç½®å¿…é¡»å­˜åœ¨ä¸”éç©º
  required_not_empty:
    - "share_folder"
    - "notification.email.smtp_host"
    - "notification.email.recipients"
```

### 18.2 æ“ä½œå‘˜èº«ä»½åˆå§‹åŒ–æµç¨‹

> **é¦–æ¬¡éƒ¨ç½²å¿…åš**: é…ç½®æ“ä½œå‘˜è´¦æˆ·ï¼Œå¦åˆ™æ‰€æœ‰æ•æ„Ÿæ“ä½œå°†è¢«æ‹’ç»ã€‚

#### 18.2.1 åˆå§‹åŒ–æ­¥éª¤

```
é¦–æ¬¡éƒ¨ç½²æ“ä½œå‘˜é…ç½®æµç¨‹
â”œâ”€â”€ Step 1: åˆ›å»ºå‡­æ®æ–‡ä»¶
â”‚   â””â”€â”€ config/operator_credentials.json
â”‚
â”œâ”€â”€ Step 2: ç”Ÿæˆå¯†ç å“ˆå¸Œ
â”‚   â””â”€â”€ python -c "import hashlib; print('sha256:' + hashlib.sha256(b'your_password').hexdigest())"
â”‚
â”œâ”€â”€ Step 3: é…ç½®é»˜è®¤ç®¡ç†å‘˜
â”‚   â””â”€â”€ è‡³å°‘é…ç½®ä¸€ä¸ª admin æˆ– super è´¦æˆ·
â”‚
â”œâ”€â”€ Step 4: éªŒè¯é…ç½®
â”‚   â””â”€â”€ å¯åŠ¨ç¨‹åºï¼Œæ£€æŸ¥ç™»å½•åŠŸèƒ½
â”‚
â””â”€â”€ Step 5: åˆ†å‘è´¦æˆ·
    â””â”€â”€ é€šè¿‡å®‰å…¨æ¸ é“å‘ŠçŸ¥æ“ä½œå‘˜
```

#### 18.2.2 é»˜è®¤æ“ä½œå‘˜é…ç½®æ¨¡æ¿

```json
// config/operator_credentials.json
// æ–‡ä»¶æƒé™: 600 (ä»…æ‰€æœ‰è€…å¯è¯»å†™)
{
  "_comment": "é¦–æ¬¡éƒ¨ç½²æ—¶è¯·ä¿®æ”¹ä»¥ä¸‹é»˜è®¤å¯†ç ",
  "admin": {
    "level": "admin",
    "password_hash": "sha256:è¯·æ›¿æ¢ä¸ºå®é™…å¯†ç å“ˆå¸Œ",
    "display_name": "é»˜è®¤ç®¡ç†å‘˜",
    "created_at": "2024-01-01T00:00:00",
    "must_change_password": true
  }
}
```

#### 18.2.3 å¯†ç é‡ç½®æµç¨‹

| åœºæ™¯ | æ“ä½œæ­¥éª¤ | æ‰§è¡Œè€… |
|------|----------|--------|
| **å¿˜è®°å¯†ç ** | 1. è”ç³» super ç®¡ç†å‘˜ 2. super é‡æ–°ç”Ÿæˆå¯†ç å“ˆå¸Œ 3. æ›´æ–°å‡­æ®æ–‡ä»¶ 4. é€šçŸ¥ç”¨æˆ·æ–°å¯†ç  | super |
| **è´¦æˆ·é”å®š** | 1. æ£€æŸ¥ `data/session/` ç›®å½• 2. åˆ é™¤å¯¹åº”ä¼šè¯æ–‡ä»¶ 3. é‡è¯•ç™»å½• | admin/super |
| **é¦–æ¬¡ç™»å½•** | 1. ä½¿ç”¨åˆå§‹å¯†ç ç™»å½• 2. ç³»ç»Ÿå¼ºåˆ¶è¦æ±‚ä¿®æ”¹å¯†ç  3. é‡æ–°ç™»å½• | ç”¨æˆ·è‡ªè¡Œ |
| **super å¯†ç ä¸¢å¤±** | 1. åœæ­¢ç¨‹åº 2. æ‰‹åŠ¨ç¼–è¾‘å‡­æ®æ–‡ä»¶ 3. é‡å¯ç¨‹åº | è¿ç»´ |

#### 18.2.4 æœªé…ç½®æ—¶çš„é»˜è®¤è¡Œä¸º

| åœºæ™¯ | ç³»ç»Ÿè¡Œä¸º | operator_id æ¥æº |
|------|----------|------------------|
| æ— å‡­æ®æ–‡ä»¶ | æ‰€æœ‰ç”¨æˆ·è§†ä¸º `operator` çº§åˆ« | ç³»ç»Ÿç”¨æˆ·å (sys:username) |
| æœ‰å‡­æ®æ–‡ä»¶ä½†æœªç™»å½• | æ•æ„Ÿæ“ä½œè¢«æ‹’ç» | ç³»ç»Ÿç”¨æˆ·å |
| å·²ç™»å½• | æŒ‰è´¦æˆ·æƒé™æ‰§è¡Œ | ç™»å½•è´¦æˆ· ID |

> **å®‰å…¨è­¦å‘Š**: æœªé…ç½®å‡­æ®æ–‡ä»¶æ—¶ï¼Œ`sys:` å‰ç¼€è´¦æˆ·åªèƒ½æ‰§è¡Œ `operator` çº§åˆ«æ“ä½œï¼Œæ— æ³•åˆ‡æ¢åˆ° `normal`/`test` æ¨¡å¼ã€‚

#### 18.2.5 æ“ä½œå‘˜æƒé™é€ŸæŸ¥è¡¨

| æ“ä½œ | operator | admin | super |
|------|----------|-------|-------|
| æŸ¥çœ‹ä»»åŠ¡åˆ—è¡¨ | âœ… | âœ… | âœ… |
| å¯¼å…¥ Excel | âœ… | âœ… | âœ… |
| æ‰‹åŠ¨æ‰§è¡Œä»»åŠ¡ | âœ… | âœ… | âœ… |
| åˆ‡æ¢åˆ°å®‰å…¨æ¨¡å¼ | âœ… | âœ… | âœ… |
| åˆ‡æ¢åˆ°æ¼”ç»ƒæ¨¡å¼ | âœ… | âœ… | âœ… |
| åˆ‡æ¢åˆ°æ­£å¸¸æ¨¡å¼ | âŒ | âœ… | âœ… |
| åˆ‡æ¢åˆ°æµ‹è¯•æ¨¡å¼ | âŒ | âœ… | âœ… |
| è®¿é—®å®Œæ•´ç‰ˆå›æ‰§ | âŒ | âœ… | âœ… |
| ä¿®æ”¹ç³»ç»Ÿé…ç½® | âŒ | âŒ | âœ… |
| ç®¡ç†æ“ä½œå‘˜è´¦æˆ· | âŒ | âŒ | âœ… |
| æ¸…é™¤åœæœºæ ‡è®° | âŒ | âœ… | âœ… |

### 18.3 è¿è¡Œæ—¶å‰ç½®æ£€æŸ¥æ¸…å•

ç¨‹åºå¯åŠ¨æ—¶æ‰§è¡Œå®Œæ•´çš„ç¯å¢ƒè‡ªæ£€, ç¡®ä¿è¿è¡Œæ¡ä»¶æ»¡è¶³:

```python
# core/env_checker.py

import ctypes
import subprocess
import os
from dataclasses import dataclass
from typing import List, Tuple

@dataclass
class CheckResult:
    """æ£€æŸ¥ç»“æœ"""
    name: str           # æ£€æŸ¥é¡¹åç§°
    passed: bool        # æ˜¯å¦é€šè¿‡
    message: str        # è¯¦ç»†ä¿¡æ¯
    critical: bool      # æ˜¯å¦ä¸ºå…³é”®æ£€æŸ¥ (å¤±è´¥åˆ™æ— æ³•è¿è¡Œ)
    fix_hint: str = ""  # ä¿®å¤å»ºè®®


class EnvironmentChecker:
    """ç¯å¢ƒè‡ªæ£€å™¨"""

    def run_all_checks(self) -> List[CheckResult]:
        """è¿è¡Œæ‰€æœ‰æ£€æŸ¥"""
        results = []

        # å…³é”®æ£€æŸ¥ (å¤±è´¥åˆ™æ— æ³•å¯åŠ¨)
        results.append(self.check_update_failed_flag())  # ä¼˜å…ˆæ£€æŸ¥åœæœºæ ‡è®°
        results.append(self.check_wechat_installed())
        results.append(self.check_wechat_running())
        results.append(self.check_wechat_logged_in())
        results.append(self.check_share_folder_access())

        # é‡è¦æ£€æŸ¥ (è­¦å‘Šä½†å¯ç»§ç»­)
        results.append(self.check_screen_resolution())
        results.append(self.check_dpi_scaling())
        results.append(self.check_screensaver_disabled())
        results.append(self.check_wechat_foreground())
        results.append(self.check_admin_mode())
        results.append(self.check_disk_space())
        results.append(self.check_time_sync())

        return results

    def check_update_failed_flag(self) -> CheckResult:
        """
        æ£€æŸ¥æ¨¡æ¿æ›´æ–°å¤±è´¥æ ‡è®°æ–‡ä»¶

        æ¨¡æ¿ç³»ç»Ÿåœ¨æ›´æ–°å¤±è´¥æ—¶ä¼šåˆ›å»º .update_failed æ ‡è®°æ–‡ä»¶,
        ç¨‹åºå¯åŠ¨æ—¶å¿…é¡»æ£€æŸ¥æ­¤æ ‡è®°, é˜»æ­¢åœ¨æ¨¡æ¿çŠ¶æ€ä¸ç¡®å®šæ—¶å‘å¸ƒå†…å®¹.

        å…³è”ç« èŠ‚: 6.2.3 æ›´æ–°å¤±è´¥å¤„ç†ä¸åœæœºä¿æŠ¤
        """
        UPDATE_FAILED_FLAG = Path("templates/.update_failed")

        if not UPDATE_FAILED_FLAG.exists():
            return CheckResult(
                name="æ¨¡æ¿æ›´æ–°çŠ¶æ€",
                passed=True,
                message="æ¨¡æ¿çŠ¶æ€æ­£å¸¸",
                critical=True
            )

        # æ ‡è®°æ–‡ä»¶å­˜åœ¨, è¯»å–å¤±è´¥ä¿¡æ¯
        try:
            with open(UPDATE_FAILED_FLAG, 'r', encoding='utf-8') as f:
                content = f.read()

            # è§£æå¤±è´¥ä¿¡æ¯ (æ ¼å¼: timestamp|error_message)
            lines = content.strip().split('\n')
            last_failure = lines[-1] if lines else "æœªçŸ¥é”™è¯¯"

            # æ£€æŸ¥æ˜¯å¦æ˜¯è¿‘æœŸå¤±è´¥ (24å°æ—¶å†…)
            from datetime import datetime, timedelta

            failure_time_str = last_failure.split('|')[0] if '|' in last_failure else None
            is_recent = False

            if failure_time_str:
                try:
                    failure_time = datetime.fromisoformat(failure_time_str)
                    is_recent = datetime.now() - failure_time < timedelta(hours=24)
                except ValueError:
                    pass

            return CheckResult(
                name="æ¨¡æ¿æ›´æ–°çŠ¶æ€",
                passed=False,
                message=f"æ£€æµ‹åˆ°æ¨¡æ¿æ›´æ–°å¤±è´¥æ ‡è®°: {last_failure[:80]}..." if len(last_failure) > 80 else f"æ£€æµ‹åˆ°æ¨¡æ¿æ›´æ–°å¤±è´¥æ ‡è®°: {last_failure}",
                critical=True,  # å…³é”®æ£€æŸ¥: é˜»æ­¢å¯åŠ¨
                fix_hint=(
                    "æ¨¡æ¿æ›´æ–°æ›¾å‘ç”Ÿå¤±è´¥, å‘å¸ƒå†…å®¹å¯èƒ½ä¸å®Œæ•´æˆ–ä¸æ­£ç¡®ã€‚\n"
                    "å¤„ç†æ­¥éª¤:\n"
                    "1. æ£€æŸ¥ç½‘ç»œè¿æ¥å’Œå…±äº«æ–‡ä»¶å¤¹è®¿é—®\n"
                    "2. æŸ¥çœ‹ logs/template_sync.log äº†è§£å¤±è´¥è¯¦æƒ…\n"
                    "3. æ‰‹åŠ¨éªŒè¯ templates/ ç›®å½•å†…å®¹æ˜¯å¦å®Œæ•´\n"
                    "4. ç¡®è®¤ä¿®å¤ååˆ é™¤æ ‡è®°æ–‡ä»¶: templates/.update_failed\n"
                    "5. é‡æ–°å¯åŠ¨ç¨‹åº"
                )
            )

        except Exception as e:
            return CheckResult(
                name="æ¨¡æ¿æ›´æ–°çŠ¶æ€",
                passed=False,
                message=f"æ— æ³•è¯»å–å¤±è´¥æ ‡è®°æ–‡ä»¶: {e}",
                critical=True,
                fix_hint="è¯·æ£€æŸ¥ templates/.update_failed æ–‡ä»¶æƒé™"
            )

    def check_wechat_installed(self) -> CheckResult:
        """æ£€æŸ¥å¾®ä¿¡æ˜¯å¦å·²å®‰è£…"""
        paths = [
            r"C:\Program Files\Tencent\WeChat\WeChat.exe",
            r"C:\Program Files (x86)\Tencent\WeChat\WeChat.exe",
        ]
        for path in paths:
            if os.path.exists(path):
                return CheckResult(
                    name="å¾®ä¿¡å®‰è£…",
                    passed=True,
                    message=f"å·²å®‰è£…: {path}",
                    critical=True
                )
        return CheckResult(
            name="å¾®ä¿¡å®‰è£…",
            passed=False,
            message="æœªæ‰¾åˆ°å¾®ä¿¡å®‰è£…",
            critical=True,
            fix_hint="è¯·å…ˆå®‰è£… PC ç‰ˆå¾®ä¿¡"
        )

    def check_wechat_running(self) -> CheckResult:
        """æ£€æŸ¥å¾®ä¿¡æ˜¯å¦åœ¨è¿è¡Œ"""
        import psutil
        for proc in psutil.process_iter(['name']):
            if proc.info['name'] == 'WeChat.exe':
                return CheckResult(
                    name="å¾®ä¿¡è¿›ç¨‹",
                    passed=True,
                    message="å¾®ä¿¡æ­£åœ¨è¿è¡Œ",
                    critical=True
                )
        return CheckResult(
            name="å¾®ä¿¡è¿›ç¨‹",
            passed=False,
            message="å¾®ä¿¡æœªè¿è¡Œ",
            critical=True,
            fix_hint="è¯·å¯åŠ¨å¾®ä¿¡å¹¶ç™»å½•"
        )

    def check_wechat_logged_in(self) -> CheckResult:
        """æ£€æŸ¥å¾®ä¿¡æ˜¯å¦å·²ç™»å½•"""
        ready, msg = check_wechat_ready()  # ä½¿ç”¨å‰é¢å®šä¹‰çš„å‡½æ•°
        return CheckResult(
            name="å¾®ä¿¡ç™»å½•",
            passed=ready,
            message=msg,
            critical=True,
            fix_hint="è¯·æ‰«ç ç™»å½•å¾®ä¿¡" if not ready else ""
        )

    def check_share_folder_access(self) -> CheckResult:
        """æ£€æŸ¥å…±äº«æ–‡ä»¶å¤¹æ˜¯å¦å¯è®¿é—®"""
        share_path = config.get('share_folder', '')
        if not share_path:
            return CheckResult(
                name="å…±äº«æ–‡ä»¶å¤¹",
                passed=False,
                message="æœªé…ç½®å…±äº«æ–‡ä»¶å¤¹è·¯å¾„",
                critical=True,
                fix_hint="è¯·åœ¨é…ç½®æ–‡ä»¶ä¸­è®¾ç½® share_folder"
            )

        if os.path.exists(share_path):
            # æ£€æŸ¥è¯»å†™æƒé™
            test_file = os.path.join(share_path, '.access_test')
            try:
                with open(test_file, 'w') as f:
                    f.write('test')
                os.remove(test_file)
                return CheckResult(
                    name="å…±äº«æ–‡ä»¶å¤¹",
                    passed=True,
                    message=f"å¯è®¿é—®: {share_path}",
                    critical=True
                )
            except (IOError, OSError, PermissionError):
                return CheckResult(
                    name="å…±äº«æ–‡ä»¶å¤¹",
                    passed=False,
                    message="å…±äº«æ–‡ä»¶å¤¹æ— å†™å…¥æƒé™",
                    critical=True,
                    fix_hint="è¯·æ£€æŸ¥å…±äº«æ–‡ä»¶å¤¹çš„å†™å…¥æƒé™"
                )
        else:
            return CheckResult(
                name="å…±äº«æ–‡ä»¶å¤¹",
                passed=False,
                message=f"è·¯å¾„ä¸å­˜åœ¨: {share_path}",
                critical=True,
                fix_hint="è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥å’Œå…±äº«æ–‡ä»¶å¤¹é…ç½®"
            )

    def check_screen_resolution(self) -> CheckResult:
        """æ£€æŸ¥å±å¹•åˆ†è¾¨ç‡"""
        user32 = ctypes.windll.user32
        width = user32.GetSystemMetrics(0)
        height = user32.GetSystemMetrics(1)

        if width >= 1920 and height >= 1080:
            return CheckResult(
                name="å±å¹•åˆ†è¾¨ç‡",
                passed=True,
                message=f"{width}x{height}",
                critical=False
            )
        else:
            return CheckResult(
                name="å±å¹•åˆ†è¾¨ç‡",
                passed=False,
                message=f"{width}x{height} (æ¨è 1920x1080)",
                critical=False,
                fix_hint="ä½åˆ†è¾¨ç‡å¯èƒ½å¯¼è‡´å…ƒç´ å®šä½ä¸å‡†ç¡®"
            )

    def check_dpi_scaling(self) -> CheckResult:
        """æ£€æŸ¥ DPI ç¼©æ”¾è®¾ç½®"""
        try:
            # è·å– DPI ç¼©æ”¾æ¯”ä¾‹
            user32 = ctypes.windll.user32
            user32.SetProcessDPIAware()
            dc = ctypes.windll.user32.GetDC(0)
            dpi = ctypes.windll.gdi32.GetDeviceCaps(dc, 88)  # LOGPIXELSX
            ctypes.windll.user32.ReleaseDC(0, dc)

            scaling = dpi / 96 * 100

            if 95 <= scaling <= 105:  # æ¥è¿‘ 100%
                return CheckResult(
                    name="DPI ç¼©æ”¾",
                    passed=True,
                    message=f"{scaling:.0f}%",
                    critical=False
                )
            else:
                return CheckResult(
                    name="DPI ç¼©æ”¾",
                    passed=False,
                    message=f"{scaling:.0f}% (æ¨è 100%)",
                    critical=False,
                    fix_hint="é 100% ç¼©æ”¾å¯èƒ½å½±å“åæ ‡è®¡ç®—, å»ºè®®è°ƒæ•´ä¸º 100%"
                )
        except (OSError, AttributeError):
            return CheckResult(
                name="DPI ç¼©æ”¾",
                passed=True,
                message="æ— æ³•æ£€æµ‹",
                critical=False
            )

    def check_screensaver_disabled(self) -> CheckResult:
        """æ£€æŸ¥å±ä¿æ˜¯å¦ç¦ç”¨"""
        try:
            import winreg
            key = winreg.OpenKey(
                winreg.HKEY_CURRENT_USER,
                r"Control Panel\Desktop"
            )
            screensaver, _ = winreg.QueryValueEx(key, "ScreenSaveActive")
            winreg.CloseKey(key)

            if screensaver == "0":
                return CheckResult(
                    name="å±å¹•ä¿æŠ¤",
                    passed=True,
                    message="å·²ç¦ç”¨",
                    critical=False
                )
            else:
                return CheckResult(
                    name="å±å¹•ä¿æŠ¤",
                    passed=False,
                    message="å·²å¯ç”¨",
                    critical=False,
                    fix_hint="å»ºè®®ç¦ç”¨å±ä¿ä»¥é¿å…ä»»åŠ¡æ‰§è¡Œä¸­æ–­"
                )
        except (OSError, FileNotFoundError):
            return CheckResult(
                name="å±å¹•ä¿æŠ¤",
                passed=True,
                message="æ— æ³•æ£€æµ‹",
                critical=False
            )

    def check_wechat_foreground(self) -> CheckResult:
        """æ£€æŸ¥å¾®ä¿¡çª—å£æ˜¯å¦åœ¨å‰å°"""
        import uiautomation as auto

        try:
            wechat = auto.WindowControl(ClassName='WeChatMainWndForPC')
            if wechat.Exists(1):
                # æ£€æŸ¥æ˜¯å¦è¢«é®æŒ¡
                hwnd = wechat.NativeWindowHandle
                user32 = ctypes.windll.user32
                foreground_hwnd = user32.GetForegroundWindow()

                if hwnd == foreground_hwnd:
                    return CheckResult(
                        name="å¾®ä¿¡å‰å°",
                        passed=True,
                        message="å¾®ä¿¡åœ¨å‰å°",
                        critical=False
                    )
                else:
                    return CheckResult(
                        name="å¾®ä¿¡å‰å°",
                        passed=False,
                        message="å¾®ä¿¡åœ¨åå°æˆ–è¢«é®æŒ¡",
                        critical=False,
                        fix_hint="æ‰§è¡Œä»»åŠ¡å‰ä¼šè‡ªåŠ¨å°†å¾®ä¿¡ç½®äºå‰å°"
                    )
        except Exception:
            pass

        return CheckResult(
            name="å¾®ä¿¡å‰å°",
            passed=True,
            message="æ— æ³•æ£€æµ‹",
            critical=False
        )

    def check_admin_mode(self) -> CheckResult:
        """æ£€æŸ¥æ˜¯å¦ä»¥ç®¡ç†å‘˜è¿è¡Œ"""
        try:
            is_admin = ctypes.windll.shell32.IsUserAnAdmin()
            if is_admin:
                return CheckResult(
                    name="ç®¡ç†å‘˜æƒé™",
                    passed=True,
                    message="ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œ",
                    critical=False
                )
            else:
                return CheckResult(
                    name="ç®¡ç†å‘˜æƒé™",
                    passed=True,  # éå¿…éœ€
                    message="æ™®é€šç”¨æˆ·æ¨¡å¼ (å¯é€‰ç®¡ç†å‘˜ä»¥å¯ç”¨ BlockInput)",
                    critical=False
                )
        except (OSError, AttributeError):
            return CheckResult(
                name="ç®¡ç†å‘˜æƒé™",
                passed=True,
                message="æ— æ³•æ£€æµ‹",
                critical=False
            )

    def check_disk_space(self) -> CheckResult:
        """æ£€æŸ¥ç£ç›˜ç©ºé—´"""
        import shutil

        total, used, free = shutil.disk_usage(os.getcwd())
        free_gb = free / (1024 ** 3)

        if free_gb >= 1:
            return CheckResult(
                name="ç£ç›˜ç©ºé—´",
                passed=True,
                message=f"å‰©ä½™ {free_gb:.1f} GB",
                critical=False
            )
        else:
            return CheckResult(
                name="ç£ç›˜ç©ºé—´",
                passed=False,
                message=f"å‰©ä½™ {free_gb:.2f} GB (ä¸è¶³)",
                critical=False,
                fix_hint="ç£ç›˜ç©ºé—´ä¸è¶³å¯èƒ½å¯¼è‡´æ—¥å¿—å’Œç¼“å­˜å†™å…¥å¤±è´¥"
            )

    def check_time_sync(self) -> CheckResult:
        """æ£€æŸ¥ç³»ç»Ÿæ—¶é—´åŒæ­¥"""
        try:
            # å°è¯•ä¸ç½‘ç»œæ—¶é—´æ¯”è¾ƒ
            import ntplib
            client = ntplib.NTPClient()
            response = client.request('pool.ntp.org', version=3)
            offset = abs(response.offset)

            if offset < 30:  # 30 ç§’å†…
                return CheckResult(
                    name="æ—¶é—´åŒæ­¥",
                    passed=True,
                    message=f"åå·® {offset:.1f} ç§’",
                    critical=False
                )
            else:
                return CheckResult(
                    name="æ—¶é—´åŒæ­¥",
                    passed=False,
                    message=f"åå·® {offset:.1f} ç§’",
                    critical=False,
                    fix_hint="ç³»ç»Ÿæ—¶é—´åå·®è¾ƒå¤§, å»ºè®®å¼€å¯è‡ªåŠ¨åŒæ­¥æ—¶é—´"
                )
        except (ImportError, OSError, Exception):
            return CheckResult(
                name="æ—¶é—´åŒæ­¥",
                passed=True,
                message="æ— æ³•æ£€æµ‹ (éœ€å®‰è£… ntplib)",
                critical=False
            )


def show_preflight_check_dialog(results: List[CheckResult]):
    """
    æ˜¾ç¤ºå¯åŠ¨å‰æ£€æŸ¥ç»“æœå¯¹è¯æ¡†

    å¦‚æœæœ‰å…³é”®æ£€æŸ¥å¤±è´¥, é˜»æ­¢ç¨‹åºå¯åŠ¨
    """
    critical_failures = [r for r in results if r.critical and not r.passed]
    warnings = [r for r in results if not r.critical and not r.passed]

    if critical_failures:
        # æ˜¾ç¤ºé”™è¯¯å¹¶é€€å‡º
        msg = "ä»¥ä¸‹å…³é”®æ£€æŸ¥æœªé€šè¿‡, ç¨‹åºæ— æ³•å¯åŠ¨:\n\n"
        for r in critical_failures:
            msg += f"[X] {r.name}: {r.message}\n"
            if r.fix_hint:
                msg += f"    -> {r.fix_hint}\n"

        QMessageBox.critical(None, "å¯åŠ¨æ£€æŸ¥å¤±è´¥", msg)
        sys.exit(1)

    elif warnings:
        # æ˜¾ç¤ºè­¦å‘Šä½†å…è®¸ç»§ç»­
        msg = "ä»¥ä¸‹æ£€æŸ¥é¡¹æœ‰è­¦å‘Š:\n\n"
        for r in warnings:
            msg += f"[!] {r.name}: {r.message}\n"
            if r.fix_hint:
                msg += f"    -> {r.fix_hint}\n"

        msg += "\næ˜¯å¦ç»§ç»­å¯åŠ¨?"

        reply = QMessageBox.warning(
            None, "å¯åŠ¨æ£€æŸ¥è­¦å‘Š", msg,
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )

        if reply == QMessageBox.No:
            sys.exit(0)
```

### 18.3.1 ç³»ç»Ÿè¦æ±‚

| é¡¹ç›® | æœ€ä½è¦æ±‚ | æ¨èé…ç½® |
|------|----------|----------|
| æ“ä½œç³»ç»Ÿ | Windows 10 | Windows 10/11 |
| CPU | åŒæ ¸ | å››æ ¸ |
| å†…å­˜ | 4GB | 8GB |
| ç¡¬ç›˜ | 500MB å¯ç”¨ç©ºé—´ | 1GB SSD |
| æ˜¾ç¤ºå™¨ | 1920x1080 | 1920x1080 |
| ç½‘ç»œ | å±€åŸŸç½‘è¿æ¥ | å±€åŸŸç½‘è¿æ¥ |

### 18.3.2 æƒé™è¦æ±‚

| æƒé™ | å¿…éœ€ | è¯´æ˜ |
|------|------|------|
| æ™®é€šç”¨æˆ· | æ˜¯ | åŸºæœ¬è¿è¡Œ |
| ç®¡ç†å‘˜ | å¯é€‰ | ä»… BlockInput åŠŸèƒ½éœ€è¦ |

### 18.3.3 å®‰è£…æ­¥éª¤

```bash
# 1. å®‰è£… Python 3.10+
# 2. å…‹éš†/ä¸‹è½½é¡¹ç›®
# 3. å®‰è£…ä¾èµ–
pip install -r requirements.txt

# 4. é…ç½®
cp config.example.yaml config.yaml
# ç¼–è¾‘ config.yaml

# 5. è¿è¡Œ
python main.py
```

### 18.3.4 æ‰“åŒ…ä¸º EXE

```bash
# ä½¿ç”¨ PyInstaller æ‰“åŒ…
pip install pyinstaller
pyinstaller --onefile --windowed --icon=icon.ico main.py
```

### 18.3.5 å¤šå®ä¾‹äº’æ–¥

```python
# main.py

import sys
from win32event import CreateMutex
from win32api import GetLastError
from winerror import ERROR_ALREADY_EXISTS

def ensure_single_instance():
    """ç¡®ä¿å•å®ä¾‹è¿è¡Œ"""
    mutex = CreateMutex(None, False, "WeChatAutoSender_Mutex")
    if GetLastError() == ERROR_ALREADY_EXISTS:
        show_error("ç¨‹åºå·²åœ¨è¿è¡Œä¸­, ä¸å…è®¸å¤šå¼€")
        sys.exit(1)
    return mutex

if __name__ == "__main__":
    mutex = ensure_single_instance()
    # å¯åŠ¨åº”ç”¨...
```

#### 18.4 è¿›ç¨‹äº’æ–¥ç”¨æˆ·é€šçŸ¥è§„èŒƒ

> **æ ¸å¿ƒåŸåˆ™**: å½“æ£€æµ‹åˆ°å·²æœ‰å®ä¾‹è¿è¡Œæ—¶ï¼Œå¿…é¡»ç»™ç”¨æˆ·æ˜ç¡®ã€å¯æ“ä½œçš„åé¦ˆï¼Œè€Œéé™é»˜é€€å‡ºã€‚

##### äº’æ–¥æ£€æµ‹åœºæ™¯ä¸å“åº”

| åœºæ™¯ | æ£€æµ‹æ–¹å¼ | ç”¨æˆ·é€šçŸ¥ | ç³»ç»Ÿè¡Œä¸º |
|------|----------|----------|----------|
| æ­£å¸¸å¤šå¼€å°è¯• | Mutex å·²å­˜åœ¨ | å¼¹çª—æç¤º | é€€å‡ºæ–°å®ä¾‹ï¼Œæ¿€æ´»å·²æœ‰çª—å£ |
| åƒµå°¸è¿›ç¨‹æ®‹ç•™ | Mutex å­˜åœ¨ä½†çª—å£æ— å“åº” | å¼¹çª—è¯¢é—® | æä¾›å¼ºåˆ¶æ¥ç®¡é€‰é¡¹ |
| è·¨ç”¨æˆ·ä¼šè¯ | ä¸åŒç”¨æˆ· Session çš„ Mutex | å¼¹çª—æç¤º | é˜»æ­¢å¯åŠ¨ï¼Œè¯´æ˜åŸå›  |
| å¼‚å¸¸å´©æºƒåé‡å¯ | Mutex æ®‹ç•™ + è¿›ç¨‹ä¸å­˜åœ¨ | è‡ªåŠ¨æ¸…ç† | æ¸…ç† Mutexï¼Œæ­£å¸¸å¯åŠ¨ |

##### ç”¨æˆ·é€šçŸ¥å¼¹çª—è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âš ï¸ ç¨‹åºå·²åœ¨è¿è¡Œä¸­                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  æ£€æµ‹åˆ°å¾®ä¿¡è‡ªåŠ¨å‘å¸ƒå·¥å…·å·²æœ‰ä¸€ä¸ªå®ä¾‹æ­£åœ¨è¿è¡Œã€‚                        â”‚
â”‚                                                                 â”‚
â”‚  ä¸ºç¡®ä¿å‘å¸ƒä»»åŠ¡ä¸å†²çªï¼ŒåŒæ—¶åªèƒ½è¿è¡Œä¸€ä¸ªå®ä¾‹ã€‚                        â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ å·²è¿è¡Œå®ä¾‹ä¿¡æ¯:                                          â”‚    â”‚
â”‚  â”‚ â€¢ è¿›ç¨‹ ID: 12345                                        â”‚    â”‚
â”‚  â”‚ â€¢ å¯åŠ¨æ—¶é—´: 2024-11-25 09:30:00                         â”‚    â”‚
â”‚  â”‚ â€¢ å½“å‰çŠ¶æ€: è¿è¡Œä¸­ (3 ä¸ªä»»åŠ¡æ’é˜Ÿ)                         â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                 â”‚
â”‚  è¯·é€‰æ‹©æ“ä½œ:                                                     â”‚
â”‚                                                                 â”‚
â”‚  [æ¿€æ´»å·²æœ‰çª—å£]  [å¼ºåˆ¶æ¥ç®¡*]  [é€€å‡º]                              â”‚
â”‚                                                                 â”‚
â”‚  *å¼ºåˆ¶æ¥ç®¡ä¼šç»ˆæ­¢å·²æœ‰å®ä¾‹ï¼Œå¯èƒ½å¯¼è‡´æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡ä¸­æ–­                  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

##### å®ç°ä»£ç 

```python
# core/single_instance.py

import sys
import ctypes
import psutil
from datetime import datetime
from win32event import CreateMutex, ReleaseMutex
from win32api import GetLastError, CloseHandle
from winerror import ERROR_ALREADY_EXISTS
from PySide6.QtWidgets import QMessageBox, QApplication

MUTEX_NAME = "WeChatAutoSender_Mutex"
WINDOW_CLASS = "WeChatAutoSender_MainWindow"

class SingleInstanceManager:
    """å•å®ä¾‹ç®¡ç†å™¨"""

    def __init__(self):
        self.mutex = None
        self.existing_pid = None

    def check_and_handle(self) -> bool:
        """
        æ£€æŸ¥å¹¶å¤„ç†å•å®ä¾‹

        Returns:
            True: å¯ä»¥ç»§ç»­å¯åŠ¨
            False: åº”è¯¥é€€å‡º
        """
        self.mutex = CreateMutex(None, False, MUTEX_NAME)

        if GetLastError() == ERROR_ALREADY_EXISTS:
            # å·²æœ‰å®ä¾‹ï¼Œè·å–è¯¦ç»†ä¿¡æ¯
            existing_info = self._get_existing_instance_info()

            if existing_info['zombie']:
                # åƒµå°¸è¿›ç¨‹ï¼Œè‡ªåŠ¨æ¸…ç†
                self._cleanup_zombie()
                return True

            # æ˜¾ç¤ºç”¨æˆ·é€‰æ‹©å¼¹çª—
            action = self._show_conflict_dialog(existing_info)

            if action == 'activate':
                self._activate_existing_window()
                return False
            elif action == 'takeover':
                self._force_takeover(existing_info['pid'])
                return True
            else:  # exit
                return False

        return True

    def _get_existing_instance_info(self) -> dict:
        """è·å–å·²è¿è¡Œå®ä¾‹ä¿¡æ¯"""
        for proc in psutil.process_iter(['pid', 'name', 'create_time', 'cmdline']):
            try:
                if 'WeChatAutoSender' in proc.info['name']:
                    return {
                        'pid': proc.info['pid'],
                        'start_time': datetime.fromtimestamp(proc.info['create_time']),
                        'zombie': not proc.is_running(),
                        'cmdline': proc.info['cmdline']
                    }
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                pass
        return {'pid': None, 'zombie': True}

    def _show_conflict_dialog(self, info: dict) -> str:
        """æ˜¾ç¤ºå†²çªå¤„ç†å¼¹çª—"""
        app = QApplication.instance() or QApplication(sys.argv)

        msg = QMessageBox()
        msg.setWindowTitle("ç¨‹åºå·²åœ¨è¿è¡Œä¸­")
        msg.setIcon(QMessageBox.Warning)
        msg.setText("æ£€æµ‹åˆ°å¾®ä¿¡è‡ªåŠ¨å‘å¸ƒå·¥å…·å·²æœ‰ä¸€ä¸ªå®ä¾‹æ­£åœ¨è¿è¡Œã€‚\n\n"
                    "ä¸ºç¡®ä¿å‘å¸ƒä»»åŠ¡ä¸å†²çªï¼ŒåŒæ—¶åªèƒ½è¿è¡Œä¸€ä¸ªå®ä¾‹ã€‚")

        detail = f"å·²è¿è¡Œå®ä¾‹ä¿¡æ¯:\n"
        detail += f"â€¢ è¿›ç¨‹ ID: {info.get('pid', 'æœªçŸ¥')}\n"
        detail += f"â€¢ å¯åŠ¨æ—¶é—´: {info.get('start_time', 'æœªçŸ¥')}\n"
        msg.setDetailedText(detail)

        activate_btn = msg.addButton("æ¿€æ´»å·²æœ‰çª—å£", QMessageBox.AcceptRole)
        takeover_btn = msg.addButton("å¼ºåˆ¶æ¥ç®¡", QMessageBox.DestructiveRole)
        exit_btn = msg.addButton("é€€å‡º", QMessageBox.RejectRole)

        msg.exec()

        if msg.clickedButton() == activate_btn:
            return 'activate'
        elif msg.clickedButton() == takeover_btn:
            return 'takeover'
        return 'exit'

    def _activate_existing_window(self):
        """æ¿€æ´»å·²æœ‰å®ä¾‹çš„çª—å£"""
        import win32gui
        import win32con

        def callback(hwnd, hwnds):
            if win32gui.IsWindowVisible(hwnd):
                class_name = win32gui.GetClassName(hwnd)
                if WINDOW_CLASS in class_name:
                    hwnds.append(hwnd)
            return True

        hwnds = []
        win32gui.EnumWindows(callback, hwnds)

        if hwnds:
            hwnd = hwnds[0]
            win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)
            win32gui.SetForegroundWindow(hwnd)

    def _force_takeover(self, pid: int):
        """
        å¼ºåˆ¶æ¥ç®¡ (å¸¦ä»»åŠ¡å®‰å…¨ç­–ç•¥)

        å®‰å…¨ç­–ç•¥:
        1. æ£€æŸ¥å·²æœ‰å®ä¾‹æ˜¯å¦æ­£åœ¨æ‰§è¡Œä»»åŠ¡
        2. å¦‚æ­£åœ¨æ‰§è¡Œï¼Œæç¤ºç”¨æˆ·é£é™©å¹¶è¦æ±‚äºŒæ¬¡ç¡®è®¤
        3. å‘é€ä¼˜é›…ç»ˆæ­¢ä¿¡å·ï¼Œç­‰å¾…ä»»åŠ¡çŠ¶æ€è½ç›˜
        4. è¶…æ—¶åæ‰å¼ºåˆ¶ç»ˆæ­¢
        """
        # 1. æ£€æŸ¥æ˜¯å¦æœ‰æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡
        running_task = self._check_running_task(pid)

        if running_task:
            # æœ‰æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡ï¼Œéœ€è¦äºŒæ¬¡ç¡®è®¤
            if not self._confirm_takeover_with_running_task(running_task):
                logger.info("ç”¨æˆ·å–æ¶ˆå¼ºåˆ¶æ¥ç®¡ (æœ‰è¿è¡Œä¸­ä»»åŠ¡)")
                return False

        # 2. å‘é€ä¼˜é›…ç»ˆæ­¢ä¿¡å·
        try:
            proc = psutil.Process(pid)

            # å°è¯•é€šè¿‡ Windows æ¶ˆæ¯é€šçŸ¥ç¨‹åºä¿å­˜çŠ¶æ€
            self._send_graceful_shutdown_signal(pid)

            # ç­‰å¾…ç¨‹åºè‡ªè¡Œé€€å‡º (ç»™äºˆä¿å­˜çŠ¶æ€çš„æ—¶é—´)
            try:
                proc.wait(timeout=10)  # 10ç§’ç­‰å¾…ä¼˜é›…é€€å‡º
                logger.info(f"å·²æœ‰å®ä¾‹ (PID={pid}) å·²ä¼˜é›…é€€å‡º")
                return True
            except psutil.TimeoutExpired:
                logger.warning(f"ä¼˜é›…é€€å‡ºè¶…æ—¶ï¼Œå‘é€ terminate ä¿¡å·")

            # 3. å‘é€ terminate ä¿¡å·
            proc.terminate()
            try:
                proc.wait(timeout=5)
                return True
            except psutil.TimeoutExpired:
                logger.warning(f"terminate è¶…æ—¶ï¼Œå¼ºåˆ¶ kill")

            # 4. æœ€åæ‰‹æ®µ: å¼ºåˆ¶ç»ˆæ­¢
            proc.kill()
            return True

        except psutil.NoSuchProcess:
            logger.info(f"è¿›ç¨‹ {pid} å·²ä¸å­˜åœ¨")
            return True
        except Exception as e:
            logger.error(f"å¼ºåˆ¶æ¥ç®¡å¤±è´¥: {e}")
            return False

    def _check_running_task(self, pid: int) -> dict:
        """æ£€æŸ¥å·²æœ‰å®ä¾‹æ˜¯å¦æœ‰è¿è¡Œä¸­çš„ä»»åŠ¡"""
        try:
            # å°è¯•è¯»å–å…±äº«çŠ¶æ€æ–‡ä»¶
            status_file = Path("data/.instance_status.json")
            if status_file.exists():
                with open(status_file, 'r') as f:
                    status = json.load(f)
                if status.get('pid') == pid and status.get('running_task'):
                    return status['running_task']
        except (json.JSONDecodeError, IOError, KeyError):
            pass
        return None

    def _confirm_takeover_with_running_task(self, task: dict) -> bool:
        """æœ‰è¿è¡Œä¸­ä»»åŠ¡æ—¶çš„äºŒæ¬¡ç¡®è®¤"""
        msg = QMessageBox()
        msg.setWindowTitle("è­¦å‘Š: æœ‰ä»»åŠ¡æ­£åœ¨æ‰§è¡Œ")
        msg.setIcon(QMessageBox.Critical)
        msg.setText(
            f"æ£€æµ‹åˆ°å·²æœ‰å®ä¾‹æ­£åœ¨æ‰§è¡Œä»»åŠ¡:\n\n"
            f"ä»»åŠ¡ID: {task.get('id', 'æœªçŸ¥')}\n"
            f"å†…å®¹: {task.get('product_name', 'æœªçŸ¥')}\n"
            f"çŠ¶æ€: {task.get('status', 'running')}\n\n"
            f"å¼ºåˆ¶æ¥ç®¡å¯èƒ½å¯¼è‡´:\n"
            f"â€¢ å½“å‰ä»»åŠ¡ä¸­æ–­\n"
            f"â€¢ ä»»åŠ¡çŠ¶æ€å¯èƒ½ä¸¢å¤±\n"
            f"â€¢ å¯èƒ½äº§ç”Ÿé‡å¤å‘å¸ƒ\n\n"
            f"ç¡®å®šè¦å¼ºåˆ¶æ¥ç®¡å—?"
        )
        msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        msg.setDefaultButton(QMessageBox.No)
        return msg.exec() == QMessageBox.Yes

    def _send_graceful_shutdown_signal(self, pid: int):
        """å‘é€ä¼˜é›…å…³é—­ä¿¡å·"""
        try:
            import win32gui
            import win32con

            # æŸ¥æ‰¾ç›®æ ‡çª—å£å¹¶å‘é€ WM_CLOSE
            def callback(hwnd, _):
                _, found_pid = win32process.GetWindowThreadProcessId(hwnd)
                if found_pid == pid:
                    win32gui.PostMessage(hwnd, win32con.WM_CLOSE, 0, 0)
                return True

            win32gui.EnumWindows(callback, None)
        except (OSError, AttributeError):
            pass

    def _cleanup_zombie(self):
        """æ¸…ç†åƒµå°¸ Mutex"""
        if self.mutex:
            CloseHandle(self.mutex)
        self.mutex = CreateMutex(None, False, MUTEX_NAME)
```

##### æ—¥å¿—è®°å½•è§„èŒƒ

| äº‹ä»¶ | æ—¥å¿—çº§åˆ« | æ—¥å¿—å†…å®¹ |
|------|----------|----------|
| é¦–æ¬¡å¯åŠ¨æˆåŠŸ | INFO | `å•å®ä¾‹æ£€æŸ¥é€šè¿‡ï¼Œç¨‹åºæ­£å¸¸å¯åŠ¨` |
| æ£€æµ‹åˆ°å·²æœ‰å®ä¾‹ | WARNING | `æ£€æµ‹åˆ°å·²æœ‰å®ä¾‹ (PID={pid})ï¼Œç”¨æˆ·é€‰æ‹©: {action}` |
| æ¿€æ´»å·²æœ‰çª—å£ | INFO | `å·²æ¿€æ´»å·²æœ‰å®ä¾‹çª—å£ï¼Œå½“å‰å®ä¾‹é€€å‡º` |
| å¼ºåˆ¶æ¥ç®¡ | WARNING | `ç”¨æˆ·é€‰æ‹©å¼ºåˆ¶æ¥ç®¡ï¼Œå·²ç»ˆæ­¢ PID={pid}` |
| åƒµå°¸è¿›ç¨‹æ¸…ç† | INFO | `æ£€æµ‹åˆ°åƒµå°¸ Mutexï¼Œå·²è‡ªåŠ¨æ¸…ç†` |
| ç”¨æˆ·é€‰æ‹©é€€å‡º | INFO | `ç”¨æˆ·é€‰æ‹©é€€å‡ºï¼Œæœªå¯åŠ¨æ–°å®ä¾‹` |

---

## åä¹ã€API å®‰å…¨è§„èŒƒ (ç¬¬äºŒé˜¶æ®µ)

> **çŠ¶æ€è¯´æ˜**: API åŠŸèƒ½ä¸ºç¬¬äºŒé˜¶æ®µè§„åˆ’ï¼Œå½“å‰ç‰ˆæœ¬ (v1.9) æš‚ä¸å®ç°ã€‚ä»¥ä¸‹ä¸ºå®Œæ•´è§„èŒƒï¼Œä¾›åç»­å¼€å‘å‚è€ƒã€‚

### 19.0 API ç«¯ç‚¹åˆ—è¡¨ä¸å¯åŠ¨é…ç½®æ ¡éªŒ

> **æ ¸å¿ƒåŸåˆ™**: æ˜ç¡®åˆ—å‡ºæ‰€æœ‰è§„åˆ’çš„ API ç«¯ç‚¹åŠå…¶å®‰å…¨è¦æ±‚ï¼Œå¯åŠ¨æ—¶è¿›è¡Œé…ç½®å®Œæ•´æ€§æ ¡éªŒã€‚
>
> **é‡è¦**: å½“ `api.enabled = false` æ—¶ï¼Œ**å®Œå…¨è·³è¿‡** API ç›¸å…³çš„æ‰€æœ‰æ ¡éªŒå’Œä¾èµ–æ£€æŸ¥ï¼Œä¸ä¼šé˜»å¡ç¨‹åºå¯åŠ¨ã€‚

#### API ç«¯ç‚¹æ€»è¡¨

| ç«¯ç‚¹ | æ–¹æ³• | æè¿° | è®¤è¯ | æƒé™ | è®¡åˆ’ç‰ˆæœ¬ | çŠ¶æ€ |
|------|------|------|------|------|----------|------|
| **ä»»åŠ¡ç®¡ç†** |
| `/api/v1/tasks` | GET | è·å–ä»»åŠ¡åˆ—è¡¨ | Bearer | operator | v2.0 | è§„åˆ’ |
| `/api/v1/tasks` | POST | åˆ›å»ºæ–°ä»»åŠ¡ | Bearer+Sign | operator | v2.0 | è§„åˆ’ |
| `/api/v1/tasks/{id}` | GET | è·å–ä»»åŠ¡è¯¦æƒ… | Bearer | operator | v2.0 | è§„åˆ’ |
| `/api/v1/tasks/{id}` | PUT | æ›´æ–°ä»»åŠ¡ | Bearer+Sign | operator | v2.0 | è§„åˆ’ |
| `/api/v1/tasks/{id}` | DELETE | åˆ é™¤ä»»åŠ¡ | Bearer+Sign | admin | v2.0 | è§„åˆ’ |
| `/api/v1/tasks/{id}/execute` | POST | ç«‹å³æ‰§è¡Œä»»åŠ¡ | Bearer+Sign | operator | v2.0 | è§„åˆ’ |
| `/api/v1/tasks/{id}/cancel` | POST | å–æ¶ˆä»»åŠ¡ | Bearer+Sign | operator | v2.0 | è§„åˆ’ |
| **é˜Ÿåˆ—æ§åˆ¶** |
| `/api/v1/queue/status` | GET | è·å–é˜Ÿåˆ—çŠ¶æ€ | Bearer | operator | v2.0 | è§„åˆ’ |
| `/api/v1/queue/pause` | POST | æš‚åœé˜Ÿåˆ— | Bearer+Sign | operator | v2.0 | è§„åˆ’ |
| `/api/v1/queue/resume` | POST | æ¢å¤é˜Ÿåˆ— | Bearer+Sign | operator | v2.0 | è§„åˆ’ |
| **ç³»ç»ŸçŠ¶æ€** |
| `/api/v1/health` | GET | å¥åº·æ£€æŸ¥ | æ—  | public | v2.0 | è§„åˆ’ |
| `/api/v1/status` | GET | ç³»ç»ŸçŠ¶æ€ | Bearer | operator | v2.0 | è§„åˆ’ |
| `/api/v1/metrics` | GET | è¿è¡ŒæŒ‡æ ‡ | Bearer | admin | v2.0 | è§„åˆ’ |
| **é£æ§æ“ä½œ** |
| `/api/v1/risk/circuit-breaker` | GET | ç†”æ–­å™¨çŠ¶æ€ | Bearer | operator | v2.0 | è§„åˆ’ |
| `/api/v1/risk/circuit-breaker/reset` | POST | é‡ç½®ç†”æ–­å™¨ | Bearer+Sign | admin | v2.0 | è§„åˆ’ |
| `/api/v1/risk/shutdown` | POST | é£æ§åœæœº | Bearer+Sign | admin | v2.0 | è§„åˆ’ |
| **é…ç½®ç®¡ç†** |
| `/api/v1/config` | GET | è·å–é…ç½® (è„±æ•) | Bearer | admin | v2.0 | è§„åˆ’ |
| `/api/v1/config/mode` | PUT | åˆ‡æ¢è¿è¡Œæ¨¡å¼ | Bearer+Sign | super | v2.0 | è§„åˆ’ |

#### è®¤è¯çº§åˆ«è¯´æ˜

| çº§åˆ« | æ ‡è¯† | è¦æ±‚ | é€‚ç”¨åœºæ™¯ |
|------|------|------|----------|
| æ— è®¤è¯ | `æ— ` | æ— éœ€ä»»ä½•å‡­è¯ | å¥åº·æ£€æŸ¥ |
| Token | `Bearer` | Authorization: Bearer {token} | åªè¯»æŸ¥è¯¢ |
| Token+ç­¾å | `Bearer+Sign` | Bearer + X-Timestamp + X-Signature | å†™æ“ä½œ |

#### å¯åŠ¨é…ç½®æ ¡éªŒ

```python
# core/api_config_validator.py

from dataclasses import dataclass
from typing import List, Optional
import re

@dataclass
class APIConfigError:
    """API é…ç½®é”™è¯¯"""
    field: str
    message: str
    severity: str  # 'error' | 'warning'

class APIConfigValidator:
    """API é…ç½®æ ¡éªŒå™¨"""

    REQUIRED_FIELDS = [
        ('api.enabled', bool, "API å¼€å…³å¿…é¡»æ˜ç¡®è®¾ç½®"),
        ('api.base_url', str, "base_url å¿…é¡»é…ç½®"),
        ('api.token', str, "token å¿…é¡»é…ç½® (å¯ä½¿ç”¨ç¯å¢ƒå˜é‡)"),
        ('api.secret', str, "secret å¿…é¡»é…ç½® (å¯ä½¿ç”¨ç¯å¢ƒå˜é‡)"),
    ]

    CONDITIONAL_FIELDS = {
        'https_enabled': [
            ('api.https.cert_path', str, "HTTPS å¯ç”¨æ—¶å¿…é¡»é…ç½®è¯ä¹¦è·¯å¾„"),
            ('api.https.key_path', str, "HTTPS å¯ç”¨æ—¶å¿…é¡»é…ç½®ç§é’¥è·¯å¾„"),
        ]
    }

    def validate(self, config: dict) -> List[APIConfigError]:
        """
        æ ¡éªŒ API é…ç½®

        Returns:
            é”™è¯¯åˆ—è¡¨ (ä¸ºç©ºè¡¨ç¤ºæ ¡éªŒé€šè¿‡)
        """
        errors = []

        # API æœªå¯ç”¨æ—¶è·³è¿‡è¯¦ç»†æ ¡éªŒ
        api_config = config.get('api', {})
        if not api_config.get('enabled', False):
            return errors

        # å¿…å¡«é¡¹æ ¡éªŒ
        for path, expected_type, message in self.REQUIRED_FIELDS:
            value = self._get_nested(config, path)
            if value is None:
                errors.append(APIConfigError(path, message, 'error'))
            elif not isinstance(value, expected_type):
                errors.append(APIConfigError(
                    path, f"ç±»å‹é”™è¯¯: æœŸæœ› {expected_type.__name__}", 'error'))

        # æ¡ä»¶æ ¡éªŒ
        if api_config.get('https', {}).get('enabled', True):
            for path, expected_type, message in self.CONDITIONAL_FIELDS['https_enabled']:
                value = self._get_nested(config, path)
                if value is None or not isinstance(value, expected_type):
                    errors.append(APIConfigError(path, message, 'error'))

        # URL æ ¼å¼æ ¡éªŒ
        base_url = api_config.get('base_url', '')
        if base_url and not self._validate_url(base_url):
            errors.append(APIConfigError(
                'api.base_url', 'æ— æ•ˆçš„ URL æ ¼å¼', 'error'))

        # å®‰å…¨è­¦å‘Š
        if api_config.get('https', {}).get('allow_insecure', False):
            errors.append(APIConfigError(
                'api.https.allow_insecure',
                'è­¦å‘Š: ä¸å®‰å…¨è¿æ¥å·²å¯ç”¨ï¼Œä»…é™å¼€å‘ç¯å¢ƒ',
                'warning'))

        # IP ç™½åå•æ ¡éªŒ
        ip_whitelist = api_config.get('ip_whitelist', [])
        if not ip_whitelist:
            errors.append(APIConfigError(
                'api.ip_whitelist',
                'è­¦å‘Š: IP ç™½åå•ä¸ºç©ºï¼ŒAPI å°†æ¥å—ä»»æ„æ¥æºè¯·æ±‚',
                'warning'))

        return errors

    def _get_nested(self, config: dict, path: str):
        """è·å–åµŒå¥—é…ç½®å€¼"""
        keys = path.split('.')
        value = config
        for key in keys:
            if isinstance(value, dict):
                value = value.get(key)
            else:
                return None
        return value

    def _validate_url(self, url: str) -> bool:
        """éªŒè¯ URL æ ¼å¼"""
        pattern = r'^https?://[a-zA-Z0-9\-\.]+(:\d+)?(/.*)?$'
        return bool(re.match(pattern, url))


def validate_api_on_startup(config: dict) -> bool:
    """
    å¯åŠ¨æ—¶æ ¡éªŒ API é…ç½®

    Returns:
        True: é…ç½®æœ‰æ•ˆï¼Œå¯ä»¥å¯åŠ¨
        False: é…ç½®æ— æ•ˆï¼Œåº”é˜»æ­¢å¯åŠ¨
    """
    validator = APIConfigValidator()
    errors = validator.validate(config)

    has_errors = False
    for error in errors:
        if error.severity == 'error':
            logger.error(f"API é…ç½®é”™è¯¯ [{error.field}]: {error.message}")
            has_errors = True
        else:
            logger.warning(f"API é…ç½®è­¦å‘Š [{error.field}]: {error.message}")

    if has_errors:
        logger.error("API é…ç½®æ ¡éªŒå¤±è´¥ï¼Œè¯·æ£€æŸ¥ config.yaml")
        return False

    logger.info("API é…ç½®æ ¡éªŒé€šè¿‡")
    return True
```

#### å¯åŠ¨æ ¡éªŒæµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    API å¯åŠ¨é…ç½®æ ¡éªŒæµç¨‹                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  [åŠ è½½ config.yaml]                                              â”‚
â”‚         â”‚                                                        â”‚
â”‚         â–¼                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     å¦ (é»˜è®¤)                                   â”‚
â”‚  â”‚ api.enabled? â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º [å®Œå…¨è·³è¿‡ API ç›¸å…³æ ¡éªŒ]            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚                                 â”‚
â”‚         â”‚ æ˜¯                   â–¼                                 â”‚
â”‚         â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚         â”‚              â”‚ â€¢ ä¸æ£€æŸ¥ token/secret   â”‚               â”‚
â”‚         â”‚              â”‚ â€¢ ä¸æ£€æŸ¥ HTTPS è¯ä¹¦     â”‚               â”‚
â”‚         â”‚              â”‚ â€¢ ä¸æ£€æŸ¥ IP ç™½åå•      â”‚               â”‚
â”‚         â”‚              â”‚ â€¢ ä¸åŠ è½½ API ä¾èµ–       â”‚               â”‚
â”‚         â”‚              â”‚ â€¢ ç¨‹åºæ­£å¸¸å¯åŠ¨          â”‚               â”‚
â”‚         â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚         â–¼                                                        â”‚
â”‚  [æ ¡éªŒå¿…å¡«é…ç½®é¡¹]                                                  â”‚
â”‚  â€¢ base_url                                                      â”‚
â”‚  â€¢ token                                                         â”‚
â”‚  â€¢ secret                                                        â”‚
â”‚         â”‚                                                        â”‚
â”‚         â–¼                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     æ˜¯                                         â”‚
â”‚  â”‚ å­˜åœ¨ error?  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º [è®°å½•é”™è¯¯] â”€â”€â–º [é˜»æ­¢ API å¯åŠ¨]     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                â”‚
â”‚         â”‚ å¦                                                     â”‚
â”‚         â–¼                                                        â”‚
â”‚  [æ ¡éªŒæ¡ä»¶é…ç½®é¡¹]                                                  â”‚
â”‚  â€¢ HTTPS è¯ä¹¦è·¯å¾„ (å¦‚å¯ç”¨)                                        â”‚
â”‚         â”‚                                                        â”‚
â”‚         â–¼                                                        â”‚
â”‚  [è¾“å‡ºè­¦å‘Šé¡¹]                                                     â”‚
â”‚  â€¢ allow_insecure                                                â”‚
â”‚  â€¢ ç©º IP ç™½åå•                                                   â”‚
â”‚         â”‚                                                        â”‚
â”‚         â–¼                                                        â”‚
â”‚  [API æ­£å¸¸å¯åŠ¨]                                                   â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 19.1 è®¤è¯æ–¹å¼

```
Authorization: Bearer <token>
X-Timestamp: 1700000000
X-Signature: <hmac_sha256(token + timestamp + body, secret)>
```

### 19.2 ç­¾åç®—æ³•

```python
import hmac
import hashlib

def generate_signature(token: str, timestamp: int, body: str, secret: str) -> str:
    """ç”Ÿæˆè¯·æ±‚ç­¾å"""
    message = f"{token}{timestamp}{body}"
    return hmac.new(
        secret.encode(),
        message.encode(),
        hashlib.sha256
    ).hexdigest()

def verify_signature(request, secret: str) -> bool:
    """éªŒè¯è¯·æ±‚ç­¾å"""
    token = request.headers.get('Authorization', '').replace('Bearer ', '')
    timestamp = int(request.headers.get('X-Timestamp', 0))
    signature = request.headers.get('X-Signature', '')
    body = request.body.decode()

    # æ£€æŸ¥æ—¶é—´æˆ³ (é˜²é‡æ”¾, 5åˆ†é’Ÿæœ‰æ•ˆ)
    if abs(time.time() - timestamp) > 300:
        return False

    expected = generate_signature(token, timestamp, body, secret)
    return hmac.compare_digest(signature, expected)
```

### 19.3 å®‰å…¨é…ç½®

```yaml
# config.yaml
api:
  enabled: false
  # é»˜è®¤ HTTPS, ç”Ÿäº§ç¯å¢ƒå¿…é¡»ä½¿ç”¨ HTTPS
  base_url: "https://192.168.1.100:3000"
  token: "${WECHAT_BOT_TOKEN}"
  secret: "${WECHAT_BOT_SECRET}"
  ip_whitelist:
    - "192.168.1.0/24"
  rate_limit:
    requests_per_minute: 60

  # TLS/HTTPS é…ç½®
  https:
    enabled: true                       # é»˜è®¤å¯ç”¨ HTTPS
    cert_path: "certs/server.crt"       # SSL è¯ä¹¦è·¯å¾„
    key_path: "certs/server.key"        # SSL ç§é’¥è·¯å¾„

    # å®‰å…¨ç­–ç•¥ (ä»…å¼€å‘/æµ‹è¯•ç¯å¢ƒä½¿ç”¨)
    allow_insecure: false               # æ˜¯å¦å…è®¸ä¸å®‰å…¨è¿æ¥ (HTTP)
    # è­¦å‘Š: è®¾ä¸º true ä»…é™ä»¥ä¸‹åœºæ™¯:
    #   - å¼€å‘ç¯å¢ƒæœ¬åœ°æµ‹è¯•
    #   - éš”ç¦»çš„å†…ç½‘ç¯å¢ƒä¸”æ— æ•æ„Ÿæ•°æ®
    # ç”Ÿäº§ç¯å¢ƒå¿…é¡»ä¸º false
```

**HTTPS å¼ºåˆ¶ç­–ç•¥:**

| ç¯å¢ƒ | allow_insecure | base_url åè®® | è¯´æ˜ |
|------|----------------|---------------|------|
| ç”Ÿäº§ | false (å¼ºåˆ¶) | https:// | å¿…é¡»é…ç½®æœ‰æ•ˆè¯ä¹¦ |
| æµ‹è¯• | false (æ¨è) | https:// | å¯ç”¨è‡ªç­¾åè¯ä¹¦ |
| å¼€å‘ | true (å¯é€‰) | http:// | ä»…é™æœ¬åœ°éš”ç¦»ç¯å¢ƒ |

```python
# é…ç½®æ ¡éªŒç¤ºä¾‹
import os

def get_environment() -> str:
    """è·å–å½“å‰è¿è¡Œç¯å¢ƒ"""
    # æ”¯æŒå¤šç§ç¯å¢ƒå˜é‡å‘½å
    env = os.environ.get('APP_ENV') or os.environ.get('ENVIRONMENT') or os.environ.get('ENV')
    if env in ('production', 'prod'):
        return 'production'
    elif env in ('test', 'testing', 'staging'):
        return 'test'
    else:
        return 'development'

def validate_api_config(config: dict) -> None:
    """
    æ ¡éªŒ API é…ç½®å®‰å…¨æ€§

    ç”Ÿäº§ç¯å¢ƒå¼ºåˆ¶ç¦æ­¢ allow_insecure=true
    """
    api_config = config.get('api', {})

    if not api_config.get('enabled', False):
        return

    env = get_environment()
    base_url = api_config.get('base_url', '')
    https_config = api_config.get('https', {})
    allow_insecure = https_config.get('allow_insecure', False)

    # ç”Ÿäº§ç¯å¢ƒå¼ºåˆ¶ç¦æ­¢ä¸å®‰å…¨è¿æ¥
    if env == 'production' and allow_insecure:
        raise ConfigError(
            "ç”Ÿäº§ç¯å¢ƒç¦æ­¢è®¾ç½® allow_insecure: true\n"
            "è¯·ä½¿ç”¨ HTTPS å¹¶é…ç½®æœ‰æ•ˆè¯ä¹¦"
        )

    # æ£€æŸ¥åè®®ä¸é…ç½®ä¸€è‡´æ€§
    if base_url.startswith('http://') and not allow_insecure:
        raise ConfigError(
            "HTTP URL éœ€è¦æ˜¾å¼è®¾ç½® https.allow_insecure: true\n"
            "è­¦å‘Š: ä¸å®‰å…¨è¿æ¥ä»…é™å¼€å‘ç¯å¢ƒä½¿ç”¨"
        )

    # ç”Ÿäº§/æµ‹è¯•ç¯å¢ƒå¿…é¡»ä½¿ç”¨ HTTPS
    if env in ('production', 'test') and base_url.startswith('http://'):
        raise ConfigError(
            f"{env} ç¯å¢ƒå¿…é¡»ä½¿ç”¨ HTTPS\n"
            "è¯·å°† base_url æ”¹ä¸º https:// åè®®"
        )

    if not allow_insecure and https_config.get('enabled', True):
        # HTTPS å¯ç”¨æ—¶æ£€æŸ¥è¯ä¹¦é…ç½®
        cert_path = https_config.get('cert_path')
        key_path = https_config.get('key_path')
        if not cert_path or not key_path:
            raise ConfigError("HTTPS å¯ç”¨æ—¶å¿…é¡»é…ç½® cert_path å’Œ key_path")

    logger.info(f"API é…ç½®æ ¡éªŒé€šè¿‡ (ç¯å¢ƒ: {env}, HTTPS: {not allow_insecure})")
```

**ç¯å¢ƒæ£€æµ‹æ–¹å¼:**

| ç¯å¢ƒå˜é‡ | ç”Ÿäº§ç¯å¢ƒå€¼ | æµ‹è¯•ç¯å¢ƒå€¼ | å¼€å‘ç¯å¢ƒå€¼ |
|----------|-----------|-----------|-----------|
| `APP_ENV` | `production` / `prod` | `test` / `staging` | `development` / å…¶ä»– |
| `ENVIRONMENT` | åŒä¸Š | åŒä¸Š | åŒä¸Š |
| `ENV` | åŒä¸Š | åŒä¸Š | åŒä¸Š |

---

## äºŒåã€äº¤ä»˜èŒƒå›´ä¸åˆ†é˜¶æ®µè®¡åˆ’

> **æ ¸å¿ƒåŸåˆ™**: æ˜ç¡®æ¯ä¸ªç‰ˆæœ¬çš„éœ€æ±‚äº¤ä»˜èƒ½åŠ›ï¼ŒåŒºåˆ†"éœ€æ±‚å·²å®šç¨¿"ã€"æœ¬ç‰ˆæœ¬ç›®æ ‡"ã€"è§„åˆ’ä¸­/å ä½"çŠ¶æ€ã€‚
>
> **æœ¯è¯­è¯´æ˜**:
> - **å·²äº¤ä»˜** = éœ€æ±‚å·²ç¡®å®šï¼Œå¯è¿›å…¥å¼€å‘/å·²æœ‰å®ç°è§„èŒƒ
> - **è§„åˆ’** = éœ€æ±‚æ–¹å‘å·²å®šï¼Œç»†èŠ‚å¾…å®Œå–„
> - **å ä½** = ä»…é¢„ç•™ä½ç½®ï¼Œå°šæ— è¯¦ç»†è§„èŒƒ
>
> å®é™…ä»£ç å®ç°è¿›åº¦è¯·æŸ¥é˜…é¡¹ç›®ä»“åº“çš„ Issue/Milestoneã€‚

### 20.1 ç‰ˆæœ¬äº¤ä»˜èŒƒå›´æ€»è¡¨ (éœ€æ±‚çŠ¶æ€)

| èƒ½åŠ›æ¨¡å— | MVP | v1.0-v1.5 | v1.6-v1.8 | v1.9+ (è§„åˆ’) | çŠ¶æ€è¯´æ˜ |
|----------|-----|-----------|-----------|--------------|----------|
| **æ ¸å¿ƒå‘å¸ƒ** |
| Excel å¯¼å…¥ä¸æ ¡éªŒ | âœ… | âœ… | âœ… | - | å·²äº¤ä»˜ |
| æœ‹å‹åœˆå‘å¸ƒæ‰§è¡Œ | âœ… | âœ… | âœ… | - | å·²äº¤ä»˜ |
| ç¾¤æ¶ˆæ¯å‘å¸ƒæ‰§è¡Œ | âœ… | âœ… | âœ… | - | å·²äº¤ä»˜ |
| ç¾¤åäºŒæ¬¡ç¡®è®¤ | âœ… | âœ… | âœ… | - | å·²äº¤ä»˜ |
| å‰ªè´´æ¿å®‰å…¨ç®¡ç† | âœ… | âœ… | âœ… | - | å·²äº¤ä»˜ |
| **è°ƒåº¦ä¸é˜Ÿåˆ—** |
| æ‰‹åŠ¨è§¦å‘å‘é€ | âœ… | âœ… | âœ… | - | å·²äº¤ä»˜ |
| å®šæ—¶å‘å¸ƒè°ƒåº¦ | - | âœ… | âœ… | - | å·²äº¤ä»˜ |
| æ‹–æ‹½æ’åº | - | âœ… | âœ… | - | å·²äº¤ä»˜ |
| æš‚åœ/è·³è¿‡/ç«‹å³æ‰§è¡Œ | - | âœ… | âœ… | - | å·²äº¤ä»˜ |
| **çŠ¶æ€ä¸é€šçŸ¥** |
| ä»»åŠ¡çŠ¶æ€ç®¡ç† | âœ… | âœ… | âœ… | - | å·²äº¤ä»˜ |
| åŸºç¡€æ—¥å¿— | âœ… | âœ… | âœ… | - | å·²äº¤ä»˜ |
| é‚®ä»¶å¤±è´¥é€šçŸ¥ | - | âœ… | âœ… | - | å·²äº¤ä»˜ |
| å›æ‰§æ–‡ä»¶ç”Ÿæˆ | - | âœ… | âœ… | - | å·²äº¤ä»˜ |
| **é£æ§ä¸å®‰å…¨** |
| ç†”æ–­å™¨ | - | âœ… | âœ… | - | å·²äº¤ä»˜ |
| æˆªå›¾å¼¹çª—æ£€æµ‹ | - | âœ… | âœ… | - | å·²äº¤ä»˜ |
| é£æ§åœæœºç­–ç•¥ | - | - | âœ… | - | v1.7 äº¤ä»˜ |
| å®‰å…¨/æµ‹è¯•/æ¼”ç»ƒæ¨¡å¼ | - | - | âœ… | - | v1.7 äº¤ä»˜ |
| æ¨¡å¼åˆ‡æ¢æƒé™å®¡è®¡ | - | - | âœ… | - | v1.8 äº¤ä»˜ |
| **æ•°æ®ä¸éšç§** |
| éšç§è„±æ• | - | âœ… | âœ… | - | å·²äº¤ä»˜ |
| å›æ‰§åˆ†å‘ (ä¸‰ç‰ˆæœ¬) | - | - | âœ… | - | v1.7 äº¤ä»˜ |
| è¯æ®ä¿å…¨ | - | - | âœ… | - | v1.4 äº¤ä»˜ |
| **æ¨¡æ¿ä¸é€‰æ‹©å™¨** |
| é€‰æ‹©å™¨é…ç½®å¤–éƒ¨åŒ– | - | âœ… | âœ… | - | å·²äº¤ä»˜ |
| æ¨¡æ¿åŒ…ç­¾åéªŒè¯ | - | - | âœ… | - | v1.4 äº¤ä»˜ |
| æ¨¡æ¿çƒ­æ›´æ–° | - | - | âœ… | - | v1.4 äº¤ä»˜ |
| **ç¯å¢ƒä¸å…¼å®¹** |
| ç¯å¢ƒè‡ªæ£€ | - | âœ… | âœ… | - | å·²äº¤ä»˜ |
| è¿›ç¨‹å®ˆæŠ¤ | - | âœ… | âœ… | - | å·²äº¤ä»˜ |
| å¤šæ˜¾ç¤ºå™¨æ”¯æŒ | - | - | âœ… | - | v1.3 äº¤ä»˜ |
| DPI ç¼©æ”¾é€‚é… | - | - | âœ… | - | v1.3 äº¤ä»˜ |
| **ä»¥ä¸‹ä¸ºè§„åˆ’/å ä½èƒ½åŠ›** |
| æ•°æ®ç»Ÿè®¡é¢æ¿ | - | - | - | ğŸ“‹ | è§„åˆ’ä¸­ |
| API æ•°æ®æº | - | - | - | ğŸ“‹ | è§„åˆ’ä¸­ |
| åŠ¨æ€é€Ÿç‡è°ƒèŠ‚ | - | - | - | ğŸ“‹ | è§„åˆ’ä¸­ |
| å¤šå¾®ä¿¡å®ä¾‹ | - | - | - | ğŸ“‹ | è§„åˆ’ä¸­ |

> **å›¾ä¾‹**: âœ… å·²äº¤ä»˜ | ğŸ“‹ è§„åˆ’ä¸­ | - ä¸é€‚ç”¨

### 20.2 v1.9 ç‰ˆæœ¬äº¤ä»˜ç›®æ ‡

**æœ¬ç‰ˆæœ¬èšç„¦**: é—­ç¯è¡¥å…¨ä¸å¯è¿ç»´æ€§æå‡

| äº¤ä»˜é¡¹ | ä¼˜å…ˆçº§ | è¯´æ˜ | éªŒæ”¶æ ‡å‡† |
|--------|--------|------|----------|
| ç”Ÿäº§é»˜è®¤é…ç½®æ€»è¡¨ | P0 | ç»Ÿä¸€æ‰€æœ‰æ•£è½çš„é»˜è®¤å€¼ | é…ç½®æ–‡ä»¶æœ‰å•ä¸€æ¥æº |
| æ ¸å¿ƒæµç¨‹æ—¶åºå›¾ | P0 | å‘å¸ƒä¸»æµç¨‹å¯è§†åŒ– | è¦†ç›–æ­£å¸¸+5ç§å¼‚å¸¸åˆ†æ”¯ |
| å¼‚å¸¸åé¦ˆç­–ç•¥çŸ©é˜µ | P0 | ç»Ÿä¸€ç”¨æˆ·æ„ŸçŸ¥æ–¹å¼ | UI/æ—¥å¿—/é‚®ä»¶/çŠ¶æ€æ å¯¹é½ |
| ä¾èµ–é™çº§ç­–ç•¥ | P0 | å¯é€‰ä¾èµ–ç¼ºå¤±æ—¶çš„è¡Œä¸º | å¯åŠ¨æ—¶æ˜ç¡®æç¤º |
| æ•°æ®æ¸…ç†/ä¿å…¨çŸ©é˜µ | P1 | ç•™å­˜ç­–ç•¥å•ä¸€æ¥æº | æ¸…ç†è„šæœ¬å¯ç”¨ |
| å¯¹å¤–è¾“å‡ºè„±æ•å­—æ®µè¡¨ | P1 | é˜²æ¼è„±æ• | å›æ‰§/é‚®ä»¶/Webhook å­—æ®µæ˜ç¡® |
| Operator åˆå§‹åŒ–æµç¨‹ | P1 | é¦–æ¬¡éƒ¨ç½²å¯æ‰§è¡Œ | å«å¯†ç é‡ç½®æµç¨‹ |
| çŠ¶æ€æœ¯è¯­ç»Ÿä¸€ | P1 | running/executing ç­‰å¯¹é½ | ä»£ç /UI/æ•°æ®åº“ä¸€è‡´ |
| å¤šæ˜¾ç¤ºå™¨éªŒè¯çŸ©é˜µ | P2 | å…¼å®¹æ€§æµ‹è¯•åŸºå‡† | 3ç§å…¸å‹é…ç½®éªŒè¯é€šè¿‡ |
| å¿«é€Ÿä¸Šæ‰‹æŒ‡å— | P2 | é™ä½ä¸Šæ‰‹é—¨æ§› | 1é¡µçº¸å¯å®Œæˆé¦–æ¬¡è¿è¡Œ |

### 20.3 è§„åˆ’èƒ½åŠ›è¯´æ˜ (éæœ¬ç‰ˆæœ¬äº¤ä»˜)

ä»¥ä¸‹èƒ½åŠ›åœ¨æ–‡æ¡£ä¸­æœ‰å®šä¹‰ä½† **ä¸åœ¨ v1.9 äº¤ä»˜èŒƒå›´å†…**, ä»…ä½œä¸ºæ¶æ„é¢„ç•™:

| èƒ½åŠ› | å½“å‰çŠ¶æ€ | é¢„è®¡ç‰ˆæœ¬ | å¤‡æ³¨ |
|------|----------|----------|------|
| æ•°æ®ç»Ÿè®¡é¢æ¿ | æ¥å£é¢„ç•™ | v2.0+ | UI æœªå®ç° |
| API æ•°æ®æº | å®‰å…¨è§„èŒƒå·²å®šä¹‰ | v2.0+ | ç«¯ç‚¹æœªå®ç° |
| åŠ¨æ€é€Ÿç‡è°ƒèŠ‚ | æ¡†æ¶å·²å®šä¹‰ | v2.1+ | ç®—æ³•æœªå®ç° |
| å¤šå¾®ä¿¡å®ä¾‹ | æœªå¼€å§‹ | v3.0+ | éœ€æ¶æ„é‡æ„ |
| BCrypt å¯†ç æ ¡éªŒ | æ¥å£å·²å®šä¹‰ | v1.9 å¯é€‰ | ä¾èµ– bcrypt åº“ |

### 20.4 å®æ–½é‡Œç¨‹ç¢‘

```
v1.9 å¼€å‘è®¡åˆ’ (é¢„ä¼°)
â”œâ”€â”€ Phase 1: é…ç½®ä¸æ–‡æ¡£é—­ç¯
â”‚   â”œâ”€â”€ ç”Ÿäº§é»˜è®¤é…ç½®æ€»è¡¨
â”‚   â”œâ”€â”€ ä¾èµ–é™çº§ç­–ç•¥
â”‚   â””â”€â”€ å¿«é€Ÿä¸Šæ‰‹æŒ‡å—
â”‚
â”œâ”€â”€ Phase 2: æµç¨‹ä¸åé¦ˆé—­ç¯
â”‚   â”œâ”€â”€ æ ¸å¿ƒæµç¨‹æ—¶åºå›¾
â”‚   â”œâ”€â”€ å¼‚å¸¸åé¦ˆç­–ç•¥çŸ©é˜µ
â”‚   â””â”€â”€ çŠ¶æ€æœ¯è¯­ç»Ÿä¸€
â”‚
â”œâ”€â”€ Phase 3: æ•°æ®ä¸å®‰å…¨é—­ç¯
â”‚   â”œâ”€â”€ æ•°æ®æ¸…ç†/ä¿å…¨çŸ©é˜µ
â”‚   â”œâ”€â”€ å¯¹å¤–è¾“å‡ºè„±æ•å­—æ®µè¡¨
â”‚   â””â”€â”€ Operator åˆå§‹åŒ–æµç¨‹
â”‚
â””â”€â”€ Phase 4: éªŒè¯ä¸ä¼˜åŒ–
    â”œâ”€â”€ å¤šæ˜¾ç¤ºå™¨éªŒè¯çŸ©é˜µ
    â””â”€â”€ ç«¯åˆ°ç«¯æµ‹è¯•
```

### 20.5 ç‰ˆæœ¬ä¸æ–‡æ¡£å¯¹é½è§„åˆ™

> **å¼ºåˆ¶è¦æ±‚**: æ¯æ¬¡ç‰ˆæœ¬å‘å¸ƒæ—¶å¿…é¡»æ›´æ–°æ­¤è¡¨ï¼Œç¡®ä¿æ–‡æ¡£ä¸å®é™…äº¤ä»˜ä¸€è‡´ã€‚

1. **å·²äº¤ä»˜èƒ½åŠ›**: å¿…é¡»æœ‰å¯¹åº”çš„ä»£ç å®ç°å’Œæµ‹è¯•ç”¨ä¾‹
2. **è§„åˆ’ä¸­èƒ½åŠ›**: åœ¨æ–‡æ¡£ä¸­ç”¨ `[è§„åˆ’]` æˆ– `[å ä½]` æ ‡æ³¨
3. **åºŸå¼ƒèƒ½åŠ›**: ä»æ–‡æ¡£ä¸­ç§»é™¤æˆ–æ ‡æ³¨ `[åºŸå¼ƒ]`
4. **ç‰ˆæœ¬å·è§„åˆ™**:
   - `v1.x`: åŠŸèƒ½è¿­ä»£
   - `v2.x`: æ¶æ„å‡çº§
   - `v3.x`: é‡å¤§é‡æ„

---

## äºŒåä¸€ã€å¼€å‘è·¯çº¿å›¾

### 21.1 MVP (æœ€å°å¯è¡Œäº§å“)

| åŠŸèƒ½ | ä¼˜å…ˆçº§ | è¯´æ˜ |
|------|--------|------|
| Excel è§£æ + æ ¡éªŒ | P0 | æ•°æ®å…¥å£ |
| SQLite ä»»åŠ¡ç®¡ç† | P0 | çŠ¶æ€æŒä¹…åŒ– |
| å‰ªè´´æ¿å®‰å…¨ç®¡ç† | P0 | é˜²é”™ä¹± |
| ç¾¤å‘æ¶ˆæ¯æ‰§è¡Œå™¨ | P0 | æ ¸å¿ƒåŠŸèƒ½ |
| ç¾¤åäºŒæ¬¡ç¡®è®¤ | P0 | å®‰å…¨æ ¡éªŒ |
| æœ‹å‹åœˆæ‰§è¡Œå™¨ | P0 | æ ¸å¿ƒåŠŸèƒ½ |
| æ‰‹åŠ¨è§¦å‘å‘é€ | P0 | åŸºç¡€æ“ä½œ |
| åŸºç¡€æ—¥å¿— | P0 | é—®é¢˜æ’æŸ¥ |
| ç®€å•å®šæ—¶å‘å¸ƒ | P1 | åŸºç¡€è°ƒåº¦ |
| å¤±è´¥é‡è¯• | P1 | å®¹é”™ |

### 21.2 åŠ å›ºé˜¶æ®µ

| åŠŸèƒ½ | ä¼˜å…ˆçº§ | è¯´æ˜ |
|------|--------|------|
| å‘å¸ƒé¢„è§ˆ | P1 | ç”¨æˆ·ä½“éªŒ |
| æ‹–æ‹½æ’åº | P1 | çµæ´»è°ƒæ•´ |
| æš‚åœ/è·³è¿‡/ç«‹å³æ‰§è¡Œ | P1 | é˜Ÿåˆ—æ§åˆ¶ |
| æˆªå›¾ + å¼¹çª—æ£€æµ‹ | P1 | é£æ§æ„ŸçŸ¥ |
| ç†”æ–­å™¨ | P1 | è‡ªæˆ‘ä¿æŠ¤ |
| é‚®ä»¶å¤±è´¥é€šçŸ¥ | P1 | åŠæ—¶å‘Šè­¦ |
| ç¯å¢ƒè‡ªæ£€ | P1 | å¯åŠ¨æ£€æŸ¥ |
| è¿›ç¨‹å®ˆæŠ¤ | P1 | è‡ªåŠ¨æ¢å¤ |
| å›æ‰§æ–‡ä»¶ç”Ÿæˆ | P1 | åé¦ˆé—­ç¯ |

### 21.3 è¿›é˜¶é˜¶æ®µ

| åŠŸèƒ½ | ä¼˜å…ˆçº§ | è¯´æ˜ |
|------|--------|------|
| æ•°æ®ç»Ÿè®¡é¢æ¿ | P2 | è¿è¥åˆ†æ |
| æ¯æ—¥æ±‡æ€»é‚®ä»¶ | P2 | å®šæœŸæŠ¥å‘Š |
| å®‰å…¨æ¨¡å¼/æµ‹è¯•æ¨¡å¼ | P2 | é£é™©æ§åˆ¶ |
| å¤šç§å®šæ—¶æ¨¡å¼ | P2 | çµæ´»è°ƒåº¦ |
| API æ•°æ®æº | P2 | è‡ªåŠ¨åŒ–å‡çº§ |
| UI é€‰æ‹©å™¨çƒ­æ›´æ–° | P2 | ç»´æŠ¤ä¾¿æ· |

### 21.4 ä¼˜åŒ–é˜¶æ®µ

| åŠŸèƒ½ | ä¼˜å…ˆçº§ | è¯´æ˜ |
|------|--------|------|
| å¤šåˆ†è¾¨ç‡é²æ£’æ€§ | P3 | å…¼å®¹æ€§ |
| æ¨¡æ¿ç®¡ç†å·¥å…· | P3 | ç»´æŠ¤æ•ˆç‡ |
| æ‰¹é‡ç¾¤ç®¡ç† | P3 | ä¾¿æ·æ“ä½œ |
| é…ç½®åŠ å¯† | P3 | å®‰å…¨åŠ å›º |
| æ“ä½œè½¨è¿¹ä¼˜åŒ– | P3 | æ›´æ‹ŸäººåŒ– |
| åŠ¨æ€é€Ÿç‡è°ƒèŠ‚ | P3 | æ™ºèƒ½é˜²æ§ |

---

## äºŒåäºŒã€æµ‹è¯•ç­–ç•¥

### 22.1 Dry-run æ¨¡å¼

```python
class DryRunExecutor:
    """æ¼”ç»ƒæ¨¡å¼æ‰§è¡Œå™¨"""

    def send_moment(self, content):
        logger.info(f"[DRY-RUN] æ¨¡æ‹Ÿå‘é€æœ‹å‹åœˆ: {content.code}")
        logger.info(f"  æ–‡æ¡ˆ: {content.text[:50]}...")
        logger.info(f"  å›¾ç‰‡: {len(content.images)} å¼ ")
        return {"status": "dry-run", "would_succeed": True}

    def send_group_message(self, group_name, content):
        logger.info(f"[DRY-RUN] æ¨¡æ‹Ÿå‘é€ç¾¤æ¶ˆæ¯")
        logger.info(f"  ç›®æ ‡ç¾¤: {group_name}")
        logger.info(f"  æ–‡æ¡ˆ: {content.text[:50]}...")
        return {"status": "dry-run", "would_succeed": True}
```

### 22.2 æµ‹è¯•æ•°æ®é›†

| åœºæ™¯ | é¢„æœŸè¡Œä¸º |
|------|----------|
| æ­£å¸¸æ•°æ® | æ­£å¸¸å…¥é˜Ÿ |
| ç¼ºå°‘å¿…å¡«å­—æ®µ | æ ‡è®°æ ¡éªŒå¤±è´¥ |
| å›¾ç‰‡è·¯å¾„ä¸å­˜åœ¨ | æ ‡è®°éœ€äººå·¥ç¡®è®¤ |
| å›¾ç‰‡æ•°é‡ä¸è¶³ | è­¦å‘Šä½†å¯ç»§ç»­ |
| è¶…é•¿æ–‡æ¡ˆ | æˆªæ–­æˆ–è­¦å‘Š |
| å¤šæ¸ é“æ··æ’ | åˆ†åˆ«å¤„ç† |
| ç‰¹æ®Šå­—ç¬¦æ–‡æ¡ˆ | æ­£å¸¸å¤„ç† |
| é‡å¤ä»»åŠ¡ | å»é‡è·³è¿‡ |

---

## äºŒåä¸‰ã€æŠ€æœ¯ä¾èµ–

### 23.1 æ ¸å¿ƒä¾èµ–

```
# requirements.txt
#
# å®˜æ–¹å®Œæ•´ä¾èµ–æ¸…å• - å·²åŒ…å«æ‰€æœ‰å¿…éœ€ä¾èµ–
# å®‰è£…å‘½ä»¤: pip install -r requirements.txt
#

# === è‡ªåŠ¨åŒ– ===
uiautomation>=2.0.18      # UI è‡ªåŠ¨åŒ– (æ ¸å¿ƒ)
pywinauto>=0.6.8          # Windows çª—å£æ§åˆ¶
pyautogui>=0.9.54         # æ¨¡æ‹Ÿé¼ æ ‡é”®ç›˜
psutil>=5.9.0             # è¿›ç¨‹ç®¡ç†

# === å›¾åƒå¤„ç† ===
opencv-python>=4.8.0      # å›¾åƒè¯†åˆ«
pillow>=10.0.0            # å›¾ç‰‡å¤„ç†
pywin32>=306              # Windows å‰ªè´´æ¿

# === GUI ===
PySide6>=6.6.0            # Qt GUI æ¡†æ¶

# === æ•°æ®å¤„ç† ===
openpyxl>=3.1.0           # Excel è¯»å–
pyyaml>=6.0               # YAML é…ç½®

# === è°ƒåº¦ ===
apscheduler>=3.10.0       # å®šæ—¶ä»»åŠ¡

# === ç½‘ç»œä¸å®‰å…¨ ===
requests>=2.31.0          # HTTP è¯·æ±‚
cryptography>=41.0.0      # ç­¾åéªŒè¯ (RSA-PSS) [v1.4+å¿…éœ€]
certifi>=2023.7.22        # HTTPS è¯ä¹¦éªŒè¯ [v1.4+å¿…éœ€]

# === é€šçŸ¥ ===
pyttsx3>=2.90             # è¯­éŸ³é€šçŸ¥ (TTS)

# === å…¶ä»– ===
pyperclip>=1.8.2          # å‰ªè´´æ¿æ–‡æœ¬
keyring>=24.0.0           # å¯†ç å®‰å…¨å­˜å‚¨
pytz>=2023.3              # æ—¶åŒºå¤„ç†

# === å¯é€‰ä¾èµ– (å–æ¶ˆæ³¨é‡Šå¯ç”¨) ===
# ntplib>=0.4.0           # NTP æ—¶é—´åŒæ­¥ (å¯é€‰)
# pytesseract>=0.3.10     # OCR é£æ§æ£€æµ‹ (å¯é€‰ï¼Œéœ€å®‰è£… Tesseract)
```

### 23.2 å®‰è£…æŒ‡å¼•

> **é‡è¦**: ä»…ä½¿ç”¨ä»¥ä¸‹å®˜æ–¹å®‰è£…å‘½ä»¤ï¼Œä¸è¦æ··ç”¨å…¶ä»–æ–¹å¼ã€‚

#### 23.2.1 å”¯ä¸€å®˜æ–¹å®‰è£…å‘½ä»¤

```bash
# å®˜æ–¹å®‰è£…å‘½ä»¤ (æ¨è)
pip install -r requirements.txt
```

æ­¤å‘½ä»¤ä¼šå®‰è£…æ‰€æœ‰**å¿…éœ€ä¾èµ–**ï¼ŒåŒ…æ‹¬:
- è‡ªåŠ¨åŒ–æ ¸å¿ƒ: uiautomation, pywinauto, pyautogui
- å®‰å…¨ç›¸å…³: cryptography, certifi (v1.4+å¿…éœ€)
- GUI/æ•°æ®/è°ƒåº¦ç­‰å®Œæ•´ä¾èµ–

#### 23.2.2 å¯é€‰ä¾èµ–

å¯é€‰ä¾èµ–ä¸åœ¨é»˜è®¤ requirements.txt ä¸­ï¼ŒæŒ‰éœ€æ‰‹åŠ¨å®‰è£…ï¼š

```bash
# NTP æ—¶é—´åŒæ­¥ (å¯é€‰)
pip install ntplib>=0.4.0

# OCR é£æ§æ£€æµ‹ (å¯é€‰ï¼Œéœ€å…ˆå®‰è£… Tesseract-OCR)
pip install pytesseract>=0.3.10
```

#### 23.2.3 ä¾èµ–åˆ†ç±»è¯´æ˜

| ä¾èµ–åŒ… | ç‰ˆæœ¬ | å¿…éœ€æ€§ | ç”¨é€” | å¤‡æ³¨ |
|--------|------|--------|------|------|
| `cryptography` | >=41.0.0 | **å¿…éœ€** | æ¨¡æ¿åŒ…ç­¾åéªŒè¯ (RSA-PSS) | å·²çº³å…¥ requirements.txt |
| `certifi` | >=2023.7.22 | **å¿…éœ€** | HTTPS è¯ä¹¦éªŒè¯ | å·²çº³å…¥ requirements.txt |
| `pyttsx3` | >=2.90 | **å¿…éœ€** | è¯­éŸ³é€šçŸ¥ (TTS) | Windows ä½¿ç”¨å†…ç½® SAPI5 |
| `ntplib` | >=0.4.0 | å¯é€‰ | NTP æ—¶é—´åŒæ­¥ | æœªå®‰è£…æ—¶è‡ªåŠ¨è·³è¿‡ |
| `pytesseract` | >=0.3.10 | å¯é€‰ | OCR é£æ§æ£€æµ‹ | éœ€é¢å¤–å®‰è£… Tesseract |

#### 23.2.4 ç‰ˆæœ¬é”å®š (ç”Ÿäº§ç¯å¢ƒæ¨è)

ç”Ÿäº§ç¯å¢ƒå»ºè®®ä½¿ç”¨ `pip freeze` é”å®šç‰ˆæœ¬ï¼š

```bash
# ç”Ÿæˆé”å®šæ–‡ä»¶
pip freeze > requirements.lock

# ä»é”å®šæ–‡ä»¶å®‰è£… (ç¡®ä¿ç‰ˆæœ¬ä¸€è‡´)
pip install -r requirements.lock
```

**å¯é€‰ä¾èµ–å¤„ç†:**

```python
# utils/optional_imports.py

def try_import_ntplib():
    """å°è¯•å¯¼å…¥ ntplib (å¯é€‰ä¾èµ–)"""
    try:
        import ntplib
        return ntplib
    except ImportError:
        logger.warning(
            "ntplib æœªå®‰è£…, NTP æ—¶é—´åŒæ­¥åŠŸèƒ½ä¸å¯ç”¨ã€‚"
            "å®‰è£…æ–¹å¼: pip install ntplib"
        )
        return None

# åœ¨éœ€è¦ä½¿ç”¨ NTP çš„åœ°æ–¹
ntplib = try_import_ntplib()

def sync_time():
    """åŒæ­¥ NTP æ—¶é—´"""
    if ntplib is None:
        logger.info("è·³è¿‡ NTP åŒæ­¥ (ntplib æœªå®‰è£…)")
        return None

    try:
        client = ntplib.NTPClient()
        response = client.request('pool.ntp.org', version=3)
        return datetime.fromtimestamp(response.tx_time)
    except Exception as e:
        logger.warning(f"NTP åŒæ­¥å¤±è´¥: {e}")
        return None
```

### 23.3 ä¾èµ–å®‰å…¨è¯´æ˜

| ä¾èµ– | å®‰å…¨ç›¸å…³ | å¤‡æ³¨ |
|------|----------|------|
| `cryptography` | ç”¨äºç­¾åéªŒè¯ | ç¡®ä¿ä» PyPI å®‰è£…ï¼Œé¿å…ä¾›åº”é“¾æ”»å‡» |
| `certifi` | æä¾› CA è¯ä¹¦ | å®šæœŸæ›´æ–°ä»¥åŒ…å«æœ€æ–°æ ¹è¯ä¹¦ |
| `requests` | HTTPS é€šä¿¡ | é…åˆ certifi è¿›è¡Œè¯ä¹¦éªŒè¯ |
| `keyring` | å¯†ç å­˜å‚¨ | ä½¿ç”¨ç³»ç»Ÿå‡­æ®ç®¡ç†å™¨åŠ å¯†å­˜å‚¨ |

**ä¾èµ–æ›´æ–°å»ºè®®:**

```bash
# å®šæœŸæ£€æŸ¥å®‰å…¨æ›´æ–°
pip list --outdated

# æ›´æ–°å®‰å…¨ç›¸å…³ä¾èµ–
pip install --upgrade cryptography certifi requests
```

### 23.4 ä¾èµ–é™çº§ç­–ç•¥ä¸è¿ç»´æŒ‡å¼•

> **æ ¸å¿ƒåŸåˆ™**: å¯é€‰ä¾èµ–ç¼ºå¤±æ—¶å¿…é¡»æ˜ç¡®é™çº§è¡Œä¸ºï¼Œå¯åŠ¨æ—¶æ¸…æ™°æç¤ºç”¨æˆ·ã€‚

#### 23.4.1 ä¾èµ–åˆ†çº§ä¸é™çº§çŸ©é˜µ

| ä¾èµ– | çº§åˆ« | ç”¨äºåŠŸèƒ½ | ç¼ºå¤±æ—¶è¡Œä¸º | å¯åŠ¨æç¤º |
|------|------|----------|------------|----------|
| `uiautomation` | **å¿…éœ€** | æ ¸å¿ƒè‡ªåŠ¨åŒ– | å¯åŠ¨å¤±è´¥ | é”™è¯¯å¼¹çª—ï¼Œé˜»æ­¢å¯åŠ¨ |
| `pywinauto` | **å¿…éœ€** | çª—å£æ§åˆ¶ | å¯åŠ¨å¤±è´¥ | é”™è¯¯å¼¹çª—ï¼Œé˜»æ­¢å¯åŠ¨ |
| `pyautogui` | **å¿…éœ€** | é¼ æ ‡/é”®ç›˜æ¨¡æ‹Ÿ | å¯åŠ¨å¤±è´¥ | é”™è¯¯å¼¹çª—ï¼Œé˜»æ­¢å¯åŠ¨ |
| `PySide6` | **å¿…éœ€** | GUI ç•Œé¢ | å¯åŠ¨å¤±è´¥ | é”™è¯¯å¼¹çª—ï¼Œé˜»æ­¢å¯åŠ¨ |
| `cryptography` | **å¿…éœ€** | æ¨¡æ¿ç­¾åéªŒè¯ | å¯åŠ¨å¤±è´¥ | é”™è¯¯å¼¹çª—ï¼Œé˜»æ­¢å¯åŠ¨ |
| `certifi` | **å¿…éœ€** | HTTPS è¯ä¹¦ | å¯åŠ¨å¤±è´¥ | é”™è¯¯å¼¹çª—ï¼Œé˜»æ­¢å¯åŠ¨ |
| `ntplib` | å¯é€‰ | NTP æ—¶é—´åŒæ­¥ | è·³è¿‡æ—¶é—´æ ¡éªŒ | é»„è‰²è­¦å‘Šï¼Œå¯ç»§ç»­ |
| `pytesseract` | å¯é€‰ | OCR é£æ§æ£€æµ‹ | ç¦ç”¨ OCR æ£€æµ‹ | é»„è‰²è­¦å‘Šï¼Œå¯ç»§ç»­ |
| `bcrypt` | å¯é€‰ | å¯†ç å“ˆå¸Œå¢å¼º | å›é€€åˆ° SHA256 | æ—¥å¿—æç¤ºï¼Œé™é»˜ç»§ç»­ |

#### 23.4.2 å¯åŠ¨æ—¶ä¾èµ–æ ¡éªŒæµç¨‹

```
ç¨‹åºå¯åŠ¨
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ£€æŸ¥å¿…éœ€ä¾èµ–    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚ å…¨éƒ¨å­˜åœ¨?â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚
    Yes  â”‚  No
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â–¼         â–¼
ç»§ç»­å¯åŠ¨   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚      â”‚ æ˜¾ç¤ºé”™è¯¯å¼¹çª— â”‚
    â”‚      â”‚ åˆ—å‡ºç¼ºå¤±ä¾èµ– â”‚
    â”‚      â”‚ æä¾›å®‰è£…å‘½ä»¤ â”‚
    â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚              â”‚
    â”‚              â–¼
    â”‚         é€€å‡ºç¨‹åº
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ£€æŸ¥å¯é€‰ä¾èµ–    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚ æœ‰ç¼ºå¤±? â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚
    Yes  â”‚  No
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â–¼         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  æ­£å¸¸å¯åŠ¨
â”‚æ˜¾ç¤ºè­¦å‘Š  â”‚
â”‚åˆ—å‡ºç¼ºå¤±  â”‚
â”‚è¯´æ˜å½±å“  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
  ç»§ç»­å¯åŠ¨ (åŠŸèƒ½é™çº§)
```

#### 23.4.3 ç”¨æˆ·æç¤ºè§„èŒƒ

**å¿…éœ€ä¾èµ–ç¼ºå¤±å¼¹çª—:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [é”™è¯¯] ç¼ºå°‘å¿…éœ€ä¾èµ–                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  ä»¥ä¸‹ä¾èµ–æœªå®‰è£…ï¼Œç¨‹åºæ— æ³•å¯åŠ¨:                   â”‚
â”‚                                                 â”‚
â”‚  âœ— cryptography - æ¨¡æ¿ç­¾åéªŒè¯                  â”‚
â”‚  âœ— certifi - HTTPS è¯ä¹¦éªŒè¯                     â”‚
â”‚                                                 â”‚
â”‚  è¯·æ‰§è¡Œä»¥ä¸‹å‘½ä»¤å®‰è£…:                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ pip install -r requirements.txt         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                 â”‚
â”‚  [å¤åˆ¶å‘½ä»¤]                    [é€€å‡º]          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å¯é€‰ä¾èµ–ç¼ºå¤±æç¤º:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [è­¦å‘Š] éƒ¨åˆ†å¯é€‰åŠŸèƒ½ä¸å¯ç”¨                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  ä»¥ä¸‹å¯é€‰ä¾èµ–æœªå®‰è£…:                            â”‚
â”‚                                                 â”‚
â”‚  âš  ntplib - NTP æ—¶é—´åŒæ­¥ (å·²ç¦ç”¨)              â”‚
â”‚    å½±å“: æ— æ³•æ ¡éªŒç³»ç»Ÿæ—¶é—´åå·®                   â”‚
â”‚                                                 â”‚
â”‚  âš  pytesseract - OCR é£æ§æ£€æµ‹ (å·²ç¦ç”¨)         â”‚
â”‚    å½±å“: æ— æ³•é€šè¿‡æˆªå›¾ OCR æ£€æµ‹é£æ§çª—å£          â”‚
â”‚                                                 â”‚
â”‚  å¦‚éœ€å¯ç”¨ï¼Œè¯·å‚è€ƒæ–‡æ¡£å®‰è£…å¯é€‰ä¾èµ–ã€‚              â”‚
â”‚                                                 â”‚
â”‚  [ç»§ç»­å¯åŠ¨]            [æŸ¥çœ‹æ–‡æ¡£]               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 23.4.4 å¯é€‰åŠŸèƒ½ç¦ç”¨é…ç½®

å½“å¯é€‰ä¾èµ–ç¼ºå¤±æ—¶ï¼Œç›¸å…³é…ç½®è‡ªåŠ¨è®¾ä¸ºç¦ç”¨:

```yaml
# config.yaml - è¿è¡Œæ—¶è‡ªåŠ¨è°ƒæ•´

# ntplib ç¼ºå¤±æ—¶
time_sync:
  enabled: false  # è‡ªåŠ¨ç¦ç”¨
  _disabled_reason: "ntplib æœªå®‰è£…"

# pytesseract ç¼ºå¤±æ—¶
risk_detection:
  ocr_enabled: false  # è‡ªåŠ¨ç¦ç”¨
  _disabled_reason: "pytesseract æœªå®‰è£…"

# bcrypt ç¼ºå¤±æ—¶
authentication:
  hash_algorithm: "sha256"  # å›é€€åˆ° sha256
  _fallback_reason: "bcrypt æœªå®‰è£…"
```

##### å¯é€‰ä¾èµ–é™çº§è¡Œä¸ºè¯¦è§£

> **é‡è¦**: å¯é€‰ä¾èµ–ç¼ºå¤±æ—¶ï¼Œç›¸å…³åŠŸèƒ½ä¼š**é™é»˜é™çº§**è€ŒéæŠ¥é”™ã€‚ç”¨æˆ·å¿…é¡»ç†è§£é™çº§åçš„å½±å“ã€‚

| ä¾èµ– | ç¼ºå¤±æ—¶çš„é™çº§è¡Œä¸º | åŠŸèƒ½å½±å“ | ç”¨æˆ·æ„ŸçŸ¥ |
|------|------------------|----------|----------|
| `pytesseract` | OCR é£æ§æ£€æµ‹**å®Œå…¨ç¦ç”¨** | æ— æ³•è¯†åˆ«å¼¹çª—æ–‡å­— (å¦‚"è´¦å·å¼‚å¸¸")ï¼Œä»…èƒ½é€šè¿‡çª—å£æ ‡é¢˜æ£€æµ‹ | é¦–æ¬¡å¯åŠ¨è­¦å‘Šå¼¹çª— + çŠ¶æ€æ å¸¸é©»é»„è‰²æç¤º |
| `ntplib` | æ—¶é—´åŒæ­¥æ ¡éªŒç¦ç”¨ | ä¸éªŒè¯æœ¬æœºæ—¶é—´ä¸ NTP æœåŠ¡å™¨åå·®ï¼Œå®šæ—¶ä»»åŠ¡å¯èƒ½ä¸å‡† | æ—¥å¿—è­¦å‘Šï¼Œé™é»˜ç»§ç»­ |
| `bcrypt` | å¯†ç å“ˆå¸Œå›é€€åˆ° SHA256 | å®‰å…¨æ€§ç•¥ä½ï¼Œä½†ä»å¯ä½¿ç”¨ | æ—¥å¿—è­¦å‘Šï¼Œé™é»˜ç»§ç»­ |

##### OCR é£æ§é™çº§è¯¦ç»†è¯´æ˜

**RiskDetector åœ¨ OCR ç¼ºå¤±æ—¶çš„è¡Œä¸º:**

```python
class RiskDetector:
    """é£æ§æ£€æµ‹å™¨ (æ”¯æŒ OCR é™çº§)"""

    def __init__(self):
        self.ocr_available = self._check_ocr_available()
        if not self.ocr_available:
            logger.warning(
                "âš  pytesseract æœªå®‰è£…ï¼ŒOCR é£æ§æ£€æµ‹å·²ç¦ç”¨ã€‚\n"
                "ä»…ä¾èµ–çª—å£æ ‡é¢˜æ£€æµ‹ï¼Œå¯èƒ½æ¼æ£€æŸäº›é£é™©å¼¹çª—ã€‚\n"
                "å®‰è£…å‘½ä»¤: pip install pytesseract (éœ€å…ˆå®‰è£… Tesseract-OCR)"
            )

    def detect_risk(self, screenshot=None) -> RiskLevel:
        """æ£€æµ‹é£é™© (OCR ç¼ºå¤±æ—¶è‡ªåŠ¨é™çº§)"""
        # 1. çª—å£æ ‡é¢˜æ£€æµ‹ (å§‹ç»ˆæ‰§è¡Œ)
        title_risk = self._check_window_title()
        if title_risk != RiskLevel.NONE:
            return title_risk

        # 2. OCR æ–‡å­—æ£€æµ‹ (ä»…åœ¨ OCR å¯ç”¨æ—¶)
        if self.ocr_available and screenshot:
            ocr_risk = self._check_screenshot_ocr(screenshot)
            if ocr_risk != RiskLevel.NONE:
                return ocr_risk
        elif not self.ocr_available:
            # OCR ä¸å¯ç”¨ï¼Œè®°å½•é™çº§æ—¥å¿—
            logger.debug("è·³è¿‡ OCR æ£€æµ‹ (pytesseract æœªå®‰è£…)")

        return RiskLevel.NONE

    def _check_ocr_available(self) -> bool:
        """æ£€æŸ¥ OCR æ˜¯å¦å¯ç”¨"""
        try:
            import pytesseract
            pytesseract.get_tesseract_version()
            return True
        except (ImportError, OSError):
            return False
```

**é™çº§åçš„é£é™©:**

| æ£€æµ‹èƒ½åŠ› | OCR å¯ç”¨ | OCR ç¼ºå¤± |
|----------|----------|----------|
| çª—å£æ ‡é¢˜ "å¾®ä¿¡å®‰å…¨" | âœ… æ£€æµ‹ | âœ… æ£€æµ‹ |
| å¼¹çª—æŒ‰é’®æ–‡å­— "è´¦å·å¼‚å¸¸" | âœ… æ£€æµ‹ | âŒ æ¼æ£€ |
| éªŒè¯ç è¾“å…¥æ¡† | âœ… æ£€æµ‹ | âŒ æ¼æ£€ |
| é£é™©æç¤ºå¯¹è¯æ¡†å†…å®¹ | âœ… æ£€æµ‹ | âŒ æ¼æ£€ |

> **å»ºè®®**: ç”Ÿäº§ç¯å¢ƒå¼ºçƒˆå»ºè®®å®‰è£… Tesseract-OCR ä»¥è·å¾—å®Œæ•´çš„é£æ§æ£€æµ‹èƒ½åŠ›ã€‚

#### 23.4.5 Tesseract-OCR å®‰è£…æŒ‡å¼•

> **ç‰¹æ®Šè¯´æ˜**: pytesseract éœ€è¦å•ç‹¬å®‰è£… Tesseract-OCR ç¨‹åºã€‚

**Windows å®‰è£…:**

1. ä¸‹è½½ Tesseract-OCR: https://github.com/UB-Mannheim/tesseract/wiki
2. å®‰è£…åˆ°é»˜è®¤è·¯å¾„: `C:\Program Files\Tesseract-OCR`
3. æ·»åŠ åˆ°ç³»ç»Ÿ PATH (å®‰è£…ç¨‹åºé€šå¸¸è‡ªåŠ¨å®Œæˆ)
4. å®‰è£… Python åŒ…: `pip install pytesseract`

**éªŒè¯å®‰è£…:**

```bash
# æ£€æŸ¥ Tesseract æ˜¯å¦å¯ç”¨
tesseract --version

# æ£€æŸ¥ Python åŒ…æ˜¯å¦æ­£ç¡®é“¾æ¥
python -c "import pytesseract; print(pytesseract.get_tesseract_version())"
```

**å¦‚ä½•å…³é—­ OCR åŠŸèƒ½ (æ— éœ€å®‰è£…):**

```yaml
# config.yaml
risk_detection:
  ocr_enabled: false  # æ˜¾å¼å…³é—­ï¼Œå³ä½¿å®‰è£…äº†ä¹Ÿä¸ä½¿ç”¨
```

#### 23.4.6 ä¾èµ–å¥åº·æ£€æŸ¥å‘½ä»¤

æä¾›å‘½ä»¤è¡Œå·¥å…·æ£€æŸ¥ä¾èµ–çŠ¶æ€:

```bash
# æ£€æŸ¥æ‰€æœ‰ä¾èµ–çŠ¶æ€
python -m wechat_publisher.check_deps

# è¾“å‡ºç¤ºä¾‹:
# â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
# â”‚ ä¾èµ–æ£€æŸ¥æŠ¥å‘Š                                â”‚
# â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
# â”‚ å¿…éœ€ä¾èµ–:                                   â”‚
# â”‚   âœ“ uiautomation    1.0.0    å·²å®‰è£…        â”‚
# â”‚   âœ“ pywinauto       0.6.8    å·²å®‰è£…        â”‚
# â”‚   âœ“ pyautogui       0.9.54   å·²å®‰è£…        â”‚
# â”‚   âœ“ cryptography    41.0.0   å·²å®‰è£…        â”‚
# â”‚   âœ“ certifi         2023.7.22 å·²å®‰è£…       â”‚
# â”‚                                             â”‚
# â”‚ å¯é€‰ä¾èµ–:                                   â”‚
# â”‚   âš  ntplib          -        æœªå®‰è£…        â”‚
# â”‚   âš  pytesseract     -        æœªå®‰è£…        â”‚
# â”‚   âœ“ bcrypt          4.0.1    å·²å®‰è£…        â”‚
# â”‚                                             â”‚
# â”‚ å¤–éƒ¨ç¨‹åº:                                   â”‚
# â”‚   âš  Tesseract-OCR   -        æœªå®‰è£…        â”‚
# â”‚                                             â”‚
# â”‚ çŠ¶æ€: å¯è¿è¡Œ (éƒ¨åˆ†åŠŸèƒ½ä¸å¯ç”¨)               â”‚
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## äºŒåå››ã€é£é™©æ¸…å•

| é£é™© | å¯èƒ½æ€§ | å½±å“ | åº”å¯¹æªæ–½ |
|------|--------|------|----------|
| å¾®ä¿¡æ›´æ–°å¯¼è‡´å®šä½å¤±è´¥ | ä¸­ | é«˜ | ç‰ˆæœ¬æ£€æŸ¥ + é€‰æ‹©å™¨å¤–éƒ¨åŒ– + çƒ­æ›´æ–° |
| è¢«å¾®ä¿¡é£æ§ | ä½ | é«˜ | é¢‘ç‡é™åˆ¶ + æ‹ŸäººåŒ– + ç†”æ–­å™¨ |
| å‘é”™ç¾¤ | ä½ | æé«˜ | ç¾¤åäºŒæ¬¡ç¡®è®¤ (å¿…é¡»å®ç°) |
| å‰ªè´´æ¿è¢«ç¯¡æ”¹ | ä¸­ | é«˜ | å¤‡ä»½/æ¢å¤/éªŒè¯æœºåˆ¶ |
| ç¨‹åºå´©æºƒä¸¢å¤±ä»»åŠ¡ | ä¸­ | ä¸­ | SQLite æŒä¹…åŒ– + é‡å¯æ¢å¤ |
| ç½‘ç»œ/æ–‡ä»¶è®¿é—®å¤±è´¥ | ä¸­ | ä¸­ | é‡è¯•æœºåˆ¶ + æœ¬åœ°ç¼“å­˜ |
| å›¾ç‰‡ç¼ºå¤± | ä¸­ | ä½ | æ ¡éªŒ + äººå·¥ç¡®è®¤æµç¨‹ |
| æ—¶é’Ÿä¸åŒæ­¥ | ä½ | ä¸­ | NTP åŒæ­¥è¦æ±‚ + æ—¶åŒºç»Ÿä¸€ |

---

## äºŒåäº”ã€å®æ–½æ£€æŸ¥æ¸…å•

> **æ‘˜è¦**: éƒ¨ç½²å‰å¿…é¡»æ£€æŸ¥çš„å…³é”®é…ç½®é¡¹ï¼Œç¡®ä¿ç³»ç»Ÿå®‰å…¨ç¨³å®šè¿è¡Œã€‚

### 25.1 ç¯å¢ƒé…ç½®æ£€æŸ¥

| æ£€æŸ¥é¡¹ | é…ç½®ä½ç½® | æ£€æŸ¥è¦ç‚¹ | çŠ¶æ€ |
|--------|----------|----------|------|
| Python ç‰ˆæœ¬ | ç³»ç»Ÿ | >= 3.9 | [ ] |
| ä¾èµ–å®‰è£… | requirements.txt | æ‰§è¡Œä¸€é”®å®‰è£…å‘½ä»¤ | [ ] |
| å¾®ä¿¡ç‰ˆæœ¬ | PC å¾®ä¿¡ | æ”¯æŒçš„ç‰ˆæœ¬èŒƒå›´ | [ ] |
| æ˜¾ç¤ºå™¨è®¾ç½® | ç³»ç»Ÿ | ä¸»å±åˆ†è¾¨ç‡ >= 900x700 | [ ] |
| DPI ç¼©æ”¾ | ç³»ç»Ÿ | æ¨è 100% æˆ–å·²æµ‹è¯• | [ ] |
| æ—¶åŒºè®¾ç½® | ç³»ç»Ÿ | Asia/Shanghai | [ ] |

### 25.2 å®‰å…¨é…ç½®æ£€æŸ¥

| æ£€æŸ¥é¡¹ | é…ç½®ä½ç½® | ç”Ÿäº§ç¯å¢ƒè¦æ±‚ | çŠ¶æ€ |
|--------|----------|--------------|------|
| `allow_insecure` | api.https | `false` (å¼ºåˆ¶) | [ ] |
| `strict_domain_whitelist` | template_update | `true` (å¼ºåˆ¶) | [ ] |
| `verify_signature` | template_update | `true` (å¼ºåˆ¶) | [ ] |
| å…¬é’¥é…ç½® | keys/template_pub.pem | å·²éƒ¨ç½²æœ‰æ•ˆå…¬é’¥ | [ ] |
| HTTPS è¯ä¹¦ | certs/ | æœ‰æ•ˆè¯ä¹¦å·²é…ç½® | [ ] |
| ç¯å¢ƒå˜é‡ | APP_ENV | `production` | [ ] |

### 25.3 éšç§é…ç½®æ£€æŸ¥

| æ£€æŸ¥é¡¹ | é…ç½®ä½ç½® | ç”Ÿäº§ç¯å¢ƒé»˜è®¤ | çŠ¶æ€ |
|--------|----------|--------------|------|
| `mask_phone` | privacy | `true` (ä¸å¯å…³é—­) | [ ] |
| `mask_wechat_id` | privacy | `true` (ä¸å¯å…³é—­) | [ ] |
| `mask_group_name` | privacy | `true` | [ ] |
| `require_password` | receipts.full_version_access | `true` | [ ] |
| `full_version_retention` | privacy.receipts | 90 å¤© | [ ] |

### 25.4 è¿è¡Œæ¨¡å¼æ£€æŸ¥

| æ£€æŸ¥é¡¹ | é…ç½®ä½ç½® | æ£€æŸ¥è¦ç‚¹ | çŠ¶æ€ |
|--------|----------|----------|------|
| `run_mode` | config.yaml | `safe` (ç”Ÿäº§é»˜è®¤ï¼Œç¡®è®¤æ— è¯¯åå¯æ”¹ä¸º normal) | [ ] |
| æµ‹è¯•ç¾¤é…ç½® | modes.test.allowed_groups | å·²é…ç½®æµ‹è¯•ç¾¤ | [ ] |
| é€Ÿç‡é™åˆ¶ | modes.*.rate_limit | åˆç†çš„é—´éš”è®¾ç½® | [ ] |
| æ¯æ—¥é™é¢ | modes.safe.daily_limits | å·²è®¾ç½®é™é¢ | [ ] |

### 25.5 å›¾ç‰‡å¤„ç†æ£€æŸ¥

| æ£€æŸ¥é¡¹ | é…ç½®ä½ç½® | æ£€æŸ¥è¦ç‚¹ | çŠ¶æ€ |
|--------|----------|----------|------|
| `auto_compress` | image_processing | `true` | [ ] |
| `keep_original` | image_processing | `true` | [ ] |
| `gif_force_confirm` | image_processing | `true` | [ ] |
| ç¼“å­˜ç›®å½•æƒé™ | cache/ | å¯è¯»å†™ | [ ] |

### 25.6 API å®‰å…¨æ£€æŸ¥ (å¦‚å¯ç”¨)

| æ£€æŸ¥é¡¹ | é…ç½®ä½ç½® | æ£€æŸ¥è¦ç‚¹ | çŠ¶æ€ |
|--------|----------|----------|------|
| `base_url` åè®® | api | https:// | [ ] |
| IP ç™½åå• | api.ip_whitelist | å·²é…ç½®å…è®¸ IP | [ ] |
| Token/Secret | ç¯å¢ƒå˜é‡ | å·²é…ç½®ä¸”å®‰å…¨å­˜å‚¨ | [ ] |
| è¯ä¹¦æœ‰æ•ˆæœŸ | certs/ | æœªè¿‡æœŸ | [ ] |

### 25.7 éƒ¨ç½²å‰æœ€ç»ˆæ£€æŸ¥

```bash
# 1. éªŒè¯ä¾èµ–
pip check

# 2. éªŒè¯é…ç½®æ–‡ä»¶è¯­æ³•
python -c "import yaml; yaml.safe_load(open('config.yaml'))"

# 3. è¿è¡Œç¯å¢ƒè‡ªæ£€
python main.py --check-env

# 4. ä½¿ç”¨ dry-run æ¨¡å¼æµ‹è¯•
python main.py --mode=dry_run
```

---

*æ–‡æ¡£ç»“æŸ*
